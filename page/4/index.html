<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/logo.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.ico">
  <link rel="mask-icon" href="/images/logo.ico" color="#222">
  <meta name="google-site-verification" content="QrRqAEoLHOBZnSt7mRkhAt6dCoj3nREdeG7IU9IKL1E">
  <meta name="msvalidate.01" content="9A1D61A279FB6EF4CF3128BF57AFCBAC">
  <meta name="baidu-site-verification" content="5Iz7ysEFLe">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-corner-indicator.min.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ylyang.xyz","root":"/","scheme":"Gemini","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":{"enable":true,"onlypost":false,"loadingImg":null},"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"path":"./public/search.xml"};
  </script>

  <meta name="description" content="云山苍苍，江水泱泱；先生之风，山高水长。">
<meta property="og:type" content="website">
<meta property="og:title" content="静水流深的博客">
<meta property="og:url" content="ylyang.xyz/page/4/index.html">
<meta property="og:site_name" content="静水流深的博客">
<meta property="og:description" content="云山苍苍，江水泱泱；先生之风，山高水长。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ylyang">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="ylyang.xyz/page/4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>静水流深的博客 - ylyang's blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

   <script type="text/javascript" src="/js/myjs/clicklove.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">静水流深的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">ylyang's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">20</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">178</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">126</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ylyang"
      src="/images/tou2.jpg">
  <p class="site-author-name" itemprop="name">ylyang</p>
  <div class="site-description" itemprop="description">云山苍苍，江水泱泱；先生之风，山高水长。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">178</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yangyl7239" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yangyl7239" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanlin.young@gmail.com" title="E-Mail → mailto:yuanlin.young@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://ylyang.xyz/" title="https:&#x2F;&#x2F;ylyang.xyz">Home</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yangyl7239" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="ylyang.xyz/2020/01/09/VivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tou2.jpg">
      <meta itemprop="name" content="ylyang">
      <meta itemprop="description" content="云山苍苍，江水泱泱；先生之风，山高水长。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/VivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">VivadoHLS之优化案例分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="文章创建时间：2020-01-09 12:59:05" itemprop="dateCreated datePublished" datetime="2020-01-09T12:59:05+08:00">2020-01-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vivado-HLS/" itemprop="url" rel="index"><span itemprop="name">Vivado HLS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><h2 id="优化吞吐率的相关directive"><a href="#优化吞吐率的相关directive" class="headerlink" title="优化吞吐率的相关directive"></a>优化吞吐率的相关directive</h2><p>1、首先是pipeline，pipeline可以作用于函数，也可以作用于循环，当作用于循环的时候有个option是rewind，可以进一步的改善吞吐率</p>
<p>2、对于数组，可以使用Array_Partition，把数组分割成不同的部分，而这种分割的方式可以是block、cyclic、complete</p>
<p>3、对于loop，还可以采用UNROLL这种方式，这时候会有option、factor，他其实是控制循环的被复制成并行的几份，、去执行</p>
<p>4、DataFlow可以作用于函数，也可以作用于循环，实际是一种并发操作的方式，从这里可以看出，改善吞吐率其实是通过提高并行度来实现的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C1.PNG" alt="1"></p>
<h2 id="PipeLine作用于函数或者循环的不同"><a href="#PipeLine作用于函数或者循环的不同" class="headerlink" title="PipeLine作用于函数或者循环的不同"></a>PipeLine作用于函数或者循环的不同</h2><p>当pipeline作用于函数的时候，从<code>I / O</code>角度来看是连续的，当pipeline作用于循环的时候可以看到，本次循环和下次循环之间是有一个空挡的，从<code>I / O</code>角度来看有一个Bubble（无操作时间）</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C2.PNG" alt="2"></p>
<h2 id="对Latency进行优化"><a href="#对Latency进行优化" class="headerlink" title="对Latency进行优化"></a>对Latency进行优化</h2><p>对于Latency有一个directive就叫做Latency，他可以作用于function也可以作用于loop，此外还有一个loop_merge，就是把顺序的Loop合并在一起，还有一个Loop_Flatten其实是把嵌套的循环打平</p>
<p>这里需要说明，当使用Latency这个directive的时候，如果是针对循环，它指的是一次循环的Latency，如果我们期望得到的是完成整个循环所需要的Latency，先要做一个region的设置，针对region去设置Latency</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C3.PNG" alt="3"></p>
<h2 id="对Area进行优化"><a href="#对Area进行优化" class="headerlink" title="对Area进行优化"></a>对Area进行优化</h2><p>1、Data types和bit widths并不是directive，但是同样可以优化资源（面积）</p>
<p>Inline</p>
<p>Allocation</p>
<p>针对array可以采用Array_Map和Array_rESHAPE</p>
<p>还有针对函数的Function_Instantiate</p>
<p> <img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C4.PNG" alt="4"></p>
<h2 id="案例分析：Cordic算法"><a href="#案例分析：Cordic算法" class="headerlink" title="案例分析：Cordic算法"></a>案例分析：Cordic算法</h2><p>Cordic算法本质上是通过一系列微旋转来计算超越函数，比如说正余弦，在这个过程中，这些微旋转变成了一些移位的操作，可以通过这些方式来计算三角函数，如果这里x0设置为1/An，y0设置位0，那么最后就可以得到正余弦的结果，这里要求z0的取值范围是-99 ~ +99，我们再进一步把它缩小为-Π/2 ~ +Π/2</p>
<p>对于-Π ~ Π的区间，要先做预处理，把它映射到-Π/2 ~ Π/2，得到结果之后在做后处理，得到真正的函数值</p>
<p>所以需要三个函数，预处理 -&gt; 中间的计算单元 -&gt; 最后的后处理</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C5.PNG" alt="5"></p>
<p>接下来通过Vivado HLS将其转化为相应的RTL代码，并提高吞吐率</p>
<p>先看一下函数代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ap_fixed.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ap_int.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WA 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FA 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WS 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FA 14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ap_fixed&lt;WA, WA-FA&gt; <span class="keyword">di_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> ap_fixed&lt;WA, WA-FA&gt; <span class="keyword">di_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> ap_fixed&lt;WA, WA-FA&gt; <span class="keyword">di_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">do_t</span> Kn = <span class="number">0.607252935</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">di_t</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cir_cordic</span><span class="params">(<span class="keyword">di_t</span> alpha, <span class="keyword">do_t</span> &amp;mysin, <span class="keyword">do_t</span> &amp;cos_out)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cir_codic.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_cir_codic</span><span class="params">(<span class="keyword">di_t</span> full_alpha, <span class="keyword">di_t</span> &amp;alpha, <span class="keyword">flag_t</span> &amp;flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(full_alpha &gt; PI/<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        alpha = PI - full_alpha;</span><br><span class="line">        flag = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(full_alpha &lt; -PI/<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        alpha = -PI - full_alpha;</span><br><span class="line">        flag = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        alpha = full_alpha;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cir_cordic_calculate</span><span class="params">(<span class="keyword">di_t</span> alpha, <span class="keyword">flag_t</span> flag, <span class="keyword">do_t</span> &amp;mysin, <span class="keyword">do_t</span> &amp;mycos, <span class="keyword">flag_t</span> flag_delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">do_t</span> xi[N];</span><br><span class="line">    <span class="keyword">do_t</span> yi[N];</span><br><span class="line">    <span class="keyword">di_t</span> zi[N];</span><br><span class="line">    <span class="keyword">flag_t</span> flag_delay_a[N];</span><br><span class="line">    </span><br><span class="line">    xi[<span class="number">0</span>] = Kn;</span><br><span class="line">    yi[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    zi[<span class="number">0</span>] = alpha;</span><br><span class="line">    flag_delay_a[<span class="number">0</span>] = flag;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">di_t</span> myarctan[<span class="number">16</span>] = &#123;</span><br><span class="line">        #included <span class="string">"myarctan.h"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    loop:</span><br><span class="line">    <span class="keyword">for</span>(m = <span class="number">0</span>; m &lt; N; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(zi[m] &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            xi[m+<span class="number">1</span>] = xi[m] - (yi[m] &gt;&gt; m);</span><br><span class="line">            yi[m+<span class="number">1</span>] = yi[m] + (xi[m] &gt;&gt; m);</span><br><span class="line">            zi[m+<span class="number">1</span>] = zi[m] - myarctan[m];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            xi[m+<span class="number">1</span>] = xi[m] + (yi[m] &gt;&gt; m);</span><br><span class="line">            yi[m+<span class="number">1</span>] = yi[m] - (xi[m] &gt;&gt; m);</span><br><span class="line">            zi[m+<span class="number">1</span>] = zi[m] + myarctan[m];</span><br><span class="line">        &#125;</span><br><span class="line">        flag_delay_a[m+<span class="number">1</span>] = flag_delay_a[m];</span><br><span class="line">    &#125;</span><br><span class="line">    mysin = yi[N<span class="number">-1</span>];</span><br><span class="line">    mycos = xi[N<span class="number">-1</span>];</span><br><span class="line">    flag_delay = flag_delay_a[N<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_cir_cordic</span><span class="params">(<span class="keyword">do_t</span> mysin, <span class="keyword">do_t</span> mycos, <span class="keyword">flag_t</span> flag_delay, <span class="keyword">do_t</span> &amp;sin_out, <span class="keyword">do_t</span> &amp;cos_out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">int</span>(flag_delay))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> : sin_out = mysin; cos_out = -mycos; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span> : sin_out = mysin; cos_out = -mycos; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span> : sin_out = mysin; cos_out = mycos; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cir_cordic</span><span class="params">(<span class="keyword">di_t</span> full_alpha, <span class="keyword">do_t</span> &amp;sin_out, <span class="keyword">do_t</span> &amp;cos_out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">di_t</span> alpha;</span><br><span class="line">    <span class="keyword">flag_t</span> flag;</span><br><span class="line">    <span class="keyword">do_t</span> mysin;</span><br><span class="line">    <span class="keyword">do_t</span> mycos;</span><br><span class="line">    flag_ flag_delay;</span><br><span class="line">    </span><br><span class="line">    pre_cir_codic(full_alpha, alpha, flag);</span><br><span class="line">    cir_codic_calculate(alpha, flag, mysin, mycos, flag_delay);</span><br><span class="line">    post_cir_codic(mysin, mycos, flag_delay, sin_out, cos_out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cir_codic.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ReafFileVec.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">629</span>;</span><br><span class="line">    <span class="keyword">char</span> *fd_alpha = <span class="string">"myalpha.dat"</span>;</span><br><span class="line">    <span class="keyword">char</span> *fd_sin = <span class="string">"mysin.dat"</span>;</span><br><span class="line">    <span class="keyword">char</span> *fd_cos = <span class="string">"mycos_dat"</span>;</span><br><span class="line">    <span class="keyword">di_t</span> alpha[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">do_t</span> sin_Ref[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">do_t</span> cos_Ref[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">do_t</span> sin_Res[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">do_t</span> cos_Res[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ErrCntSin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ErrCntCos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> precision = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">-10</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    ReadFileVec &lt;N, <span class="keyword">di_t</span>, <span class="keyword">float</span>&gt; (fd_alpha, alpha);</span><br><span class="line">    ReadFileVec &lt;N, <span class="keyword">do_t</span>, <span class="keyword">float</span>&gt; (fd_sin, sinRef);</span><br><span class="line">    ReadFileVec &lt;N, <span class="keyword">do_t</span>, <span class="keyword">float</span>&gt; (fd_cos, cosRef);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cir_codic(alpha[i], sinres[i], cosres[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'-'</span>) &lt;&lt; setw(<span class="number">90</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; <span class="string">"Alpha"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; <span class="string">"sin"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; <span class="string">"sinRef"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; <span class="string">"cos"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; <span class="string">"cosRef"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'-'</span>) &lt;&lt; setw(<span class="number">90</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; alpha[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; sinres[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; sinRef[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; cosres[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; cosRef[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="keyword">float</span>(sinres[i]-sinRef[i])) &gt; precision)</span><br><span class="line">        &#123;</span><br><span class="line">            ErrCntSin++;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; <span class="string">"(sin failed)"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="keyword">float</span>(cosres[i]-cosRef[i])) &gt; precision)</span><br><span class="line">        &#123;</span><br><span class="line">            ErrCntCos++;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; <span class="string">"(cos failed)"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'-'</span>) &lt;&lt; setw(<span class="number">90</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ErrCntSin + ErrCntCos &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ErrCntSin &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ErrCntCos &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; <span class="string">"There are "</span> &lt;&lt; ErrCntCos &lt;&lt; <span class="string">" cos results failed"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test failed for precision: "</span> &lt;&lt; presicion &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'-'</span>) &lt;&lt; setw(<span class="number">90</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test Passed for precision: "</span> &lt;&lt; precision &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'-'</span>) &lt;&lt; setw(<span class="number">90</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建Vivado HLS的工程，然后进行系统仿真，出现下面的信息说明仿真结果通过了</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C6.PNG" alt="6"></p>
<p>然后再做C的综合，出现下面的结果说明C综合通过</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C7.PNG" alt="7"></p>
<p>综合结束后会有相应的综合报告，可以看到Latency等信息，可以看到Latency和Interval都是比较大的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C8.PNG" alt="8"></p>
<p>然后我们就可以做C和RTL的Co-Simulation，做完Co-Simulation之后就可以打开波形查看器，去看最终的结果</p>
<p>设置sin_out和cos_out，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C9.PNG" alt="9"></p>
<p>设置输出是一个定点数，有符号数，小数部分是14位</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C10.PNG" alt="10"></p>
<p>同时把它设置为模拟波形的方式来显示</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C11.PNG" alt="11"></p>
<p>现在就可以看到整个曲线的样子</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C12.PNG" alt="12"></p>
<p>针对Latency进行优化</p>
<p>创建一个solution命名为s_pipeline，针对for循环去做pipeline</p>
<p>对for循环添加directive，UNROLL和PIPELINE，然后再进行综合，综合后的结果可以看到，Latency变成了6，Interval变成了7，有了显著的变化，但是我们期望Interval是1，所以我们进一步优化</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C13.PNG" alt="13"></p>
<p>创建solution，s_pipeline_fun，作用于主函数本身进行pipeline，然后进行综合，这时候综合报告显示，Latency变成了5，Interval变成了1</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C14.PNG" alt="14"></p>
<p>然后将三次综合结合结果进行对比，可以看到Latency和Interval的变化</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C15.PNG" alt="15"></p>
<p>在资源方面的变化也可以做一个对比</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C16.PNG" alt="16"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="ylyang.xyz/2020/01/08/VivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tou2.jpg">
      <meta itemprop="name" content="ylyang">
      <meta itemprop="description" content="云山苍苍，江水泱泱；先生之风，山高水长。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/08/VivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">Vivado HLS之函数层面的优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="文章创建时间：2020-01-08 12:59:05" itemprop="dateCreated datePublished" datetime="2020-01-08T12:59:05+08:00">2020-01-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vivado-HLS/" itemprop="url" rel="index"><span itemprop="name">Vivado HLS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数的代码风格"><a href="#函数的代码风格" class="headerlink" title="函数的代码风格"></a>函数的代码风格</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>从函数的角度来看代码风格主要是说函数的参数，针对参数我们要看的是数据类型，C++里定义的数据类型是以8为边界的，比如说char或者int等等，但实际在硬件我们可能会遇到任意精度的数据类型，所以如果算法中牵涉到的数据类型是任意精度，我们一定要将其定义为任意精度</p>
<p>看例子</p>
<p>这是一个很简单的例子，目的是实现<code>x * y</code>，而且在这里x和y都是12比特的整型，如果我们用传统的C++来定义就会将其定义为int类型，但是如果我们用Vivado HLS支持的任意精度的数据类型，我们就可以将其定义为ap_int&lt;12&gt;，这两种方法我们进行对比可以看到，如果用任意精度的数据类型，只用了1个DSP48，但是如果定义为int类型就要用到3个DSP48（一个int是4字节，32位）</p>
<p>所以这就体现了数据类型对于使用资源的影响</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C1.PNG" alt="1"></p>
<h2 id="Inline"><a href="#Inline" class="headerlink" title="Inline"></a>Inline</h2><p>对函数的Inline其实是去除了函数的层次化</p>
<p>这个可以通过INLINE directive去实现</p>
<p>对函数进行inline带来的好处是可以改善资源，这是因为Inline就不再需要调用函数的相关逻辑</p>
<p>对一些小的函数，Vivado HLS会自动进行inline的处理，可以改善相应的QOR（quality of results），如果我们不希望函数inline，可以通过设置函数中的<code>-off</code>选项去实现</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C2.PNG" alt="2"></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在这个例子中有一个顶层函数dct，其中调用了<code>read_data()</code>和<code>write_data()</code>函数，以及<code>dct_2d()</code>这三个函数，在默认情形下可以看到Vivado HLS自动对<code>read_data()</code>和<code>write_data()</code>执行了inline，所以在综合报告中我们只看到了一个instance，也就是dct_2d()这个函数，如果我们阻止inline，在directive窗口中选择相应的函数，并切换到Inline，同时将off选中，就变成了如下所示，这时候再进行综合，在相应的综合报告中就可以看到有3个相应的instance，相应的Latency和资源的对比也可以看到，显然，把inline关掉的话，Latency会增大，相应的资源也会变多</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C3.PNG" alt="3"></p>
<h2 id="Allocation"><a href="#Allocation" class="headerlink" title="Allocation"></a>Allocation</h2><p>再看一下Allocation，Allocation其实是定义了函数和相应的RTL model之间的关系</p>
<p>看下例</p>
<p>在这个函数中，在<code>loop_sequential()</code>函数下面调用了两次<code>Accumulator()</code>函数，如果我们通过Allocation设置其中的limit=2，目的是告诉HLS，<code>Accumulator()</code>函数对应的RTL实体会被实例化了两次，这个就是这里limit=2的含义，再看一下结果就可以看到有两个实体</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C4.PNG" alt="4"></p>
<h3 id="Allocation的影响"><a href="#Allocation的影响" class="headerlink" title="Allocation的影响"></a>Allocation的影响</h3><p>默认是default的情形，这时候for循环的Latency是8，tripcount是4，</p>
<p>再看Allocation：Limit=1，和Allocation：Limit=2的情形，对比一下可以看到，当Allocation=2时，Latency是最小的，但是资源用的也是最多的，FF用到了48，所以对比一下可以得出结论，Allocation是得出了Latency和Area之间的折中。</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C5.PNG" alt="5"></p>
<h2 id="DataFlow"><a href="#DataFlow" class="headerlink" title="DataFlow"></a>DataFlow</h2><p>DataFlow在之前讲到for循环优化的时候就提到过，这里可以把它运用于函数，比如函数1执行完的结果给函数2，… …，这样顺序执行，知道最后函数N，然后输出，我们把这个称为顺序处理的模式，通过Dataflow可以把这种顺序处理的模式变成并行处理，并行处理的时候就可以用到channel，这个channel就可以是ping-pong RAM，也可以是FIFO</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C6.PNG" alt="6"></p>
<p>关于dataflow可以作为顺序执行的一些任务，可以作用于顺序执行的一些任务，这些任务可以是函数，循环，或者两者都有，DataFlow是把顺序的处理机制变成了并行的处理机制，在前边图中的channel就表明了，当前任务并不需要等到后一个任务处理完毕再执行，他们是可以并行执行的，所以DataFlow允许任务之间有交叠，所谓的这种交叠其实就是并行处理，这种机制提高了数据吞吐率，从而降低了Latency</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C7.PNG" alt="7"></p>
<h3 id="对DataFlow的理解"><a href="#对DataFlow的理解" class="headerlink" title="对DataFlow的理解"></a>对DataFlow的理解</h3><p>看下面这个图，在这个图中显示了三个函数，Func1、Func2、Func3，其中，Func1需要3个时钟周期，Func2需要2个时钟周期，Func3需要3个时钟周期，也就是总共的Latency是8，如果我们用DataFlow，Latency就降低到了5</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C8.PNG" alt="8"></p>
<p>再看一个例子，dct()函数中调用了三个函数，分别是read_data()、dct_2d()、write_data()，他们是满足顺序处理机制的，从而可以通过DataFlow实现并行的处理，在相应的分析窗口中我们就可以看到Module Hierarchy窗口中有一个标记，那么就说明了使用了DataFlow，我们可以看到相应的Schedule Viewer视图和DataFlow视图</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C9.PNG" alt="9"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，我们可以看到使用任意精度的数据类型能够帮助我们降低资源的使用</p>
<p>函数的Inline使用可以提高QoR（quality of results）</p>
<p>Allocation的使用可以帮助我们折中Latency和资源（Area）</p>
<p>DataFlow对于提高吞吐量是一种强有力的优化方式</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C10.PNG" alt="10"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="ylyang.xyz/2020/01/07/VivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tou2.jpg">
      <meta itemprop="name" content="ylyang">
      <meta itemprop="description" content="云山苍苍，江水泱泱；先生之风，山高水长。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/07/VivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">VivadoHLS之数组优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="文章创建时间：2020-01-07 12:59:05" itemprop="dateCreated datePublished" datetime="2020-01-07T12:59:05+08:00">2020-01-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vivado-HLS/" itemprop="url" rel="index"><span itemprop="name">Vivado HLS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数组优化-数组分割"><a href="#数组优化-数组分割" class="headerlink" title="数组优化 - 数组分割"></a>数组优化 - 数组分割</h1><p>对于数组，我们可以通过resource这个directive明确的告知vivado HLS当前的这个数组是采用什么样的Memory来实现，比如是通过分布式的还是通过block RAM，是采用单端口还是采用双端口，如果没有使用resource，Vivado HLS会自行决定采用单端口还是双端口，取决于哪种方式可以有效的降低Initiation interval以及Latency。</p>
<p>数组最终会以memory（RAM、ROM、FIFO）的形式出现，如果数组是作为顶层函数的形参，那么他最终就会以相应的memory的接口来呈现，包括相应的读写地址，以及数据，当然还有读写使能，如果数组是在读写的内部，那么最终就会映射为block RAM，LUTRAM，Ultra RAM，或者是寄存器取决于在设计中采用的优化策略和优化方法</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C1.PNG" alt="1"></p>
<h2 id="看例子"><a href="#看例子" class="headerlink" title="看例子"></a>看例子</h2><p>在例子中，如果我们要同时获取mem[]数组相邻的三个元素，把他们相加，输出的值给到另外一个元素，在默认的情况下我们会看到Resource/Control的过程，可以看到这时候mem被映射为双端口：p0、p1，但是结果sum就是单端口，每次只能写入一个数据，但是我们可以很明确的将mem指定为双端口，这时候要把循环展开，这个指令就是通过resource的directive实现的，这时候我们看到整个的读写过程，很明显因为sum变成了双端口，所以可以同时写入两个数据，更要说明的是因为这里的循环时展开的，所以也就使得相应的加法操作变成了并行，由此我们可以看到Latency从默认情形下的13变成了3，Interval由14变成了4，优化结果很明显。</p>
<p>由此可以看到，数组往往是设计过程中的瓶颈</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C2.PNG" alt="2"></p>
<h2 id="三种方法（Three-Forms-of-Partition）"><a href="#三种方法（Three-Forms-of-Partition）" class="headerlink" title="三种方法（Three Forms of Partition）"></a>三种方法（Three Forms of Partition）</h2><p>Vivado HLS提供了三种对数组进行分割的方法，分别是block、cyclic、register，仍然以上面的例子为例，mem数组长度为6的一个数组</p>
<h3 id="1、block"><a href="#1、block" class="headerlink" title="1、block"></a>1、block</h3><p>如果我们采用Block的方式、Factor为3，就意味着数组分成三份，是一种等分成三份的方式，所以0号、1号作为一组，2号、3号作为一组，4号、5号作为一组，在相应的directive窗口中可以看到，<code>block factor=3 dim=1</code>，dim也就是dimension，因为这里的数组是个一维数组</p>
<h3 id="2、cyclic"><a href="#2、cyclic" class="headerlink" title="2、cyclic"></a>2、cyclic</h3><p>我们还可以采用第二种partition的方式，就是Cyclic，Factor=3，这时候我们要注意分割方式有所不同，依然要分成3份，但是0、1、2属于不同的memory，3、4、5属于不同的memory，从而0、3构成第一个memory，1、4构成第二个memory，2、5构成第三个memory，同样这时在directive窗口中就会看到<code>cyclic factor=3 dim=1</code>，</p>
<h3 id="3、register"><a href="#3、register" class="headerlink" title="3、register"></a>3、register</h3><p>如果采用Register的方式，这时候0 - 5这六个元素就变成了0 - 5对应的六个register，就是一种完全并行的方式，在directive窗口中就可以看到<code>complete dim=1</code>，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C3.PNG" alt="3"></p>
<p>我们看一下这三种分割方式对于前边的例子会有怎样的影响，很显然，对于上面的例子来说，采用block、cyclic他们的并行增强了，基本上效果是一致的，采用complete是一种完全并行的方式，因为他全部采用了register，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C4.PNG" alt="4"></p>
<p>但是并非是越多的block效果越好，事实上block的个数取决于真实的数据流，从前面的例子中可以看到，我们在获得一次和的过程中，需要有三个输入，三个输入可以分解成两个block，一个block是一个双端口，因为每个block、每个memory作为双端口可以提供两个数据，如果是两个block也就是两个memory，至少可以提供4个数据，完全满足这种数据流，所以我们并没有必要去把它分解成三个block，因此我们这里做一个对比，当block=2，和block=3的时候，其实情形是一样的，最终的性能Latency和Interval是一样的，同样的，如果我们选择Cyclic的方式，cyclic=2和cyclic=3也是一样的，从资源角度看，尽管有一些变化，但是可以忽略不计</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C5.PNG" alt="5"></p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>对于多维数组，dimension该如何设置，例如有如下一个三维数组，Vivado HLS的认定规则是：10是第一维，6是第二维，4是第三维。</p>
<p>当我们选择dim=3进行partition的时候，这时候就变成了如下中间这种形式，当选择dim=1的时候，就变成了如下右边这种形式，需要说明的是，当dim=1时，是把<code>My_array_0[6][4]</code>作为一个整体来看的</p>
<h3 id="看一个例子"><a href="#看一个例子" class="headerlink" title="看一个例子"></a>看一个例子</h3><p>在下面这个例子中，这是数组的加法，对数组元素进行相加，所以要求a和b是一个相同维度的数组，这里的a是一个4x5也就是4行5列的数组，对这个数组a做约束，首先通过resource把它设置为单端口，第二把它做分割，对他的第一维分割，并且分解成四块，第一维就是4x5的4对应的维度，同理，数组b和数组sum也是同样的方式，同时还要注意相应的循环要展开，所以如果<code>block factor=4, dim=1</code>，九八数组a分解成了如下四个block，可以看到每一行对应一个block，如果把<code>block factor=2, dim=1</code>，就会分解成如下两个block，这时候第0行、第1行作为block 0，第2行、第3行作为block 1，这个方式跟一维数组的方式是类似的，只是在做block分割的时候是把其中的每一行作为一个整体来看待的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C6.PNG" alt="6"></p>
<p>从仿真结果也可以进一步来验证这种<code>block factor=4, dim=1</code>，和block factor=2, dim=1的时候所获得的元素是什么样子的，所以跟我们前边分割的方式是完全一致的，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C7.PNG" alt="7"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、Vivado HLS提供了三种数组分割的方式：block，cyclic、complete</p>
<p>2、数组分割可以提高吞吐率</p>
<h1 id="数组优化-数组映射和重组"><a href="#数组优化-数组映射和重组" class="headerlink" title="数组优化  - 数组映射和重组"></a>数组优化  - 数组映射和重组</h1><p>Optimization Methods of Array: Map and Reshape</p>
<h2 id="映射（Map）"><a href="#映射（Map）" class="headerlink" title="映射（Map）"></a>映射（Map）</h2><p>在C代码中如果有多个比较小的数组，可以通过Map合并成一个大的数组，从而减少block RAM的消耗，从而降低对资源的用量</p>
<p>当设备支持时，每一个数组都能够映射到block RAM或者UltraRAM中</p>
<p>Vivado HLS对于ARRAY_MAP提供了两种方式，一种是横向（水平），一种是纵向（竖直）</p>
<ul>
<li>横向映射（Horizontal mapping）</li>
</ul>
<p>得到一个包含更多元素的单个数组（Get a single array with more elements）</p>
<ul>
<li>纵向映射（Vertical mapping）</li>
</ul>
<p>获得一个具有更大位宽的单个数组（Get a single array with larger bit-width）</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C8.PNG" alt="8"></p>
<h3 id="横向（水平）映射"><a href="#横向（水平）映射" class="headerlink" title="横向（水平）映射"></a>横向（水平）映射</h3><p>假如有两个一维数组<code>A[N]</code>和<code>B[M]</code>，长度分别为N和M</p>
<p>如果我们选择水平方向的map，最终合并之后的数组长度变成了N+M，两个数组时前后拼接在一起变成了一个更大的数组，最终的数组形式如紫色图所示，这里可以看到数组从0变化到M+N-1，同时需要注意，数组的宽度，也就是存储元素的位宽可以是不一样的</p>
<p>在Vivado HLS中通过相应的ARRAY_MAP就可以选择，mode参数选择横向还是纵向，合并后的数组可以起一个名字，在instancwe上取，对于这个数组<code>A[N]</code>和<code>B[M]</code>，合并之后的数组的维度就变成了N+M</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C9.PNG" alt="9"></p>
<p>对于横向映射的数组允许有Offset，也就是地址偏移，可以看到下面这个例子他们不是无缝对接，而是中间有一些空挡，从仿真结果也可以进行验证，当offset=0时，也就是无缝对接的时候，他们是0、1、2、3，但是当offset=2时，可以看到地址的变化，2、3、4、5，因为offset=2，起始地址变成了2</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C10.PNG" alt="10"></p>
<p>这里还要强调一下，这种方式虽然减少了相应的资源的使用，但是对吞吐率并没有改善，因为memory个数减少了意味着读出的端口的个数也减少了</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C11.PNG" alt="11"></p>
<h3 id="纵向（竖直）映射"><a href="#纵向（竖直）映射" class="headerlink" title="纵向（竖直）映射"></a>纵向（竖直）映射</h3><p>还是以两个一维数组<code>A[N]</code>和<code>B[M]</code>，长度分别为N和M为例</p>
<p>对于纵向的合并，是把相应的元素对应的位置做位拼接，所以最终的数组长度仍然是原始数组中最长的那个数组的长度，但是宽度宽度发生了变化，是因为做了位拼接，所以最终的数组就变成了如下图3，假设N&gt;M，这里数组的长度就变成了N，但他的宽度就变成了A和B宽度之和</p>
<p>纵向映射的方式也是在directive中设置数组的模式（mode）也可以去指定合并后数组的名字（instance）</p>
<p>这里主要就是强调对于纵向映射的数组，合并后的长度就是N和M的最大值</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C12.PNG" alt="12"></p>
<h3 id="数组分割配合横向映射"><a href="#数组分割配合横向映射" class="headerlink" title="数组分割配合横向映射"></a>数组分割配合横向映射</h3><p>之间提到的数组分割中的array_partition，是把数组分割成多个模块</p>
<p>其实array_partition是可以跟横向映射一块使用的，例如，先通过partition把数组分解成两个模块，然后再通过横向的array_map把相应的分割的部分再进行合并，这样做的好处是在减少使用资源的同时也可以获得较好的吞吐率，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C13.PNG" alt="13"></p>
<h2 id="重组（Reshape）-ARRAY-RESHSPE"><a href="#重组（Reshape）-ARRAY-RESHSPE" class="headerlink" title="重组（Reshape）-  ARRAY_RESHSPE"></a>重组（Reshape）-  ARRAY_RESHSPE</h2><p>重组是将ARRAY_PARTITION和纵向的ARRAY_MAP结合在一起的，这样可以降低资源的用量，同时对于数据的并行读取也会有好处，因为ARRAY_PARTITION的目的就是并行的获取数据，提高数据的并行性</p>
<p>相应的，因为ARRAY_PARTITION有3种模式，所以ARRAY_RESHAPE也会有类似的3种方式</p>
<p>这里我们以一维数组为例</p>
<h3 id="1、block-1"><a href="#1、block-1" class="headerlink" title="1、block"></a>1、block</h3><p>可以看到，这种情况下是将数组一分为二，然后纵向拼接相应的位置上的元素，拼接在一起，所以最终的长度是原先的1/2，宽度变成了原先的2倍</p>
<h3 id="2、cyclic-1"><a href="#2、cyclic-1" class="headerlink" title="2、cyclic"></a>2、cyclic</h3><p>再看cyclic，这时候是把数组交织的分成两部分，最终reshape之后的数组，长度是原来的1/2，宽度变成原来宽度的2倍</p>
<h3 id="3、complete"><a href="#3、complete" class="headerlink" title="3、complete"></a>3、complete</h3><p>他是同时获得了n个register，同时将n个register合并，合成一个宽度是原来n倍的寄存器，不同于Array_Partition和横向的映射组合，Array_Reshape是针对同一个数组的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C14.PNG" alt="14"></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在这个例子中，代码的</p>
<p>第一部分是一个for循环，在这个for循环中，将数组pa赋值给了数组A，然后对数组A执行相应的操作，操作内容是对偶数元素加5，对奇数元素减5，</p>
<p>第二部分是把数组pb赋值给了数组B，然后对B进行操作是把B的前一半元素加5，后一半元素减5</p>
<p>第三部分是对处理后的值，A和B分别乘以2，再回写到原来的pa和pb中</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C15.PNG" alt="15"></p>
<p>对这个例子分别进行array_map的横向映射，array_map的纵向映射，以及reshape，采用的是cyclic和block两种方式</p>
<p>从结果可以看到，对于Latency，只有reshape也就是s_r1这个solution会有改善，从资源来看，array_map的横向映射和array_map的纵向映射都是把block RAM的个数减小到1，所以对比下来看，array_map对于资源的用量是可以减小的，但是对于数据吞吐率是没有改善的，而Array_Reshape可以通过本身包含的partition来提高吞吐率，在一定程度上获得了资源（面积Area）和吞吐率的折中。</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C16.PNG" alt="16"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Vivado HLS提供了两种map的方式，包括横向和纵向，他们都能帮助我们减少资源的用量，主要是memory资源</p>
<p>但是Array_map对于数据吞吐率并没有改善</p>
<p>Array_Reshape是将纵向的Array_Map和Array_Partition结合在一起，所以他可以获得资源和数据吞吐率的一个比较好的折中</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C18.PNG" alt="18"></p>
<h1 id="数据优化-其他方法"><a href="#数据优化-其他方法" class="headerlink" title="数据优化 - 其他方法"></a>数据优化 - 其他方法</h1><h2 id="如何定义一个ROM？"><a href="#如何定义一个ROM？" class="headerlink" title="如何定义一个ROM？"></a>如何定义一个ROM？</h2><h3 id="1、const-initial-value"><a href="#1、const-initial-value" class="headerlink" title="1、const + initial value"></a>1、const + initial value</h3><p>最简单的方式就是用关键字const + initial value，这种方式简单易行，不足之处就是如果我们定义的ROM比较大，也就是初始值很多的情况下，在代码里写这些初始值是一个很繁琐的过程，容易出错。</p>
<p>同时从代码的管理角度而言也是很不方便的。</p>
<p> 相应的我们可以在综合后的报告里看到资源的占用量</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C17.PNG" alt="17"></p>
<h3 id="2、头文件的方式"><a href="#2、头文件的方式" class="headerlink" title="2、头文件的方式"></a>2、头文件的方式</h3><p>采用头文件的方式，将相应的初始值放到头文件中，这样既简单同时对代码的维护和工程的管理都很方便，注意在代码中蓝色方框标记的部分有一个<code>.h</code>的头文件，在写法上<code>#include &quot;des_1_coef.h&quot;</code>要单独占一行。</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C19.PNG" alt="19"></p>
<p>对于<code>.h</code>文件中的内容，一个例子，这里需要用逗号，而在最后一行是数值再加上一个空格，是没有标点符号的，相应的在综合之后就可以看到资源用量，这里给的例子是整个的ROM的长度，很小，所以是用查找表来实现的，可以看到有相应的LUT、Words、Bits</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C20.PNG" alt="20"></p>
<h3 id="3、Vivado-HLS推导出相应的ROM"><a href="#3、Vivado-HLS推导出相应的ROM" class="headerlink" title="3、Vivado HLS推导出相应的ROM"></a>3、Vivado HLS推导出相应的ROM</h3><p>如果ROM里头的存储值是通过数学公式计算得到的，那么Vivado HLS也可以帮助去推导出相应的ROM</p>
<p>在这个例子中有一个函数<code>init_sin_table()</code>，这里边其实是通过sin值函数去计算相应的数值，然后在下边的函数中会调用<code>init_sin_table()</code>，这时候在综合后的报告里就能看到Vivado HLS会帮助我们推导出一个相应的ROM</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C21.PNG" alt="21"></p>
<p>对于ROM可以改变它的输出的Latency，在默认情形下用的输出Latency是2，可以通过增加Latency改善这条路径上的时序，在相应的directive窗口可以看到Latency(optional)，默认是2，现在改为3，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C22.PNG" alt="22"></p>
<p>要想知道是否生效，可以查看生成的RTL代码进行验证，当Latency=2时可以看到地址有一级Latency，输出有一级Latency，当Latency=3时，地址有一级Latency，输出有一级Latency，最终的输出还有一级Latency，总共是3级。</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C23.PNG" alt="23"></p>
<h3 id="4、数组的初始化"><a href="#4、数组的初始化" class="headerlink" title="4、数组的初始化"></a>4、数组的初始化</h3><p>对于数组，如果是映射为memory，需要在前面加关键字static，这个关键字不仅能保证Vivado HLS把数组作为memory实现，还可以保证最终实现的结果跟RTL的结果行为上是一致的，所谓的行为上是一致的，体现在当数组有初始值的时候，如果没有加static关键字，一旦在对RAM或者ROM（也就是memory）进行操作的时候将会对memory进行一个初始化的过程，初始化需要的时间跟memory有很大的关系，比如在这个例子中memory是一个长度为8的memory，那么他至少需要8个时钟周期进行初始化，相应的如果memory是1024的长度，那么就需要1024个时钟周期进行初始化，如果前面加了static关键字，那么初始化的值就一定会被写进return文件里头，不会再有相应的初始化的过程</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C24.PNG" alt="24"></p>
<p>所以这里我们可以看到，static所起的作用</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C25.PNG" alt="25"></p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>在我们使用数组的时候，如果确定是我们RTL代码里的memory，我们一定要加关键字static</p>
<p>同样的，如果我们是要做一个ROM，就要加关键字const，可以采用头文件的方式也可以采用在代码中直接赋值的方式</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C26.PNG" alt="26"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="ylyang.xyz/2020/01/05/VivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tou2.jpg">
      <meta itemprop="name" content="ylyang">
      <meta itemprop="description" content="云山苍苍，江水泱泱；先生之风，山高水长。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/05/VivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">Vivado HLS之for循环优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="文章创建时间：2020-01-05 12:59:05" itemprop="dateCreated datePublished" datetime="2020-01-05T12:59:05+08:00">2020-01-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vivado-HLS/" itemprop="url" rel="index"><span itemprop="name">Vivado HLS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="for循环优化-基本衡量指标"><a href="#for循环优化-基本衡量指标" class="headerlink" title="for循环优化 - 基本衡量指标"></a>for循环优化 - 基本衡量指标</h1><h2 id="看一个例子"><a href="#看一个例子" class="headerlink" title="看一个例子"></a>看一个例子</h2><p>在头文件里定义了一个变量<code>N = 3</code></p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C1.PNG" alt="1"></p>
<p>N是循环边界，for循环执行的是乘加操作</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C2.PNG" alt="2"></p>
<p>以上程序可以用以下这样一个状态来表示，一共有四个状态，分别是<code>C0、C1、C2、C3</code>，</p>
<p>在这四个状态中，</p>
<p>C0是读取数据b和c</p>
<p>C1是获取数组xin[]的0号地址xin[0]</p>
<p>C2是从0号地址读取相应的数据</p>
<p>C3完成相应的计算</p>
<h2 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h2><p>假定每个状态都消耗一个时钟周期，for循环要执行三次，所以<strong>Loop Trip Count = 3</strong>，也就是代表<strong>循环一共执行了多少次</strong></p>
<p>对一个for循环而言，有<code>C1、C2、C3</code>三个状态，占用了三个时钟周期，所以它的<strong>Loop Iteration Latency = 3</strong></p>
<p><strong>本次for循环和下一次for循环的间隔</strong>也是三，所以也是<strong>Loop Iteration Interval（Loop II）= 3</strong>，这个<strong>Loop II</strong>表明了两次相邻的输入之间的间隔，也是以时钟周期的个数表示的，从而我们就可以确定整个for循环的<strong>Loop Latency = 9</strong>，</p>
<p>整个函数的<strong>Function Latency = 10</strong></p>
<p>以及<strong>Function Initial Interval（II）= 11</strong></p>
<p>这些参数是衡量我们设计性能很重要的指标，在综合报告中也能看到这些指标。</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C3.PNG" alt="3"></p>
<p>这是综合后的报告，相应的Latency、Interation Latency，还有函数的Latency以及相应的Interval</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C4.PNG" alt="4"></p>
<p>从 CoSimulation的波形来看，当ap_start为高的时候作为起始点，当ap_done为高的时候作为终止点，这样就确定了整个函数的Latency</p>
<p>这样就确定了整个函数的Function Latency = 10，相应的可以确定Function Initial Interval = 11</p>
<p>我们在描述for循环的时候很明确的知道for循环执行到什么时候退出，但是对硬件电路而言，需要去判断，判断变量i到底是否超出了循环边界，相应的循环体要不要被终止，这样就需要消耗一个额外的时钟周期，所以并不是i一达到循环边界就结束，会有一个判断的操作</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C5.PNG" alt="5"></p>
<h2 id="pipeline优化for循环"><a href="#pipeline优化for循环" class="headerlink" title="pipeline优化for循环"></a>pipeline优化for循环</h2><p>对for循环最常见的优化就是做流水线，流水线设置是在directive中设置为pipeline，相应的设置完成以后就可以在Directive窗口中被设置好了</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C6.PNG" alt="6"></p>
<p>为什么设置pipeline会改善Latency和Interval呢？</p>
<p>在没有采用pipeline的时候整个操作是按时间的先后顺序来执行的，一旦有了pipeline，就变成了并行的流水线操作</p>
<p>这里设置pipeline以后，Iteration Latency = 3没有变，每次循环还是要消耗3个时钟周期，但是II就变成1了（Loop II = 1），不用等到上一个for循环执行完了再去读下一个，而是当在读数据的时候，下一次for循环就可以开始获取相应的地址，也可以看到Loop Latency = 3</p>
<p>这也就是通过pipeline可以把Latency和Interval降下来的原因</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C7.PNG" alt="7"></p>
<h2 id="在波形图中查看相应的指标"><a href="#在波形图中查看相应的指标" class="headerlink" title="在波形图中查看相应的指标"></a>在波形图中查看相应的指标</h2><p>在波形图中可以查看相应的指标，比如Function Latency和Function Initial Interval</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C8.PNG" alt="8"></p>
<h2 id="unrolling优化for循环"><a href="#unrolling优化for循环" class="headerlink" title="unrolling优化for循环"></a>unrolling优化for循环</h2><p>对于for循环也可以进行展开优化，在默认的情况下for循环是被折叠的，所谓折叠可以理解为每一次循环都是采用同一套电路，只是这个电路被分时复用了，如果展开就意味着这个for循环被复制了，可能被复制了n次，也可能被复制了n/2ci，可控。</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C9.PNG" alt="9"></p>
<p>比如下图中<strong>trip count  = 3</strong>，完全展开，相应的资源扩大了三倍，乘法器从一个变成了3个</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C10.PNG" alt="10"></p>
<h2 id="部分循环展开（Partial-Loop-Unrolling）"><a href="#部分循环展开（Partial-Loop-Unrolling）" class="headerlink" title="部分循环展开（Partial Loop Unrolling）"></a>部分循环展开（Partial Loop Unrolling）</h2><p>如下程序，<strong>trip count = 6</strong>，从C语言角度出发，可以写成三个for循环，这三个for循环<code>i</code>的起始值是不一样的，但是边界都是6，相应的，每个for循环所对应的<code>i</code>也是不一样的，可以在右上角看到：</p>
<p>loop1：i = 0，3</p>
<p>loop2：i = 1，4</p>
<p>loop3：i = 2，5</p>
<p>所以从这个角度讲，for循环是被拆分成三部分，或者说是被复制了三份，被复制后0和3共用一套逻辑资源，1和4共用一套逻辑资源，2和5共用一套逻辑资源</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C11.PNG" alt="11"></p>
<h3 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h3><p>当使用部分循环展开时，在directive窗口进行设置，有个参数是<strong>factor</strong>，将其设置为3，意思就是将for循环复制了3份</p>
<p>综合后的结果可以看到DSP48消耗了三个，也就是乘法器复制了三份</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C13.PNG" alt="13"></p>
<h2 id="循环变量i"><a href="#循环变量i" class="headerlink" title="循环变量i"></a>循环变量<code>i</code></h2><p>还是以上面的代码为例，循环变量<code>i</code>被声明为了<code>int</code>，也可以声明为ap_int&lt;4&gt;，也就是4比特，因为它的边界是6，所以声明为int还是ap_int是不受影响的，因为Vivado HLS考虑的是<code>i</code>的最大值是多少，从而根据<code>i</code>的最大值进行相应的资源规划，尽管也会考虑到数据类型，但是变量的范围决定了它的资源量</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C14.PNG" alt="14"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一节讲了一些基本的概念，</p>
<p>循环和函数的Latency以及Interval，</p>
<p>对于for循环优化最常用的是pipeline，也就是流水</p>
<p>对于for循环在默认情况下是折叠的，因此我们可以对他进行循环展开</p>
<p>也可以进行部分展开，设置相应的factor来实现</p>
<p>部分展开是一种折中的方式，在并行度和资源方面选择一种折中的方案，获取最佳实践</p>
<p>循环变量对最终的资源消耗量并没有影响</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C15.PNG" alt="15"></p>
<h1 id="for循环优化-循环合并"><a href="#for循环优化-循环合并" class="headerlink" title="for循环优化 - 循环合并"></a>for循环优化 - 循环合并</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在下面的代码中，有两个循环，一个执行加法，一个执行减法，而且这两个for循环对应的逻辑电路是可以并行执行的，就是可以同时去并行计算<code>a + b</code>和<code>a - b</code>，期望的电路如下右图，有加法和减法，同时把输出数据给到两个运算单元，从而得到相应的结果</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C16.PNG" alt="16"></p>
<p>但是实际上在默认的情况下，对于加的for循环，Latency等于8，对于减的for循环，Latency也是等于8，从综合后的报告可以看到，这两个for循环是按顺序执行的，考虑到进入for循环和退出for循环需要额外的时钟周期，所以整个的Latency是18个时钟周期</p>
<p>这显然不符合我们预期的结果</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C17.PNG" alt="17"></p>
<h2 id="如何-循环合并"><a href="#如何-循环合并" class="headerlink" title="如何 循环合并"></a>如何 循环合并</h2><h3 id="对于循环边界相同的两个常数"><a href="#对于循环边界相同的两个常数" class="headerlink" title="对于循环边界相同的两个常数"></a>对于循环边界相同的两个常数</h3><p>所以在Vivado HLS中就提供了循环合并，在进行循环合并时，有一个新的概念叫region（区域），就是绿色虚线框对应的部分，所谓region就是loop region花括号之间对应的代码段，region作用的loop_merge，循环合并的作用域也就是loo_region下的for循环部分，在相应的directive窗口下就可以看到是生效的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C18.PNG" alt="18"></p>
<p>合并之后整个loop就变成了一个，从综合的报告中也可以看到Latency变成了8，整个函数的Latency就变成了9</p>
<p>，这就是循环合并带给我们的最直接的好处</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C19.PNG" alt="19"></p>
<p>通过前面的比较可以看到，循环的合并从一定程度上降低Latency，这是因为在默认的状态下，for循环会创建额外的状态机，而状态机会创建额外的时钟周期，以及额外的资源，所以就会导致Latency和整个的资源用量都会有所改变，所以一旦合并，这两个方面都会降低</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C20.PNG" alt="20"></p>
<h3 id="对于循环边界不同的两个常数"><a href="#对于循环边界不同的两个常数" class="headerlink" title="对于循环边界不同的两个常数"></a>对于循环边界不同的两个常数</h3><p>如下代码中两个循环的循环边界是不同的，在合并之前是分开的，分别是4和2，合并之后trip count变成了4，也就是说，当两个循环的循环边界不同时，在合并时是以最大的边界作为合并后的边界</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C21.PNG" alt="21"></p>
<h3 id="循环边界有变量的场景（报错）"><a href="#循环边界有变量的场景（报错）" class="headerlink" title="循环边界有变量的场景（报错）"></a>循环边界有变量的场景（报错）</h3><p>如果一个循环的边界是常数，另一个循环的边界是变量的场景</p>
<p>在这个例子中，第一个循环的循环边界是常数，第二个循环的循环边界是变量，是函数的传入的一个参数</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C22.PNG" alt="22"></p>
<p>从综合后的报告可以看出，给出的trip count是一个范围，0 ~ 15，这是因为这里的变量K是一个ap_uint&lt;4&gt;的数据类型，四位无符号整数表示的最大范围就是0 ~ 15，所以这里的trip count就是0 ~ 15</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C23.PNG" alt="23"></p>
<p>如果在这两个for循环上应用loop merge，就会报错</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C24.PNG" alt="24"></p>
<p>所以当for循环的边界一个是常数，一个是变量的情形下，他们是不能合并的</p>
<h3 id="循环边界都是变量的场景（报错）"><a href="#循环边界都是变量的场景（报错）" class="headerlink" title="循环边界都是变量的场景（报错）"></a>循环边界都是变量的场景（报错）</h3><p>如下所示代码中，J和K都是变量</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C25.PNG" alt="25"></p>
<p>综合后的报告中可以看到trip count 是个范围，而不是固定的常数，都是0 ~ 15，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C26.PNG" alt="26"></p>
<p>同样对这两个for循环应用loop_merge，报错如下：</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C27.PNG" alt="27"></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>假如上面例子中的K &lt; J</p>
<p>因为K &lt; J，因此可以把J拆开，拆成两部分，一部分是0 ~ K，一部分是K ~ J</p>
<p>这样就可以把上面的for循环合并</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C28.PNG" alt="28"></p>
<p>综合后，在没有采用loop_merge的情况下有三个for循环</p>
<p>merge之后，只有两个for循环</p>
<p>所以当两个边界都是for循环时，可以通过修改代码实现for循环的合并</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C29.PNG" alt="29"></p>
<h2 id="合并规则"><a href="#合并规则" class="headerlink" title="合并规则"></a>合并规则</h2><p>1、当for循环的循环边界是固定常数的情况下，合并之后的for循环是以其中那个大的循环边界为边界</p>
<p>2、当两个for循环都是变量的情况下，他们必须是相同的值，也就是说，两个边界变量所能达到的最大值和最小值得是一样的，保证他们要有相同的迭代周期</p>
<p>3、如果循环边界一个是变量，一个是常数，他们是没法合并的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C30.PNG" alt="30"></p>
<p>在这一节中还引入了region的概念，region就是两个花括号之间的代码段，合并for循环可以帮助我们在一定程度上降低时钟周期，在Latency上有所改善，同时使一些for循环能够并行执行，但是要注意并不是所有的循环都能合并，我们需要遵循一定的规则</p>
<h1 id="for循环优化-数据流"><a href="#for循环优化-数据流" class="headerlink" title="for循环优化 - 数据流"></a>for循环优化 - 数据流</h1><h2 id="看一个例子-1"><a href="#看一个例子-1" class="headerlink" title="看一个例子"></a>看一个例子</h2><p>在下面的例子中有三个for循环，分别是Task A，Task B，Task C来做标记，同时for循环所用到的一些变量，也就是一些数组，看他的数据流是怎么样的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C31.PNG" alt="31"></p>
<p>首先进来的是数组A，通过循环Task A，生成变量x，x通过Task B，生成变量y，y通过Task C，生成变量C，通过这个例子可以看到，Task B依赖于Task A，因为Task B用到的变量x是通过Task A传过来的，同样Task C生成的C变量是取决于变量y的，所以可以看到A、B、C三个Task中间是有依赖关系的，结合前面for循环优化的两种方法，pipeline和loop merge，来进行优化</p>
<p>很显然pipeline是没问题的，但是merge是不可以的，因为他们之间存在依赖关系</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C32.PNG" alt="32"></p>
<h2 id="Dataflow（数据流）优化方式"><a href="#Dataflow（数据流）优化方式" class="headerlink" title="Dataflow（数据流）优化方式"></a>Dataflow（数据流）优化方式</h2><p>三个循环，在循环之间可以通过channel，channel可以是Ping-pong RAM，可以是FIFO，也可以是Register</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C33.PNG" alt="33"></p>
<p>在没有使用Dataflow时，三个循环的执行顺序就是如下A、B、C，使用Dataflow之后就变成右边的顺序，特点是，循环之间都是并行的关系，同时循环之间是有交叠的，从下图就可以看到，在执行loopA的时候并不需要执行完loopB就可以执行了，只要loopA有输出，就可以用loopA的输出去执行loopB，同时多个任务之间有交叠，这种交叠可以帮助我们降低Latency，而提高数据吞吐率</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C34.PNG" alt="34"></p>
<h2 id="运用Dataflow之后带来的性能上的好处"><a href="#运用Dataflow之后带来的性能上的好处" class="headerlink" title="运用Dataflow之后带来的性能上的好处"></a>运用Dataflow之后带来的性能上的好处</h2><p>可以看到Latency有明显的降低</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C35.PNG" alt="35"></p>
<p>再看utilization，也有很大的改善</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C36.PNG" alt="36"></p>
<p>此外，对于dataflow在使用的时候，每个for循环之间的channel时pingpong ram还是Register可以通过config_dataflow去配置</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C37.PNG" alt="37"></p>
<p>默认情况下，channel是ping-pong RAM</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C38.PNG" alt="38"></p>
<h2 id="Dataflow优化限制"><a href="#Dataflow优化限制" class="headerlink" title="Dataflow优化限制"></a>Dataflow优化限制</h2><p>并不是所有的for循环都可以使用dataflow，出现下面这些情况的，在使用的时候就要做一些优化或者改善，重点讲前两个</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C39.PNG" alt="39"></p>
<h3 id="Single-producer-consumer-Model"><a href="#Single-producer-consumer-Model" class="headerlink" title="Single-producer-consumer Model"></a>Single-producer-consumer Model</h3><p>在下面这个例子中，loop2和loop3，din通过Loop1会生成temp1，然后temp1通过Loop2会生成dout1，同时temp也会到Loop3生成dout2，所以可以看到temp1是被Loop1和Loop2这两个循环都使用到</p>
<p>这个例子可以使用pipeline，Loop2和Loop3也可以使用merge合并，因为他们两个都是使用temp1执行的</p>
<p>但是这个例子，不能使用dataflow，因为这个模型导致temp1在Loop2和Loop3两个循环中都使用， 所以要进行修改代码，使得可以使用dataflow</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C40.PNG" alt="40"></p>
<p> 首先编写循环loop_copy，在loop_copy中执行的操作很简单，就是把temp1赋给了temp2和temp3，temp2只是流向loop2，temp3只是流向loop3，接着又分别生成dout1和dout2，然后对其进行综合发现，此时的Latency和Interval都有所改善，utilization也有相应的改善，这个是旨在说明，变量只能在一个for循环中被使用</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C41.PNG" alt="41"></p>
<h3 id="Bypassing-Tasks-Model"><a href="#Bypassing-Tasks-Model" class="headerlink" title="Bypassing Tasks Model"></a>Bypassing Tasks Model</h3><p>这个例子是在Loop2中temp1会生成temp3，数据流如右图所示是din通过Loop1生成temp1，temp1通过Loop2生成temp3，但是Loop1中还有一个变量temp2会直接到Loop3，而没有经过Loop2，因此相对于Loop2而言他是Bypassing</p>
<p>这时候，pipeline是可以使用的，</p>
<p>但是如果使用merge，因为temp1在Loop2中会使用，temp2和temp3在Loop3会使用，temp3的数据来自于Loop2和Loop1，所以也是不能使用merge的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C42.PNG" alt="42"></p>
<p>但是我们可以进行优化</p>
<p>我们在Loop2中对temp2进行额外的复制，数据流是din通过Loop1生成temp1和temp2，然后temp1和temp2通过Loop2分别生成temp3和temp4，注意，temp4只是temp2的复制，这样temp2就在Loop2中有所体现，然后再通过Loop3生成dout，这时候就可以使用Dataflow，可以看到综合后的结果相应的Latency、Interval和Utilization都有所体现。</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C43.PNG" alt="43"></p>
<h3 id="配置Dataflow的内存通道（Configuring-Dataflow-Memory-Channels）"><a href="#配置Dataflow的内存通道（Configuring-Dataflow-Memory-Channels）" class="headerlink" title="配置Dataflow的内存通道（Configuring Dataflow Memory Channels）"></a>配置Dataflow的内存通道（Configuring Dataflow Memory Channels）</h3><p>这里说的Memery也就是channel，可以使用ping-pong也可以使用FIFO</p>
<p>1、如果参数是个scalar、pointer或者reference，Vivado HLS会把它作为FIFO</p>
<p>2、如果参数是个数组，结果可能是ping-pong RAM也可能是FIFO</p>
<ul>
<li>如果Vivado HLS能够判断出数据流是按顺序，也就是体现出FIFO的特征，那么这时候就会配置成FIFO，相应的depth深度为1</li>
<li>如果无法检查出数据的特征，也就是说数据的顺序是随机的，这时候就会把channel变成ping-pong RAM</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Configuring Dataflow Memory Channels</span><br><span class="line">Vivado HLS implements channels between the tasks as either ping-pong or FIFO buffers, depending on the access patterns of the producer and the consumer of the data.</span><br><span class="line"><span class="bullet"> - </span>For scalar, pointer, and reference parameters as well as the function return, Vivado HLS implements the channel as a FIFO.</span><br><span class="line"><span class="bullet"> - </span>If the parameter (producer or consumer) is an array, Vivado HLS implements the channel as a ping-pong buffer or a FIFO as follows.</span><br><span class="line"><span class="code">	• If Vivado HLS determines the data is accessed in sequential order, Vivado HLS implements the memory channel as a FIFO channel of depth 1.</span></span><br><span class="line"><span class="code">	• If Vivado HLS is unable to determine that the data is accessed in sequential order or determines the data is accessed in an arbitrary manner, Vivado HLS implements the memory channel as a ping-pong buffer. that is, as two block RAMs each defined by the maximum size of the consumer or producer array.</span></span><br><span class="line">配置数据流内存通道</span><br><span class="line">Vivado HLS根据数据生产者和消费者的访问方式，将任务之间的通道实现为ping-pong或FIFO缓冲区。</span><br><span class="line">  -对于scalar，指针和引用参数以及函数返回值，Vivado HLS将通道实现为FIFO。</span><br><span class="line">  -如果参数（生产者或消费者）是数组，则Vivado HLS将该通道实现为ping-pong缓冲区或FIFO，如下所示。</span><br><span class="line"><span class="code">	• 如果Vivado HLS确定按顺序访问数据，则Vivado HLS将存储通道实现为深度为1的FIFO通道。</span></span><br><span class="line"><span class="code">	• 如果Vivado HLS无法确定按顺序访问数据或确定以随机方式访问数据，则Vivado HLS将存储通道实现为ping-pong缓冲区。（也就是说，作为两个Block RAM，每个Block RAM由使用者或生产者阵列的最大大小定义。）</span></span><br></pre></td></tr></table></figure>

<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C44.PNG" alt="44"></p>
<h3 id="显式指定默认通道（To-explicitly-specify-the-default-channel）"><a href="#显式指定默认通道（To-explicitly-specify-the-default-channel）" class="headerlink" title="显式指定默认通道（To explicitly specify the default channel）"></a>显式指定默认通道（To explicitly specify the default channel）</h3><p>我们也可以通过config_dataflow很显式的告诉Vivado HLS这个Memery是FIFO还是ping-pong RAM，只是需要注意，一旦配置成FIFO，FIFO的深度如果配置的有问题，再RTL协同仿真的时候就会报错</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C45.PNG" alt="45"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>1、dataflow对for循环的改善，可以使得for循环并行的执行方式，也就是说相邻的顺序的变成了并行，体现在for循环可以重叠的执行，下一个for循环不必等到前一个for循环执行完了再执行，只要前一个for循环有输出，就可以利用当前的输出去执行下一个for循环</p>
<p>2、在使用dataflow的时候也有一些限制，最典型的就是上面所讲的那两个限制</p>
<p>3、对于for循环之间的memery也就是channel，我们可以缺省的使用默认的配置方式，也可以显式的配置为FIFO或者ping-pong RAM</p>
<h1 id="for循环优化-嵌套的for循环"><a href="#for循环优化-嵌套的for循环" class="headerlink" title="for循环优化 - 嵌套的for循环"></a>for循环优化 - 嵌套的for循环</h1><h2 id="嵌套for循环的分类"><a href="#嵌套for循环的分类" class="headerlink" title="嵌套for循环的分类"></a>嵌套for循环的分类</h2><p>在Vivado HLS中对嵌套的for循环有三种分类</p>
<h3 id="第一类是perfect-loop-nest"><a href="#第一类是perfect-loop-nest" class="headerlink" title="第一类是perfect loop nest"></a>第一类是perfect loop nest</h3><p>特征是循环边界都是常数，同时循环体只会在最内层的for循环里出现</p>
<h3 id="第二类是Semi-Perfect-loop-nest"><a href="#第二类是Semi-Perfect-loop-nest" class="headerlink" title="第二类是Semi-Perfect loop nest"></a>第二类是Semi-Perfect loop nest</h3><p>这种情况最外层的for循环循环边界是变量，但内层的循环边界是常数，同时循环体也只会在最内层的for循环里出现</p>
<h3 id="第三类是Imperfect-loop-nest"><a href="#第三类是Imperfect-loop-nest" class="headerlink" title="第三类是Imperfect loop nest"></a>第三类是Imperfect loop nest</h3><p>Imperfect loop nest其中又分成两类，</p>
<p>第一类是循环边界是常数，但是循环体出现在外部循环中，</p>
<p>第二类是尽管循环体只在内层for循环，但是最内部的for循环循环边界是个变量</p>
<p>对于Imperfect loop nest希望可以通过代码优化的手段把它转化成Semi-Perfect loop nest或者是Perfect loop nest</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C46.PNG" alt="46"></p>
<h2 id="perfect-loop的例子"><a href="#perfect-loop的例子" class="headerlink" title="perfect loop的例子"></a>perfect loop的例子</h2><p>这个例子是两个矩阵对应元素相乘，这里并不是矩阵的乘法，而是矩阵的元素对应相乘，这里M=2，N=4，是声明在头文件里的，然后做一个对比</p>
<p>三种情况：1、不加任何约束；2、只对内部for’循环做pipeline；3、只对外层循环做pipeline。</p>
<p>可以看到，只对外层for循环做pipeline的时候，Latency是最小的</p>
<p>而在资源消耗方面，对外层for循环做pipeline，DSP48E也就是乘法器，用到了4个，这其实是因为，当我们做流水的时候，如果是对外层for循环做流水，这个外层for循环下面的所有的for循环都会被打开，相应的资源也就会增加，所以这就是乘法器变成了4个的原因</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C47.PNG" alt="47"></p>
<p>如果对最内层的for循环做pipeline，就会看到控制台有一个输出信息，<code>Flattening a loop nest</code>，这时候trip count变成了8，也就是2x4，也就是把内部的for循环展开并打平，外部的for循环也是展开打平，所以count就变成了8</p>
<p>Loop_Flatten的要求是两个for嵌套的循环一定要是perfect loop或者是Simi-perfect loop，</p>
<h2 id="Imperfect-Loop的例子"><a href="#Imperfect-Loop的例子" class="headerlink" title="Imperfect Loop的例子"></a>Imperfect Loop的例子</h2><p>这个是矩阵的乘法，可以看到，在第二个for循环和第三个for循环之间有一个循环体，也就是初始化为0的操作，这两个矩阵都是3x3的矩阵</p>
<h3 id="如果只对最内层的for循环做pipeline（流水）"><a href="#如果只对最内层的for循环做pipeline（流水）" class="headerlink" title="如果只对最内层的for循环做pipeline（流水）"></a>如果只对最内层的for循环做pipeline（流水）</h3><p>1、如果只对最内层的for循环做流水，整个count外部的变成了9，内层的还是3，因为这个col对应的for循环和Product对应的for循环之间有循环体，是无法应用Loop Flatten的，所以这就是为什么Product对应的for循环是3，而Row和Col对应的for循环被打平</p>
<p>同时在分析结果中也可以看到，这个Imperfect loop是要做初始化的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C48.PNG" alt="48"></p>
<h3 id="如果只是对第二层for循环做pipeline"><a href="#如果只是对第二层for循环做pipeline" class="headerlink" title="如果只是对第二层for循环做pipeline"></a>如果只是对第二层for循环做pipeline</h3><p>2、如果只是对第二层for循环做pipeline，也就是Col对应的for循环做流水，首先会在输出信息中看到有一个Unrolling loop ‘Product’，也就是说把Col对应的for循环下面的所有for循环都会打开，所以这时候for循环就变成了Rol和Col都被打平，trip count变成了9，而内部的Product循环会被展开，在这里unrolling和flatten是不一样的概念</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOOP_FLATTEN的directive作用是“允许嵌套循环塌缩为一个循环以减少延时”，原文是“Allows netsed loops to be collapsed into a single loop with inproved latency”</span><br></pre></td></tr></table></figure>

<p>同时在分析表（右下）中还可以看到都有一个a load，同时在相应的信息中也可以看到，会有limited memory ports，在默认情况下会把数组声明为相应的memory，在这里他是一个双端口的memory</p>
<p>在这里得出结论，如果我们对上层的for循环做pipeline，那么这个for循环下面的所有for循环都会被unroll也就是会被展开</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C49.PNG" alt="49"></p>
<h3 id="如果只对最外层的for循环做pipeline"><a href="#如果只对最外层的for循环做pipeline" class="headerlink" title="如果只对最外层的for循环做pipeline"></a>如果只对最外层的for循环做pipeline</h3><p>3、如果只对最外层的for循环做pipeline，他会把下面的for循环全部展开（Unrolling），trip count变成了3，但是DSP48变成了9</p>
<p>这也进一步验证了以上的结论，对上层的for循环做流水，下面的for循环全都会被展开（Unrolling）</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C50.PNG" alt="50"></p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>四种情况</p>
<p>1、不加任何约束</p>
<p>2、对最内层循环做流水</p>
<p>3、对中间层循环做流水</p>
<p>4、对最外层循环做流水</p>
<p>可以看到，Latency的变化，显然，对最外层的循环做流水，可以获得最好的Latency，但是资源方面用到的DSP48是最多的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C51.PNG" alt="51"></p>
<h2 id="对整个函数做流水"><a href="#对整个函数做流水" class="headerlink" title="对整个函数做流水"></a>对整个函数做流水</h2><p>可以看到，整个函数中的循环都被展开了</p>
<p>对函数做流水，能获得最好的Latency，但是相应的，使用的资源也是最多的，DSP48变成了27个</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C52.PNG" alt="52"></p>
<h2 id="矩阵乘法优化"><a href="#矩阵乘法优化" class="headerlink" title="矩阵乘法优化"></a>矩阵乘法优化</h2><p>矩阵乘法的规则可以用相应的地址来表示，比如第i行第j列要算第k个乘法，那么要获得第0行第0列的数据，那么会执行什么样的操作呢？</p>
<p>就是a的第0行，b的第0列，相乘，然后再做相加，获得结果的第0行0列的元素</p>
<p>同样a的第0行，b的第1列，相乘，然后再做相加，获得结果的第0行1列的元素</p>
<p>那么在这个过程中可以看到，a的第0行在算结果的第0行的时候，是保持不变的，实际上我们只要读一次将他缓存起来就可以，而b需要读第0列、第1列、第2列… …，同样在算结果的第1行第0列、1列、2列的元素的时候，类似的也是，我们对a只需要读相应的第1行的元素，对b要读第0列、1列、2列的元素，都要遍历一下</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C53.PNG" alt="53"></p>
<p>经过上面的分析就可以对C代码进行优化，见Cache_Row，做了一个缓存的机制，也就是在计算结果的第0行的元素的时候，把a的第0行缓存下来</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C54.PNG" alt="54"> </p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>1、对循环或者函数做流水的时候，他们所在的下层的for循环都会被展开（unroll）</p>
<p>2、通常情况下，建议对最内部的函数做流水，这样既可以获得较好的Latency，同时资源用量也是可以接受的</p>
<h1 id="for循环优化-其他方法"><a href="#for循环优化-其他方法" class="headerlink" title="for循环优化 - 其他方法"></a>for循环优化 - 其他方法</h1><p>主要内容</p>
<ul>
<li><p>for循环的并行性</p>
</li>
<li><p>for循环在做流水的时候如何使用rewind option</p>
</li>
<li><p>当for循环的循环边界是变量的时候如何处理</p>
</li>
</ul>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C63.PNG" alt="63"></p>
<h2 id="for循环的并行性"><a href="#for循环的并行性" class="headerlink" title="for循环的并行性"></a>for循环的并行性</h2><p>这个例子中，这个函数包括两个for循环，sum_x和sum_y，这两个for循环分别用到了数组A和数组B，然后分别产生了相应的数组X和数组Y，可以看到这两个for循环是相互独立的，也就是说把他们翻译成相应的硬件电路是可以并行执行的，但是从综合后的结果来看，Vivado HLS是把他们做了顺序执行的，我们可以看到整个的Latency是18，来源于两个for循环串行相加的结果</p>
<p>所以，在默认的情况下，Vivado HLS是把for循环做顺序执行的，其实很容易想到，因为这两个for循环是相互独立的，循环边界都是常数且相等，因此可以用merge的方式降低Latency，但是当for循环的边界是变量的时候，是没有办法用merge的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C55.PNG" alt="55"></p>
<p>但是假如把for循环封装成一个函数，然后在顶层函数中对这个函数调用两次，这样的话综合后的结果跟前边的结果是一致的，这样可以看出来，Vivado HLS是把这个函数做了分时复用，相应的节省了资源，但是从并行性的角度而言，相应的函数还是顺序执行的，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C56.PNG" alt="56"></p>
<h3 id="使函数并行执行的方法"><a href="#使函数并行执行的方法" class="headerlink" title="使函数并行执行的方法"></a>使函数并行执行的方法</h3><p>那么有没有什么方式可以实现使函数并行执行呢，我们可以通过ALLOCATION这个directive可以实现让这两个函数并行执行，在这里这个AllOCATION有个limited = 2，就是说将这个函数Accumulator()复制了两份，换言之，这两个函数就实现了并行执行，这时我们可以看到Latency已经变成了10</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C57.PNG" alt="57"></p>
<h3 id="对上面两个结果进行比较"><a href="#对上面两个结果进行比较" class="headerlink" title="对上面两个结果进行比较"></a>对上面两个结果进行比较</h3><p>对上面两个结果进行比较，可以看到整个的Latency是降低了，这里的策略是将for循环封装成函数以后，采用了ALLOCATION的directive，同时把这个for循环做了pipeline，从仿真结果也可以看到，这个函数是并行执行的，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C58.PNG" alt="58"></p>
<h2 id="使用rrewind-option"><a href="#使用rrewind-option" class="headerlink" title="使用rrewind option"></a>使用rrewind option</h2><p>看下面这个for循环，这个for循环有三个操作，读、运算、写，如果我们只是添加了pipeline的策略，这时候，在执行完了一次for’循环在执行下一次for循环时，中间会有一个时钟周期的空挡，如果我们使用rewind之后，两次for循环之间时没有空挡的，这样就降低了整个函数的Latency，因为for循环的Latency降低了，从而也会将整个函数的Latency降低，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C59.PNG" alt="59"></p>
<h3 id="rewind使用举例"><a href="#rewind使用举例" class="headerlink" title="rewind使用举例"></a>rewind使用举例</h3><p>这是一个累加运算，</p>
<p>采用pipeline，并选中<code>enable loop rewinding (option)</code>，</p>
<p>这时候可以看到，在默认情况下，以及只添加pipeline，以及添加pipeline并选中rewind三种solution做了比较，</p>
<p>显然，采用添加pipeline并选中rewind的方式Latency时最小的，Interval也是最小的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C60.PNG" alt="60"></p>
<p>从仿真结果也可以看出来，在没有rewind的情况下，for循环在执行的时候，中间会有一段空挡，添加rewind之后就没有空档了，执行是连续的执行</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C61.PNG" alt="61"></p>
<h3 id="函数中有多个循环的情况"><a href="#函数中有多个循环的情况" class="headerlink" title="函数中有多个循环的情况"></a>函数中有多个循环的情况</h3><p>当我们的函数中有多个循环的时候，比如下面这个例子，有sum_x和sum_y，这时候如果我们再对这两个或者其中的某一个做rewind的时候，会抛出警告如下，告诉我们因为这个函数包含了多个循环，因此没法执行rewind，因此rewind不是适用于所有的for循环，他是有条件的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C62.PNG" alt="62"></p>
<h3 id="如何对for循环自动添加流水"><a href="#如何对for循环自动添加流水" class="headerlink" title="如何对for循环自动添加流水"></a>如何对for循环自动添加流水</h3><p>这个时候就要用到config_compile configuration，这个是通过pipeline loops option来设置我们期望的循环次数，换言之，当这个循环次数小于我们设定的值的时候，这个循环就会被添加流水</p>
<p>比如这里的参数pipeline loops设置为6，那么当循环的次数小于6的时候就会被添加流水</p>
<p>如果在使用config_compile之后，如果仍然希望有一些for’循环不做流水，这时候我们就可以在directive的pipeline这个选项中将disable loop pipelining选项选中，那么相应的for循环就不会被添加流水，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C64.PNG" alt="64"></p>
<h3 id="添加pipeline失效的情况"><a href="#添加pipeline失效的情况" class="headerlink" title="添加pipeline失效的情况"></a>添加pipeline失效的情况</h3><p> 当我们对一个任务把它作为pipeline的时候，对于函数或者一个for循环，相应的这些函数或者for循环下边的操作都会被展开，那么如果这个for循环的循环边界是一个变量的话，就阻止了工具对相应的操作执行流水，这是因为Vivado HLS并不知道这个循环什么时候能够完成，这就是要讲的下一个问题，如何处理循环边界是变量的情形。</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C65.PNG" alt="65"></p>
<h3 id="如何处理循环边界是变量的情形"><a href="#如何处理循环边界是变量的情形" class="headerlink" title="如何处理循环边界是变量的情形"></a>如何处理循环边界是变量的情形</h3><p>当循环边界是变量的时候会引发一些问题，首先是Vivado HLS无法确定Loop的Latency是多少，进而也就无法确定整个函数的Latency，这时候相应的Latency会以问号作为标记，在下面的例子中，循环边界width是个变量，最后的综合报告中可以看到，Latency和Interval都是问号，这里这个width是个int型，也就是32位的一个整型</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C66.PNG" alt="66"></p>
<p>对于这种情况，有三种处理方式：</p>
<p>1、使用Tripcount的directive</p>
<p>2、将循环边界的数据类型声明为<code>ap_int&lt;w&gt;</code></p>
<p>3、使用assert这个macro</p>
<h4 id="使用Tripcount的directive的方式"><a href="#使用Tripcount的directive的方式" class="headerlink" title="使用Tripcount的directive的方式"></a>使用Tripcount的directive的方式</h4><p>先看一下使用Tripcount的directive的方式，在这里有一个min和一个max，是用来说明tripcount的最大值和最小值，相应的综合后的报告中就能看到，tripcount的值的范围是4 ~ 8，相应的Latency就有min和max，interval也有相应的min和max</p>
<p>这里需要注意的是，tripcount这个directive不会影响综合后的结果，不会对综合做任何的优化，只是用于报告的显示，以及不同solution之间的比较，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C67.PNG" alt="67"></p>
<h4 id="将循环边界的数据类型声明为ap-int-lt-w-gt"><a href="#将循环边界的数据类型声明为ap-int-lt-w-gt" class="headerlink" title="将循环边界的数据类型声明为ap_int&lt;w&gt;"></a>将循环边界的数据类型声明为<code>ap_int&lt;w&gt;</code></h4><p>再看一下将循环边界声明为<code>ap_int&lt;w&gt;</code>类型的情景，因为我们在头文件里定义了TEST，所以相应的循环边界的类型就变成了ap_int&lt;5&gt;，所以综合后的报告中tripcount就变成了0 ~ 15，因为5位有符号整数所能表示的最大值就是15</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C68.PNG" alt="68"></p>
<p>看一下综合后的结果，从资源角度看，整个的LUT会减少，触发器也会减少</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C69.PNG" alt="69"></p>
<h4 id="使用assert这个macro"><a href="#使用assert这个macro" class="headerlink" title="使用assert这个macro"></a>使用assert这个macro</h4><p>头文件添加<code>#include&lt;assert.h&gt;</code>，同时在for循环上边声明<code>assert(width &lt; 5);</code>，这时候tripcount就变成了0 ~ 4，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C70.PNG" alt="70"></p>
<p>综合后的报告可以看到，整个资源也会进一步减少，LUT从104变成了29，触发器由80变成了19，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C71.PNG" alt="71"></p>
<p>对这三种方法进一步作比较，当采用assert这种方式的时候，Latency是最小的，同时相应的资源消耗也是最小</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C72.PNG" alt="72"></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>1、当函数中有多个for循环的时候，即便多个for循环是相互独立的，Vivado HLS默认情况下也会让他们默认执行，而不是并行处理</p>
<p>2、当我们对for循环做pipeline的时候，我们可以选择rewind，帮助我们进一步改善Latency，但是并不是所有的for循环都能使用rewind</p>
<p>3、当循环边界是变量的时候，我们有三种处理方式，通过tripcount、通过改变循环边界的变量类型、通过采用assert三种方式，其中后两种方式是可以帮助我们改善综合后的一些结果，比如Latency以及资源。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="ylyang.xyz/2020/01/04/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tou2.jpg">
      <meta itemprop="name" content="ylyang">
      <meta itemprop="description" content="云山苍苍，江水泱泱；先生之风，山高水长。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/04/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">复合数据类型在Vivado HLS中的应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="文章创建时间：2020-01-04 12:59:05" itemprop="dateCreated datePublished" datetime="2020-01-04T12:59:05+08:00">2020-01-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vivado-HLS/" itemprop="url" rel="index"><span itemprop="name">Vivado HLS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="复合数据类型在Vivado-HLS中的应用"><a href="#复合数据类型在Vivado-HLS中的应用" class="headerlink" title="复合数据类型在Vivado HLS中的应用"></a>复合数据类型在Vivado HLS中的应用</h1><h2 id="结构体Struct"><a href="#结构体Struct" class="headerlink" title="结构体Struct"></a>结构体Struct</h2><h3 id="当结构体被用作顶层函数的参数时"><a href="#当结构体被用作顶层函数的参数时" class="headerlink" title="当结构体被用作顶层函数的参数时"></a>当结构体被用作顶层函数的参数时</h3><p>对于<code>scalar</code>，会被映射为<code>scalar</code>类型的端口</p>
<p>对于数组，会被映射为默认的<code>memory</code>端口</p>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>在实际使用中建议结构体预先在头文件中声明</p>
<h3 id="data-packing"><a href="#data-packing" class="headerlink" title="data packing"></a>data packing</h3><p>对于结构体中的元素，Vivado HLS提供了相应的优化方式，叫做<code>data packing</code></p>
<p>这种优化方式具体有两种，一种是<code>field_level</code>，一种是<code>struct_level</code></p>
<ul>
<li><code>field_level</code></li>
<li><code>struct_level</code></li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C1.PNG" alt="1"></p>
<p>在这个例子中，首先在头文件中定义了一个结构体</p>
<p>结构体中有两个变量</p>
<p><code>A_t A</code>：类型为<code>ap_int&lt;4&gt;</code></p>
<p><code>B_t B[4]</code>：类型为<code>ap_uint&lt;4&gt;</code>的数组，数组元素4个</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C2.PNG" alt="2"></p>
<p>然后进行操作，对于变量<code>A</code>，执行的是加法。进行加2操作</p>
<p>对于变量<code>B[]</code>，对数组中的每一个元素都加2</p>
<p>最后返回值返回的也是一个结构体变量</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C3.PNG" alt="3"></p>
<p>用<code>cout</code>查看结构体的<code>size</code>，结果是5</p>
<p>因为</p>
<p><code>A_t A</code>：类型为<code>ap_int&lt;4&gt;</code>占1个byte</p>
<p><code>B_t B[4]</code>：类型为<code>ap_uint&lt;4&gt;</code>的数组，数组元素4个，占4个byte</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C4.PNG" alt="4"></p>
<h5 id="field-level"><a href="#field-level" class="headerlink" title="field_level"></a>field_level</h5><p>把每个元素都扩展成8bits</p>
<p>最后<code>40bits</code>，</p>
<p>因为五个元素，<code>5 x 8 = 40</code></p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C5.PNG" alt="5"></p>
<h5 id="struct-level"><a href="#struct-level" class="headerlink" title="struct_level"></a>struct_level</h5><p>对于每一个元素的实际位宽，依然保留，但是封装后的位宽要取8比特的整数倍</p>
<p>这里，五个元素，<code>5x4=20</code>，取8比特的整数倍=24，最终位宽是24bits</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C6.PNG" alt="6"></p>
<p>对其进行比较</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C7.PNG" alt="7"></p>
<p>各方面基本一致</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C8.PNG" alt="8"></p>
<p>从这里也可以看到，data packing可以帮助把<code>latency</code>降低，initial interval也降低，提高了系统的吞吐率</p>
<p>之所以能提高，在这个函数而言是因为把for循环展开了</p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C9.PNG" alt="9"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="ylyang.xyz/2020/01/03/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tou2.jpg">
      <meta itemprop="name" content="ylyang">
      <meta itemprop="description" content="云山苍苍，江水泱泱；先生之风，山高水长。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/03/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">数据类型的转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="文章创建时间：2020-01-03 12:59:05" itemprop="dateCreated datePublished" datetime="2020-01-03T12:59:05+08:00">2020-01-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vivado-HLS/" itemprop="url" rel="index"><span itemprop="name">Vivado HLS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h1><h2 id="如何对一个变量进行初始化"><a href="#如何对一个变量进行初始化" class="headerlink" title="如何对一个变量进行初始化"></a>如何对一个变量进行初始化</h2><p>在传统的C语言中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val_i = <span class="number">-6</span>;</span><br></pre></td></tr></table></figure>

<p>对任意精度的数据类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ap_int&lt;<span class="number">6</span>&gt; a_6bit_var_c = <span class="number">-22</span>; <span class="comment">//copy initialization(Y)</span></span><br><span class="line"><span class="function">ap_int&lt;6&gt; <span class="title">a_6bit_var_d</span><span class="params">(<span class="number">-22</span>)</span></span>; <span class="comment">//direct initialization(Y)</span></span><br><span class="line">ap_int&lt;<span class="number">6</span>&gt; a_6bit_var_u&#123;<span class="number">-22</span>&#125;; <span class="comment">//uniform initialization(N), 目前的Vivado HLS不支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用任意进制的格式</span></span><br><span class="line"><span class="function">ap_int&lt;6&gt; <span class="title">a_6bit_var_r2</span><span class="params">(<span class="string">"0b101010"</span>, <span class="number">2</span>)</span></span>; <span class="comment">//二进制</span></span><br><span class="line"><span class="function">ap_int&lt;6&gt; <span class="title">a_6bit_var_r2</span><span class="params">(<span class="string">"0o52"</span>, <span class="number">8</span>)</span></span>; <span class="comment">//八进制</span></span><br><span class="line"><span class="function">ap_int&lt;6&gt; <span class="title">a_6bit_var_r2</span><span class="params">(<span class="string">"-22"</span>, <span class="number">10</span>)</span></span>; <span class="comment">//十进制</span></span><br><span class="line"><span class="function">ap_int&lt;6&gt; <span class="title">a_6bit_var_r2</span><span class="params">(<span class="string">"0x2A"</span>, <span class="number">16</span>)</span></span>; <span class="comment">//十六进制</span></span><br></pre></td></tr></table></figure>

<p>当然，在上边任意进制的格式中，前边<code>0b，0o，0x</code>，这种显式的声明可以去掉。</p>
<p>在初始化的时候尽量每一行只初始化一个变量，避免一行初始化多个变量。</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%5C1.PNG" alt="1"></p>
<h2 id="对于ap-u-fixed-lt-W-I-Q-O-gt-这种变量"><a href="#对于ap-u-fixed-lt-W-I-Q-O-gt-这种变量" class="headerlink" title="对于ap_[u]fixed&lt;W, I, Q, O&gt;这种变量"></a>对于<code>ap_[u]fixed&lt;W, I, Q, O&gt;</code>这种变量</h2><p>对于<code>ap_[u]fixed&lt;W, I, Q, O&gt;</code>这种变量，他的<code>&lt;&gt;</code>中由四个参数，分别代表</p>
<p><code>W</code>：代表整个的数据字长</p>
<p><code>I</code>：代表整数部分的数据字长，显然小数部分的字长就是：<code>W - I</code></p>
<p><code>Q</code>：代表<strong>量化模式</strong>，针对低位部分</p>
<p><code>O</code>：表示了<strong>Overflow</strong>，<strong>溢出模式</strong>，针对高位部分</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var1字长为3，整数部分的字长为2</span></span><br><span class="line"><span class="comment">//1.25用2进制表示：01.01，小数点在中间位置</span></span><br><span class="line"><span class="comment">//biaoshicheng&lt;3, 2&gt;，字长为3，整数部分的字长为2</span></span><br><span class="line"><span class="comment">//就变成了01.0，var1结果其实就是1</span></span><br><span class="line">ap_fixed&lt;<span class="number">3</span>, <span class="number">2</span>&gt; var1 = <span class="number">1.25</span>;</span><br><span class="line"><span class="comment">//var2采用了AP_RND量化模式，最终数值是1.5</span></span><br><span class="line">ap_fixed&lt;<span class="number">3</span>, <span class="number">2</span>, AP_RND&gt; var2 = <span class="number">1.25</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//19用2进制表示010011这种形式，</span></span><br><span class="line"><span class="comment">//字长为4，整数部分为4，所以是取低四位，所以是0011，所以是3</span></span><br><span class="line">ap_fixed&lt;<span class="number">4</span>, <span class="number">4</span>&gt; var3 = <span class="number">19</span>;</span><br><span class="line"><span class="comment">//var4溢出模式AP_SAT，所以值为四位有符号数所能表示的最大数值，0111，7</span></span><br><span class="line">ap_fixed&lt;<span class="number">3</span>, <span class="number">2</span>, AP_RND, AP_SAT&gt; var4 = <span class="number">19</span>;</span><br></pre></td></tr></table></figure>

<p>定义浮点类型的数值时，后边要有<code>f</code>，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">vf2</span><span class="params">(<span class="number">5.0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">vf3</span><span class="params">(<span class="number">5.0f</span>)</span></span>; <span class="comment">//表示单精度浮点</span></span><br></pre></td></tr></table></figure>

<p>Vivado HLS的数学库（<code>hls_math.h</code>）提供了对标准C的（<code>math.h</code>）和C++的（<code>cmath</code>）都提供了支持</p>
<ul>
<li>支持包括单精度、双精度以及浮点数据类型本身的支持</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hls_math.h</span><br><span class="line">math.h</span><br><span class="line">cmath</span><br></pre></td></tr></table></figure>

<h2 id="隐式数据类型转换"><a href="#隐式数据类型转换" class="headerlink" title="隐式数据类型转换"></a>隐式数据类型转换</h2><p>隐式的数据类型转换包括<code>promotion</code>和<code>conversion</code>两种，</p>
<p><code>promotion</code>：一种安全的方式，将小范围向大范围的，或者说将小类型的向大类型的数据转换</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%5C2.PNG" alt="2"></p>
<p><code>conversion</code>：可能会造成数据精度的损失</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%5C3.PNG" alt="3"></p>
<h2 id="数据类型显式的转换"><a href="#数据类型显式的转换" class="headerlink" title="数据类型显式的转换"></a>数据类型显式的转换</h2><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%5C4.PNG" alt="4"></p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%5C5.PNG" alt="5"></p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%5C6.PNG" alt="6"></p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%5C7.PNG" alt="7"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="ylyang.xyz/2020/01/02/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%BB%E6%84%8F%E7%B2%BE%E5%BA%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tou2.jpg">
      <meta itemprop="name" content="ylyang">
      <meta itemprop="description" content="云山苍苍，江水泱泱；先生之风，山高水长。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/02/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%BB%E6%84%8F%E7%B2%BE%E5%BA%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">如何处理任意精度的数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="文章创建时间：2020-01-02 12:59:05" itemprop="dateCreated datePublished" datetime="2020-01-02T12:59:05+08:00">2020-01-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vivado-HLS/" itemprop="url" rel="index"><span itemprop="name">Vivado HLS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="任意精度的数据类型"><a href="#任意精度的数据类型" class="headerlink" title="任意精度的数据类型"></a>任意精度的数据类型</h1><p>传统的C语言支持的数据类型：包括字符型、整型、浮点型等等，整型分为有符号和无符号，有符号用signed标识，无符号用unsigned标识，有符号的signed可以省略。</p>
<p><img data-src="1.PNG" alt="1"></p>
<p>Vivado HLS对于两种字符型是不支持的：char16_t(C++11 only)、char32_t(C++11 only)</p>
<p><img data-src="2.PNG" alt="2"></p>
<p>从硬件的角度看数据类型：</p>
<p>采用传统的C语言的数据类型的限制</p>
<ul>
<li>都是以8为边界：8，16，32，64bits</li>
</ul>
<p><img data-src="4.PNG" alt="4"></p>
<p><img data-src="3.PNG" alt="3"></p>
<h1 id="采用任意精度数据类型的好处"><a href="#采用任意精度数据类型的好处" class="headerlink" title="采用任意精度数据类型的好处"></a>采用任意精度数据类型的好处</h1><p>可以看到，采用任意精度的数据类型，可以运行到更高的时钟频率、获得更好的数据吞吐率、在资源方面消耗的也最少</p>
<p>因此，采用任意精度的数据类型可以获得很多好处，而且通常情况下C/C++所支持的整型的数据类型的相关的运算，ap_[u]int和ap_[u]fixed也都是支持的</p>
<p>采用任意精度的数据类型可以以更少的资源，获得相同的精度，同时还可以运行在相同的时钟频率下</p>
<p><img data-src="5.PNG" alt="5"></p>
<p>当我们在声明一个任意精度的数据类型的时候一般会在头文件中进行声明，这在做debug的时候会非常有用，如下所示的例子，这里定义了一个头文件，在头文件中有一个宏，同时位宽是18，可以根据宏定义进行切换，数据类型到底是int还是ap_int，相应的在Vivado HLS的Outline里也可以看到，这时候有宏定义的时候，相应的数据类型会以高亮的形式显示出来</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%BB%E6%84%8F%E7%B2%BE%E5%BA%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%5C6.PNG" alt="6"></p>
<p>跟数据类型相应的是<code>sizeof()</code>，这个返回的是数据类型所占用的相应的字节，使用方法是参数传入数据类型或者传入变量名，下图中也可以看到这些数据类型所占用的位数。</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%BB%E6%84%8F%E7%B2%BE%E5%BA%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%5C7.PNG" alt="7"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="ylyang.xyz/2020/01/01/VivadoHLS%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tou2.jpg">
      <meta itemprop="name" content="ylyang">
      <meta itemprop="description" content="云山苍苍，江水泱泱；先生之风，山高水长。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/01/VivadoHLS%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">VivadoHLS的设计流程介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="文章创建时间：2020-01-01 12:59:05" itemprop="dateCreated datePublished" datetime="2020-01-01T12:59:05+08:00">2020-01-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vivado-HLS/" itemprop="url" rel="index"><span itemprop="name">Vivado HLS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="VivadoHLS的设计流程（介绍）"><a href="#VivadoHLS的设计流程（介绍）" class="headerlink" title="VivadoHLS的设计流程（介绍）"></a>VivadoHLS的设计流程（介绍）</h1><h2 id="传统的RTL设计流程："><a href="#传统的RTL设计流程：" class="headerlink" title="传统的RTL设计流程："></a>传统的RTL设计流程：</h2><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps23.jpg" alt="img"> </p>
<p>如果采用传统的RTL设计流程，就需要用硬件描述语言比如VHDL、Verilog或者System Verilog描述算法以及相应的Test Bench，然后执行行为级仿真（RTL Simulation），这个过程是一个迭代的过程，以验证算法的正确性，然后再执行综合（Synthesis）和实现（Implementation），在这个阶段要实现设计的收敛（Design Closure），要从Latency、Timing和Resource三个角度进行考察，最后进行系统级的全面的测试，这也是一个迭代的过程。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/01/01/VivadoHLS%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="ylyang.xyz/2020/01/01/VivadoHLS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tou2.jpg">
      <meta itemprop="name" content="ylyang">
      <meta itemprop="description" content="云山苍苍，江水泱泱；先生之风，山高水长。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/01/VivadoHLS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Vivado HLS的工作原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="文章创建时间：2020-01-01 12:59:05" itemprop="dateCreated datePublished" datetime="2020-01-01T12:59:05+08:00">2020-01-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vivado-HLS/" itemprop="url" rel="index"><span itemprop="name">Vivado HLS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vivado-HLS的工作原理"><a href="#Vivado-HLS的工作原理" class="headerlink" title="Vivado HLS的工作原理"></a>Vivado HLS的工作原理</h1><h2 id="EDA领域的发展历史"><a href="#EDA领域的发展历史" class="headerlink" title="EDA领域的发展历史"></a>EDA领域的发展历史</h2><h3 id="CAD-gt-CAE-gt-EDA"><a href="#CAD-gt-CAE-gt-EDA" class="headerlink" title="CAD -&gt; CAE -&gt; EDA"></a>CAD -&gt; CAE -&gt; EDA</h3><ul>
<li>Computer Aided Design</li>
<li>Computer Aided Engineering</li>
<li>Electronic Design Automation<ul>
<li>在EDA阶段最典型的特征就是出现了HDL（硬件描述语言），例如VHDL和Verilog</li>
</ul>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/01/01/VivadoHLS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="ylyang.xyz/2019/11/05/Http%E5%92%8CHttps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tou2.jpg">
      <meta itemprop="name" content="ylyang">
      <meta itemprop="description" content="云山苍苍，江水泱泱；先生之风，山高水长。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/05/Http%E5%92%8CHttps/" class="post-title-link" itemprop="url">计算机网络之Http和Https</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="文章创建时间：2019-11-05 18:10:39" itemprop="dateCreated datePublished" datetime="2019-11-05T18:10:39+08:00">2019-11-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Http和Https"><a href="#Http和Https" class="headerlink" title="Http和Https"></a>Http和Https</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http是一种无状态协议。无状态是指客户机和服务器之间不需要建立持久连接，这意味着当一个客户端向服务器发出请求，然后服务器返回响应（response），连接就被关闭了，在服务器端不保留连接的有关信息，HTTP遵循请求/应答模型。客户机向服务器发送请求，服务器处理请求并返回适当的应答。所有HTTP连接都构成一套请求和应答。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/11/05/Http%E5%92%8CHttps/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Powered by ylyang</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/npm/ribbon.js@1/dist/ribbon.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>


  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
