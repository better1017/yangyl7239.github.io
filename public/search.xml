<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ubuntu上多版本Python切换默认Python环境问题</title>
      <link href="/2020/08/08/Ubuntu%E4%B8%8A%E5%A4%9A%E7%89%88%E6%9C%ACPython%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4Python%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/"/>
      <url>/2020/08/08/Ubuntu%E4%B8%8A%E5%A4%9A%E7%89%88%E6%9C%ACPython%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4Python%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="切换默认Python环境"><a href="#切换默认Python环境" class="headerlink" title="切换默认Python环境"></a>切换默认Python环境</h1><p>使用 ls 命令来查看系统中都有那些 Python 的二进制文件可供使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls &#x2F;usr&#x2F;bin&#x2F;python*</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;python &#x2F;usr&#x2F;bin&#x2F;python2 &#x2F;usr&#x2F;bin&#x2F;python2.7 &#x2F;usr&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python3.4 &#x2F;usr&#x2F;bin&#x2F;python3.4m &#x2F;usr&#x2F;bin&#x2F;python3m</span><br></pre></td></tr></table></figure><p>执行如下命令查看默认的 Python 版本信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python --version</span><br><span class="line">Python 2.7.8</span><br></pre></td></tr></table></figure><h2 id="系统级修改-Python-版本"><a href="#系统级修改-Python-版本" class="headerlink" title="系统级修改 Python 版本"></a>系统级修改 Python 版本</h2><p>使用 <code>update-alternatives</code> 这个命令来为整个系统更改 Python 版本。</p><a id="more"></a><p>以 root 身份登录，首先罗列出所有可用的 python 替代版本信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># update-alternatives --list python</span><br></pre></td></tr></table></figure><p>可能会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives: error: no alternatives &#96;&#96;for&#96; &#96;python</span><br></pre></td></tr></table></figure><p>如果出现以上所示的错误信息，则表示 Python 的替代版本尚未被 update-alternatives 命令识别。</p><p>想解决这个问题，我们需要更新一下替代列表，将 python2.7 和 python3.4 放入其中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;python python &#x2F;usr&#x2F;bin&#x2F;python2.7 1</span><br><span class="line">update-alternatives: using &#x2F;usr&#x2F;bin&#x2F;python2.7 to provide &#x2F;usr&#x2F;bin&#x2F;python (python) in auto mode</span><br><span class="line"># update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;python python &#x2F;usr&#x2F;bin&#x2F;python3.4 2</span><br><span class="line">update-alternatives: using &#x2F;usr&#x2F;bin&#x2F;python3.4 to provide &#x2F;usr&#x2F;bin&#x2F;python (python) in auto mode</span><br></pre></td></tr></table></figure><p>–install 选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中。</p><p>这个例子中，我们为 /usr/bin/python3.4 设置的优先级为2，所以update-alternatives 命令会自动将它设置为默认 Python 版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># python --version</span><br><span class="line">Python 3.4.2</span><br></pre></td></tr></table></figure><p>接下来，我们再次列出可用的 Python 替代版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># update-alternatives --list python</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;python2.7</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;python3.4</span><br></pre></td></tr></table></figure><p>现在开始，我们就可以使用下方的命令随时在列出的 Python 替代版本中任意切换了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># update-alternatives --config python</span><br><span class="line">There are 2 choices for the alternative python (providing &#x2F;usr&#x2F;bin&#x2F;python).</span><br><span class="line"></span><br><span class="line">  Selection    Path                Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">* 0            &#x2F;usr&#x2F;bin&#x2F;python3.6   2         auto mode</span><br><span class="line">  1            &#x2F;usr&#x2F;bin&#x2F;python2.7   1         manual mode</span><br><span class="line">  2            &#x2F;usr&#x2F;bin&#x2F;python3.6   2         manual mode</span><br><span class="line"></span><br><span class="line">Press &lt;enter&gt; to keep the current choice[*], or type selection number:</span><br></pre></td></tr></table></figure><p>根据提示选择序号即可切换默认python版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># python --version</span><br><span class="line">Python 2.7.8</span><br></pre></td></tr></table></figure><h3 id="移除替代版本"><a href="#移除替代版本" class="headerlink" title="移除替代版本"></a>移除替代版本</h3><p>一旦我们的系统中不再存在某个 Python 的替代版本时，我们可以将其从 update-alternatives 列表中删除掉。例如，我们可以将列表中的 python2.7 版本移除掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># update-alternatives --remove python &#x2F;usr&#x2F;bin&#x2F;python2.7</span><br><span class="line"> </span><br><span class="line">update-alternatives: removing manually selected alternative - switching python to auto mode</span><br><span class="line">update-alternatives: using &#x2F;usr&#x2F;bin&#x2F;python3.4 to provide &#x2F;usr&#x2F;bin&#x2F;python (python) in auto mode</span><br></pre></td></tr></table></figure><h3 id="方法2-移除软连接"><a href="#方法2-移除软连接" class="headerlink" title="方法2 移除软连接"></a>方法2 移除软连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf &#x2F;data&#x2F;logs</span><br><span class="line"> </span><br><span class="line">ln -s &#x2F;temp&#x2F;logs &#x2F;data&#x2F;logs</span><br></pre></td></tr></table></figure><p>解决软连接ln报错-bash: /usr/local/bin/mysql: Too many levels of symbolic links</p><h2 id="基于用户修改-Python-版本"><a href="#基于用户修改-Python-版本" class="headerlink" title="基于用户修改 Python 版本"></a>基于用户修改 Python 版本</h2><p>想要为某个特定用户修改 Python 版本，只需要在其 home 目录下创建一个 alias(别名) 即可。打开该用户的 ~/.bashrc文件，添加新的别名信息来修改默认使用的 Python 版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias python&#x3D;&#39;&#x2F;usr&#x2F;bin&#x2F;python3.4&#39;</span><br></pre></td></tr></table></figure><p>一旦完成以上操作，重新登录或者重新加载 .bashrc 文件，使操作生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ . ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><p>检查当前的 Python 版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python --version</span><br><span class="line">Python 3.4.2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo源码环境搭建</title>
      <link href="/2020/08/06/Dubbo%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/08/06/Dubbo%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建-Dubbo-源码环境"><a href="#搭建-Dubbo-源码环境" class="headerlink" title="搭建 Dubbo 源码环境"></a>搭建 Dubbo 源码环境</h1><h2 id="Dubbo-架构简介"><a href="#Dubbo-架构简介" class="headerlink" title="Dubbo 架构简介"></a>Dubbo 架构简介</h2><p>简单介绍一下 Dubbo 架构中的核心角色，简单了解一下 Dubbo 的架构。下图是Dubbo核心架构图，展示了 Dubbo 核心架构：</p><a id="more"></a><p><img data-src="1.png" alt="Dubbo 核心架构图"></p><ul><li><p>Registry：注册中心。 负责服务地址的注册与查找，服务的 Provider 和 Consumer 只在启动时与注册中心交互。注册中心通过长连接感知 Provider 的存在，在 Provider 出现宕机的时候，注册中心会立即推送相关事件通知 Consumer。</p></li><li><p>Provider：服务提供者。 在它启动的时候，会向 Registry 进行注册操作，将自己服务的地址和相关配置信息封装成 URL 添加到 ZooKeeper 中。</p></li><li><p>Consumer：服务消费者。 在它启动的时候，会向 Registry 进行订阅操作。订阅操作会从 ZooKeeper 中获取 Provider 注册的 URL，并在 ZooKeeper 中添加相应的监听器。获取到 Provider URL 之后，Consumer 会根据负载均衡算法从多个 Provider 中选择一个 Provider 并与其建立连接，最后发起对 Provider 的 RPC 调用。 如果 Provider URL 发生变更，Consumer 将会通过之前订阅过程中在注册中心添加的监听器，获取到最新的 Provider URL 信息，进行相应的调整，比如断开与宕机 Provider 的连接，并与新的 Provider 建立连接。Consumer 与 Provider 建立的是长连接，且 Consumer 会缓存 Provider 信息，所以一旦连接建立，即使注册中心宕机，也不会影响已运行的 Provider 和 Consumer。</p></li><li><p>Monitor：监控中心。 用于统计服务的调用次数和调用时间。Provider 和 Consumer 在运行过程中，会在内存中统计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。监控中心在上面的架构图中并不是必要角色，监控中心宕机不会影响 Provider、Consumer 以及 Registry 的功能，只会丢失监控数据而已。</p></li></ul><h2 id="搭建Dubbo源码环境"><a href="#搭建Dubbo源码环境" class="headerlink" title="搭建Dubbo源码环境"></a>搭建Dubbo源码环境</h2><p>当然，要搭建Dubbo 源码环境，你首先需要下载源码。这里你可以直接从官方仓库 <a href="https://github.com/apache/dubboFork" target="_blank" rel="noopener">https://github.com/apache/dubboFork</a> 到自己的仓库，直接执行下面的命令去下载代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:xxxxxxxx/dubbo.git</span><br></pre></td></tr></table></figure><p>然后切换分支，这里我们用Dubbo 2.7.7 这个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dubbo-2.7.7 dubbo-2.7.7</span><br></pre></td></tr></table></figure><p>接下来，执行 mvn 命令进行编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip&#x3D;true</span><br></pre></td></tr></table></figure><p>最后，执行下面的命令转换成 IDEA 项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn idea:idea &#x2F;&#x2F; 要是执行报错，就执行这个 mvn idea:workspace</span><br></pre></td></tr></table></figure><p>然后，在 IDEA 中导入源码，因为这个导入过程中会下载所需的依赖包，所以会耗费点时间。</p><h2 id="Dubbo源码核心模块"><a href="#Dubbo源码核心模块" class="headerlink" title="Dubbo源码核心模块"></a>Dubbo源码核心模块</h2><p>在 IDEA 成功导入 Dubbo 源码之后，看到的项目结构如下图所示：</p><p><img data-src="2.png" alt="项目结构"></p><p>简单介绍一下这些核心模块的功能，至于详细分析，后面再说：</p><ul><li>dubbo-common 模块： Dubbo 的一个公共模块，其中有很多工具类以及公共逻辑，例如课程后面紧接着要介绍的 Dubbo SPI 实现、时间轮实现、动态编译器等。</li></ul><p><img data-src="3.png" alt="dubbo-common模块"></p><ul><li>dubbo-remoting 模块： Dubbo 的远程通信模块，其中的子模块依赖各种开源组件实现远程通信。在 dubbo-remoting-api 子模块中定义该模块的抽象概念，在其他子模块中依赖其他开源组件进行实现，例如，dubbo-remoting-netty4 子模块依赖 Netty 4 实现远程通信，dubbo-remoting-zookeeper 通过 Apache Curator 实现与 ZooKeeper 集群的交互。</li></ul><p><img data-src="4.png" alt="4"></p><ul><li>dubbo-rpc 模块： Dubbo 中对远程调用协议进行抽象的模块，其中抽象了各种协议，依赖于 dubbo-remoting 模块的远程调用功能。dubbo-rpc-api 子模块是核心抽象，其他子模块是针对具体协议的实现，例如，dubbo-rpc-dubbo 子模块是对 Dubbo 协议的实现，依赖了 dubbo-remoting-netty4 等 dubbo-remoting 子模块。 dubbo-rpc 模块的实现中只包含一对一的调用，不关心集群的相关内容。</li></ul><p><img data-src="5.png" alt="5"></p><ul><li><p>dubbo-cluster 模块： Dubbo 中负责管理集群的模块，提供了负载均衡、容错、路由等一系列集群相关的功能，最终的目的是将多个 Provider 伪装为一个 Provider，这样 Consumer 就可以像调用一个 Provider 那样调用 Provider 集群了。</p></li><li><p>dubbo-registry 模块： Dubbo 中负责与多种开源注册中心进行交互的模块，提供注册中心的能力。其中， dubbo-registry-api 子模块是顶层抽象，其他子模块是针对具体开源注册中心组件的具体实现，例如，dubbo-registry-zookeeper 子模块是 Dubbo 接入 ZooKeeper 的具体实现。</p></li></ul><p><img data-src="6.png" alt="6"></p><ul><li><p>dubbo-monitor 模块： Dubbo 的监控模块，主要用于统计服务调用次数、调用时间以及实现调用链跟踪的服务。</p></li><li><p>dubbo-config 模块： Dubbo 对外暴露的配置都是由该模块进行解析的。例如，dubbo-config-api 子模块负责处理 API 方式使用时的相关配置，dubbo-config-spring 子模块负责处理与 Spring 集成使用时的相关配置方式。有了 dubbo-config 模块，用户只需要了解 Dubbo 配置的规则即可，无须了解 Dubbo 内部的细节。</p></li></ul><p><img data-src="7.png" alt="7"></p><ul><li>dubbo-metadata 模块： Dubbo 的元数据模块（本课程后续会详细介绍元数据的内容）。dubbo-metadata 模块的实现套路也是有一个 api 子模块进行抽象，然后其他子模块进行具体实现。</li></ul><p><img data-src="8.png" alt="8"></p><ul><li>dubbo-configcenter 模块： Dubbo 的动态配置模块，主要负责外部化配置以及服务治理规则的存储与通知，提供了多个子模块用来接入多种开源的服务发现组件。</li></ul><p><img data-src="9.png" alt="9"></p><h2 id="Dubbo-源码中的-Demo-示例"><a href="#Dubbo-源码中的-Demo-示例" class="headerlink" title="Dubbo 源码中的 Demo 示例"></a>Dubbo 源码中的 Demo 示例</h2><p>在 Dubbo 源码中我们可以看到一个 dubbo-demo 模块，共包括三个非常基础 的 Dubbo 示例项目，分别是： 使用 XML 配置的 Demo 示例、使用注解配置的 Demo 示例 以及 直接使用 API 的 Demo 示例 。下面我们将从这三个示例的角度，简单介绍 Dubbo 的基本使用。同时，这三个项目也将作为后续 Debug Dubbo 源码的入口，我们会根据需要在其之上进行修改 。不过在这儿之前，你需要先启动 ZooKeeper 作为注册中心，然后编写一个业务接口作为 Provider 和 Consumer 的公约。</p><h2 id="启动-ZooKeeper"><a href="#启动-ZooKeeper" class="headerlink" title="启动 ZooKeeper"></a>启动 ZooKeeper</h2><p>在前面 Dubbo 的架构图中，可以看到 Provider 的地址以及配置信息是通过注册中心传递给 Consumer 的。 Dubbo 支持的注册中心尽管有很多， 但在生产环境中， 基本都是用 ZooKeeper 作为注册中心 。因此，在调试 Dubbo 源码时，自然需要在本地启动 ZooKeeper。</p><p>首先，下载 zookeeper-3.4.14.tar.gz 包（下载地址： <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.14/）。下载完成之后执行如下命令解压缩：" target="_blank" rel="noopener">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.14/）。下载完成之后执行如下命令解压缩：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf zookeeper-3.4.14.tar.gz</span><br></pre></td></tr></table></figure><p>解压完成之后，进入 zookeeper-3.4.14 目录，复制 conf/zoo_sample.cfg 文件并重命名为 conf/zoo.cfg，之后执行如下命令就可以启动 ZooKeeper了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;.&#x2F;bin&#x2F;zkServer.sh start </span><br><span class="line"># 下面为输出内容 </span><br><span class="line">ZooKeeper JMX enabled by default </span><br><span class="line">Using config: &#x2F;Users&#x2F;xxx&#x2F;zookeeper-3.4.14&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfg # 配置文件 </span><br><span class="line">Starting zookeeper ... STARTED # 启动成功</span><br></pre></td></tr></table></figure><h2 id="业务接口"><a href="#业务接口" class="headerlink" title="业务接口"></a>业务接口</h2><p>在使用 Dubbo 之前，还需要一个业务接口，这个业务接口可以认为是 Dubbo Provider 和 Dubbo Consumer 的公约，反映出很多信息：</p><p>Provider ，如何提供服务、提供的服务名称是什么、需要接收什么参数、需要返回什么响应；</p><p>Consumer ，如何使用服务、使用的服务名称是什么、需要传入什么参数、会得到什么响应。</p><p>dubbo-demo-interface 模块就是定义业务接口的地方，如下图所示：</p><p><img data-src="10.png" alt="10"></p><p>其中，DemoService 接口中定义了两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123; </span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>; <span class="comment">// 同步调用 </span></span><br><span class="line">    <span class="comment">// 异步调用 </span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> CompletableFuture&lt;String&gt; <span class="title">sayHelloAsync</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(sayHello(name)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Demo-1：基于-XML-配置"><a href="#Demo-1：基于-XML-配置" class="headerlink" title="Demo 1：基于 XML 配置"></a>Demo 1：基于 XML 配置</h2><p>在 dubbo-demo 模块下的 dubbo-demo-xml 模块，提供了基于 Spring XML 的 Provider 和 Consumer。</p><p>先来看 dubbo-demo-xml-provider 模块，其结构如下图所示：</p><p><img data-src="11.png" alt="11"></p><p>在其 pom.xml 中除了一堆 dubbo 的依赖之外，还有依赖了 DemoService 这个公共接口：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-demo-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>DemoServiceImpl 实现了 DemoService 接口，sayHello() 方法直接返回一个字符串，sayHelloAsync() 方法返回一个 CompletableFuture 对象。</p><p>在 dubbo-provider.xml 配置文件中，会将 DemoServiceImpl 配置成一个 Spring Bean，并作为 DemoService 服务暴露出去：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置为 Spring Bean --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"org.apache.dubbo.demo.provider.DemoServiceImpl"</span>/&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 作为 Dubbo 服务暴露出去 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>还有就是指定注册中心地址（就是前面 ZooKeeper 的地址），这样 Dubbo 才能把暴露的 DemoService 服务注册到 ZooKeeper 中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Zookeeper 地址 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>最后，在 Application 中写个 main() 方法，指定 Spring 配置文件并启动 ClassPathXmlApplicationContext 即可。</p><p>接下来再看 dubbo-demo-xml-consumer 模块，结构如下图所示：</p><p><img data-src="12.png" alt="12"></p><p>在 pom.xml 中同样依赖了 dubbo-demo-interface 这个公共模块。</p><p>在 dubbo-consumer.xml 配置文件中，会指定注册中心地址（就是前面 ZooKeeper 的地址），这样 Dubbo 才能从 ZooKeeper 中拉取到 Provider 暴露的服务列表信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Zookeeper地址 --&gt; </span><br><span class="line">&lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;127.0.0.1:2181&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>还会使用 dubbo:reference 引入 DemoService 服务，后面可以作为 Spring Bean 使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入DemoService服务，并配置成Spring Bean--&gt; </span><br><span class="line">&lt;dubbo:reference id&#x3D;&quot;demoService&quot; check&#x3D;&quot;false&quot;  </span><br><span class="line">                 interface&#x3D;&quot;org.apache.dubbo.demo.DemoService&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>最后，在 Application 中写个 main() 方法，指定 Spring 配置文件并启动 ClassPathXmlApplicationContext 之后，就可以远程调用 Provider 端的 DemoService 的 sayHello() 方法了。</p><h2 id="Demo-2：基于注解配置"><a href="#Demo-2：基于注解配置" class="headerlink" title="Demo 2：基于注解配置"></a>Demo 2：基于注解配置</h2><p>dubbo-demo-annotation 模块是基于 Spring 注解配置的示例，无非就是将 XML 的那些配置信息转移到了注解上。</p><p>我们先来看 dubbo-demo-annotation-provider 这个示例模块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    <span class="comment">// 使用AnnotationConfigApplicationContext初始化Spring容器， </span></span><br><span class="line">        <span class="comment">// 从ProviderConfiguration这个类的注解上拿相关配置信息 </span></span><br><span class="line">        AnnotationConfigApplicationContext context =  </span><br><span class="line">              <span class="keyword">new</span> AnnotationConfigApplicationContext( </span><br><span class="line">                  ProviderConfiguration<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">        context.start(); </span><br><span class="line">        System.in.read(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Configuration</span> <span class="comment">// 配置类 </span></span><br><span class="line">    <span class="comment">// @EnableDubbo注解指定包下的Bean都会被扫描，并做Dubbo服务暴露出去 </span></span><br><span class="line">    <span class="meta">@EnableDubbo</span>(scanBasePackages = <span class="string">"org.apache.dubbo.demo.provider"</span>)      </span><br><span class="line">    <span class="comment">// @PropertySource注解指定了其他配置信息 </span></span><br><span class="line">    <span class="meta">@PropertySource</span>(<span class="string">"classpath:/spring/dubbo-provider.properties"</span>)      </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>&#123; </span><br><span class="line">        <span class="meta">@Bean</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig(); </span><br><span class="line">            registryConfig.setAddress(<span class="string">"zookeeper://127.0.0.1:2181"</span>); </span><br><span class="line">            <span class="keyword">return</span> registryConfig; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，同样会有一个 DemoServiceImpl 实现了 DemoService 接口，并且在 org.apache.dubbo.demo.provider 目录下，能被扫描到，暴露成 Dubbo 服务。</p><p>接着再来看 dubbo-demo-annotation-consumer 模块，其中 Application 中也是通过 AnnotationConfigApplicationContext 初始化 Spring 容器，也会扫描指定目录下的 Bean，会扫到 DemoServiceComponent 这个 Bean，其中就通过 @Reference 注解注入 Dubbo 服务相关的 Bean：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;demoServiceComponent&quot;) </span><br><span class="line">public class DemoServiceComponent implements DemoService &#123; </span><br><span class="line">    @Reference &#x2F;&#x2F; 注入Dubbo服务 </span><br><span class="line">    private DemoService demoService; </span><br><span class="line">    @Override </span><br><span class="line">    public String sayHello(String name) &#123; </span><br><span class="line">        return demoService.sayHello(name); </span><br><span class="line">    &#125; </span><br><span class="line">  &#x2F;&#x2F; 其他方法 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Demo-3：基于-API-配置"><a href="#Demo-3：基于-API-配置" class="headerlink" title="Demo 3：基于 API 配置"></a>Demo 3：基于 API 配置</h2><p>在有的场景中，不能依赖于 Spring 框架，只能使用 API 来构建 Dubbo Provider 和 Consumer，比较典型的一种场景就是在写 SDK 的时候。</p><p>先来看 dubbo-demo-api-provider 模块，其中 Application.main() 方法是入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个ServiceConfig的实例，泛型参数是业务接口实现类， </span></span><br><span class="line"><span class="comment">// 即DemoServiceImpl </span></span><br><span class="line">ServiceConfig&lt;DemoServiceImpl&gt; service = <span class="keyword">new</span> ServiceConfig&lt;&gt;(); </span><br><span class="line"><span class="comment">// 指定业务接口 </span></span><br><span class="line">service.setInterface(DemoService<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line"><span class="comment">// 指定业务接口的实现，由该对象来处理Consumer的请求 </span></span><br><span class="line">service.setRef(<span class="keyword">new</span> DemoServiceImpl()); </span><br><span class="line"><span class="comment">// 获取DubboBootstrap实例，这是个单例的对象 </span></span><br><span class="line">DubboBootstrap bootstrap = DubboBootstrap.getInstance(); </span><br><span class="line"><span class="comment">//生成一个 ApplicationConfig 的实例、指定ZK地址以及ServiceConfig实例 </span></span><br><span class="line">bootstrap.application(<span class="keyword">new</span> ApplicationConfig(<span class="string">"dubbo-demo-api-provider"</span>)) </span><br><span class="line">        .registry(<span class="keyword">new</span> RegistryConfig(<span class="string">"zookeeper://127.0.0.1:2181"</span>)) </span><br><span class="line">        .service(service) </span><br><span class="line">        .start() </span><br><span class="line">        .await();</span><br></pre></td></tr></table></figure><p>这里，同样会有一个 DemoServiceImpl 实现了 DemoService 接口，并且在 org.apache.dubbo.demo.provider 目录下，能被扫描到，暴露成 Dubbo 服务。</p><p>再来看 dubbo-demo-api-consumer 模块，其中 Application 中包含一个普通的 main() 方法入口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; 创建ReferenceConfig,其中指定了引用的接口DemoService </span><br><span class="line"> ReferenceConfig&lt;DemoService&gt; reference &#x3D; new ReferenceConfig&lt;&gt;(); </span><br><span class="line"> reference.setInterface(DemoService.class); </span><br><span class="line"> reference.setGeneric(&quot;true&quot;); </span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; 创建DubboBootstrap，指定ApplicationConfig以及RegistryConfig </span><br><span class="line"> DubboBootstrap bootstrap &#x3D; DubboBootstrap.getInstance(); </span><br><span class="line"> bootstrap.application(new ApplicationConfig(&quot;dubbo-demo-api-consumer&quot;)) </span><br><span class="line">         .registry(new RegistryConfig(&quot;zookeeper:&#x2F;&#x2F;127.0.0.1:2181&quot;)) </span><br><span class="line">         .reference(reference) </span><br><span class="line">         .start(); </span><br><span class="line"> &#x2F;&#x2F; 获取DemoService实例并调用其方法 </span><br><span class="line"> DemoService demoService &#x3D; ReferenceConfigCache.getCache() </span><br><span class="line">.get(reference); </span><br><span class="line"> String message &#x3D; demoService.sayHello(&quot;dubbo&quot;); </span><br><span class="line"> System.out.println(message);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，首先介绍了 Dubbo 的核心架构以及各核心组件的功能，接下来又搭建了 Dubbo 源码环境，并详细介绍了 Dubbo 核心模块的功能，为后续分析 Dubbo 源码打下了基础。最后还深入分析了 Dubbo 源码中自带的三个 Demo 示例，现在就可以以这三个 Demo 示例为入口 Debug Dubbo 源码了。</p>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo, 分布式, 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper之数据模型：节点的特性与应用</title>
      <link href="/2020/07/21/ZooKeeper%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%EF%BC%9A%E8%8A%82%E7%82%B9%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2020/07/21/ZooKeeper%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%EF%BC%9A%E8%8A%82%E7%82%B9%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="数据模型：节点的特性与应用"><a href="#数据模型：节点的特性与应用" class="headerlink" title="数据模型：节点的特性与应用"></a>数据模型：节点的特性与应用</h1><p>ZooKeeper 作为一个分布式协调服务，给出了在分布式环境下一致性问题的工业解决方案，目前流行的很多开源框架技术背后都有 ZooKeeper 的身影。那么 ZooKeeper 是如何做到这一点的，在平时开发中我们应该如何使用 ZooKeeper？要想了解这些问题，我们先要对 ZooKeeper 的基础知识进行全面的掌握。</p><a id="more"></a><p>ZooKeeper 基础知识基本分为三大模块：</p><ul><li>数据模型</li><li>ACL 权限控制</li><li>Watch 监控</li></ul><p>其中，数据模型是最重要的，很多 ZooKeeper 中典型的应用场景都是利用这些基础模块实现的。比如我们可以利用数据模型中的临时节点和 Watch 监控机制来实现一个发布订阅的功能。</p><p>因此，今天主要通过理论知识结合实际的应用场景来给你介绍数据模型。掌握本课时的知识对于理解 ZooKeeper 内部原理，以及在日常工作中使用好 ZooKeeper 非常重要。</p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>计算机最根本的作用其实就是处理和存储数据，作为一款分布式一致性框架，ZooKeeper 也是如此。数据模型就是 ZooKeeper 用来存储和处理数据的一种逻辑结构。就像我们用 MySQL 数据库一样，要想处理复杂业务。前提是先学会如何往里边新增数据。ZooKeeper 数据模型最根本的功能就像一个数据库。</p><p>现在，数据模型对我们来说还是一个比较抽象的概念，接下来我们开始部署一个开发测试环境，并在上面做一些简单的操作。来看看 ZooKeeper 的数据模型究竟是什么样的：</p><p>1、配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tickTime&#x3D;2000</span><br><span class="line">dataDir&#x3D;&#x2F;var&#x2F;lib&#x2F;zookeeper</span><br><span class="line">clientPort&#x3D;2181</span><br></pre></td></tr></table></figure><p>2、服务启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;zkServer.sh start</span><br></pre></td></tr></table></figure><p>3、使用客户端连接服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></table></figure><p>4、这样单机版的开发环境就已经构建完成了，接下来我们通过 ZooKeeper 提供的 create 命令来创建几个节点，分别是：<code>“/locks”“/servers”“/works”</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create &#x2F;locks</span><br><span class="line">create &#x2F;servers</span><br><span class="line">create &#x2F;works</span><br></pre></td></tr></table></figure><p>最终在 ZooKeeper 服务器上会得到一个具有层级关系的数据结构，如下图所示，这个数据结构就是 ZooKeeper 中的数据模型。</p><p><img data-src="Ciqc1F6yL9OAUUguAAAtBwGI74E989.png" alt="img"></p><p>ZooKeeper 中的数据模型是一种树形结构，非常像电脑中的文件系统，有一个根文件夹，下面还有很多子文件夹。ZooKeeper 的数据模型也具有一个固定的根节点（/），我们可以在根节点下创建子节点，并在子节点下继续创建下一级节点。ZooKeeper 树中的每一层级用斜杠（/）分隔开，且只能用绝对路径（如“get /work/task1”）的方式查询 ZooKeeper 节点，而不能使用相对路径。具体的结构你可以看看下面这张图：</p><p><img data-src="CgqCHl6yL9uAbpHYAABF_GHyGNc950.png" alt="img"></p><h2 id="znode-节点类型与特性"><a href="#znode-节点类型与特性" class="headerlink" title="znode 节点类型与特性"></a>znode 节点类型与特性</h2><p>知道了 ZooKeeper 的数据模型是一种树形结构，就像在 MySQL 中数据是存在于数据表中，ZooKeeper 中的数据是由多个数据节点最终构成的一个层级的树状结构，和我们在创建 MySOL 数据表时会定义不同类型的数据列字段，ZooKeeper 中的数据节点也分为持久节点、临时节点和有序节点三种类型：</p><h3 id="持久节点"><a href="#持久节点" class="headerlink" title="持久节点"></a>持久节点</h3><p>我们第一个介绍的是持久节点，这种节点也是在 ZooKeeper 最为常用的，几乎所有业务场景中都会包含持久节点的创建。之所以叫作持久节点是因为一旦将节点创建为持久节点，该数据节点会一直存储在 ZooKeeper 服务器上，即使创建该节点的客户端与服务端的会话关闭了，该节点依然不会被删除。如果我们想删除持久节点，就要显式调用 delete 函数进行删除操作。</p><h3 id="临时节点"><a href="#临时节点" class="headerlink" title="临时节点"></a>临时节点</h3><p>接下来我们来介绍临时节点。从名称上我们可以看出该节点的一个最重要的特性就是临时性。所谓临时性是指，如果将节点创建为临时节点，那么该节点数据不会一直存储在 ZooKeeper 服务器上。当创建该临时节点的客户端会话因超时或发生异常而关闭时，该节点也相应在 ZooKeeper 服务器上被删除。同样，我们可以像删除持久节点一样主动删除临时节点。</p><p>在平时的开发中，我们可以利用临时节点的这一特性来做服务器集群内机器运行情况的统计，将集群设置为“/servers”节点，并为集群下的每台服务器创建一个临时节点“/servers/host”，当服务器下线时该节点自动被删除，最后统计临时节点个数就可以知道集群中的运行情况。如下图所示：</p><p><img data-src="CgqCHl6yL-SAb0zaAABQBLohKvo019.png" alt="img"></p><h3 id="有序节点"><a href="#有序节点" class="headerlink" title="有序节点"></a>有序节点</h3><p>最后我们再说一下有序节点，其实有序节点并不算是一种单独种类的节点，而是在之前提到的持久节点和临时节点特性的基础上，增加了一个节点有序的性质。所谓节点有序是说在我们创建有序节点的时候，ZooKeeper 服务器会自动使用一个单调递增的数字作为后缀，追加到我们创建节点的后边。例如一个客户端创建了一个路径为 works/task- 的有序节点，那么 ZooKeeper 将会生成一个序号并追加到该节点的路径后，最后该节点的路径为 works/task-1。通过这种方式我们可以直观的查看到节点的创建顺序。</p><p>到目前为止我们知道在 ZooKeeper 服务器上存储数据的基本信息，知道了 ZooKeeper 中的数据节点种类有持久节点和临时节点等。上述这几种数据节点虽然类型不同，但 ZooKeeper 中的每个节点都维护有这些内容：一个二进制数组（byte data[]），用来存储节点的数据、ACL 访问控制信息、子节点数据（因为临时节点不允许有子节点，所以其子节点字段为 null），除此之外每个数据节点还有一个记录自身状态信息的字段 stat。</p><p>下面我们详细说明节点的状态信息。</p><h2 id="节点的状态结构"><a href="#节点的状态结构" class="headerlink" title="节点的状态结构"></a>节点的状态结构</h2><p>每个节点都有属于自己的状态信息，这就很像我们每个人的身份信息一样，我们打开之前的客户端，执行 stat /zk_test，可以看到控制台输出了一些信息，这些就是节点状态信息。</p><p><img data-src="Ciqc1F6yL-yAKn9QAABsJSpQkFI688.png" alt="img"></p><p>每一个节点都有一个自己的状态属性，记录了节点本身的一些信息，这些属性包括的内容我列在了下面这个表格里：</p><p><img data-src="Ciqc1F6zbwWAVkt5AAC_yMQVCFo712.png" alt="img"></p><h2 id="数据节点的版本"><a href="#数据节点的版本" class="headerlink" title="数据节点的版本"></a>数据节点的版本</h2><p>这里我们重点讲解一下版本相关的属性，在 ZooKeeper 中为数据节点引入了版本的概念，每个数据节点有 3 种类型的版本信息，对数据节点的任何更新操作都会引起版本号的变化。ZooKeeper 的版本信息表示的是对节点数据内容、子节点信息或者是 ACL 信息的修改次数。</p><h3 id="使用-ZooKeeper-实现锁"><a href="#使用-ZooKeeper-实现锁" class="headerlink" title="使用 ZooKeeper 实现锁"></a>使用 ZooKeeper 实现锁</h3><p>学习了 ZooKeeper 的数据模型和数据节点的相关知识，下面我们通过实际的应用进一步加深理解。</p><p>设想这样一个情景：一个购物网站，某个商品库存只剩一件，客户 A 搜索到这件商品并准备下单，但在这期间客户 B 也查询到了该件商品并提交了购买，于此同时，客户 A 也下单购买了此商品，这样就出现了只有一件库存的商品实际上卖出了两件的情况。为了解决这个问题，我们可以在客户 A 对商品进行操作的时候对这件商品进行锁定从而避免这种超卖的情况发生。</p><p>实现锁的方式有很多中，这里我们主要介绍两种：悲观锁、乐观锁。</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁认为进程对临界区的竞争总是会出现，为了保证进程在操作数据时，该条数据不被其他进程修改。数据会一直处于被锁定的状态。</p><p>我们假设一个具有 n 个进程的应用，同时访问临界区资源，我们通过进程创建 ZooKeeper 节点 /locks 的方式获取锁。</p><p>线程 a 通过成功创建 ZooKeeper 节点“/locks”的方式获取锁后继续执行，如下图所示：</p><p><img data-src="CgqCHl6yL_WAAnymAAB32xbrhxQ973.png" alt="img"></p><p>这时进程 b 也要访问临界区资源，于是进程 b 也尝试创建“/locks”节点来获取锁，因为之前进程 a 已经创建该节点，所以进程 b 创建节点失败无法获得锁。</p><p><img data-src="CgqCHl6yL_6AOIONAAB3daUjikw147.png" alt="img"></p><p>这样就实现了一个简单的悲观锁，不过这也有一个隐含的问题，就是当进程 a 因为异常中断导致 /locks 节点始终存在，其他线程因为无法再次创建节点而无法获取锁，这就产生了一个死锁问题。针对这种情况我们可以通过将节点设置为临时节点的方式避免。并通过在服务器端添加监听事件来通知其他进程重新获取锁。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁认为，进程对临界区资源的竞争不会总是出现，所以相对悲观锁而言。加锁方式没有那么激烈，不会全程的锁定资源，而是在数据进行提交更新的时候，对数据的冲突与否进行检测，如果发现冲突了，则拒绝操作。</p><p><strong>乐观锁基本可以分为读取、校验、写入三个步骤。</strong>CAS（Compare-And-Swap），即比较并替换，就是一个乐观锁的实现。CAS 有 3 个操作数，内存值 V，旧的预期值 A，要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。</p><p>在 ZooKeeper 中的 version 属性就是用来实现乐观锁机制中的“校验”的，ZooKeeper 每个节点都有数据版本的概念，在调用更新操作的时候，假如有一个客户端试图进行更新操作，它会携带上次获取到的 version 值进行更新。而如果在这段时间内，ZooKeeper 服务器上该节点的数值恰好已经被其他客户端更新了，那么其数据版本一定也会发生变化，因此肯定与客户端携带的 version 无法匹配，便无法成功更新，因此可以有效地避免一些分布式更新的并发问题。</p><p>在 ZooKeeper 的底层实现中，当服务端处理 setDataRequest 请求时，首先会调用 checkAndIncVersion 方法进行数据版本校验。ZooKeeper 会从 setDataRequest 请求中获取当前请求的版本 version，同时通过 getRecordForPath 方法获取服务器数据记录 nodeRecord， 从中得到当前服务器上的版本信息 currentversion。如果 version 为 -1，表示该请求操作不使用乐观锁，可以忽略版本对比；如果 version 不是 -1，那么就对比 version 和 currentversion，如果相等，则进行更新操作，否则就会抛出 BadVersionException 异常中断操作。</p><p><img data-src="CgqCHl6yMBKAZzwGAABPrrtajyI575.png" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了ZooKeeper的基础知识点——数据模型。并深入介绍了节点类型、stat 状态属性等知识，并利用目前学到的知识解决了集群中服务器运行情况统计、悲观锁、乐观锁等问题。这些知识对接下来的课程至关重要，请务必掌握。</p><p>了解了 ZooKeeper 数据模型的基本原理后，我们来思考一个问题：为什么 ZooKeeper 不能采用相对路径查找节点呢？</p><p>这是因为 ZooKeeper 大多是应用场景是定位数据模型上的节点，并在相关节点上进行操作。像这种查找与给定值相等的记录问题最适合用散列来解决。因此 ZooKeeper 在底层实现的时候，使用了一个 hashtable，即 hashtableConcurrentHashMap&lt;String, DataNode&gt; nodes ，用节点的完整路径来作为 key 存储节点数据。这样就大大提高了 ZooKeeper 的性能。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth2.0介绍及实现思路</title>
      <link href="/2020/07/20/OAuth2-0%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/"/>
      <url>/2020/07/20/OAuth2-0%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="OAuth简介"><a href="#OAuth简介" class="headerlink" title="OAuth简介"></a>OAuth简介</h1><p>OAuth是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。OAuth2.0是目前最流行的授权机制，用来授权第三方应用，获取用户数据。本文主要参考材料为<a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noopener">RFC 6749</a>。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。</p><a id="more"></a><p><img data-src="bg2014051202.png" alt="img"></p><p>但是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？</p><p>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p><p>（1）”云冲印”为了后续的服务，会保存用户的密码，这样很<strong>不安全</strong>。<br>（2）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。<br>（3）”云冲印”拥有了获取用户储存在Google所有资料的权力，用户没法限制”云冲印”获得授权的<strong>范围和有效期</strong>。<br>（4）用户只有<strong>修改密码</strong>，才能收回赋予”云冲印”的权力。但是这样做，<strong>会使得其他所有获得用户授权的第三方应用程序全部失效</strong>。<br>（5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的<strong>数据泄漏</strong>。</p><p>OAuth就是为了解决上面这些问题而诞生的。</p><h2 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h2><p>OAuth 2.0之前，需要了解几个专用名词：</p><p>（1）<strong>Third-party application：</strong>第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印”。<br>（2）<strong>HTTP service：</strong>HTTP服务提供商，本文中简称”服务提供商”，即上一节例子中的Google。<br>（3）<strong>Resource Owner：</strong>资源所有者，本文中又称”用户”（user）。<br>（4）<strong>User Agent：</strong>用户代理，本文中就是指浏览器。<br>（5）<strong>Authorization server：</strong>认证服务器，即服务提供商专门用来处理认证的服务器。<br>（6）<strong>Resource server：</strong>资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p><p>知道了上面这些名词，就会比较容易理解，OAuth的作用就是<strong>让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动</strong>。</p><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>OAuth在”客户端”与”服务提供商”之间，设置了一个<strong>授权层（authorization layer）</strong>。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的<strong>令牌（token）</strong>，与用户的密码不同。用户可以在登录的时候，指定授权层令牌的<strong>权限范围和有效期</strong>。</p><p>“客户端”登录授权层以后，”服务提供商”根据令牌的<strong>权限范围和有效期</strong>，向”客户端”开放用户储存的资料。</p><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p>OAuth 2.0的运行流程如下图，摘自RFC 6749。</p><p><img data-src="bg2014051203.png" alt="img"></p><p>（A）<strong>用户</strong>打开客户端以后，<strong>客户端</strong>要求用户给予授权。<br>（B）<strong>用户</strong>同意给予<strong>客户端</strong>授权。<br>（C）<strong>客户端</strong>使用上一步获得的授权，向<strong>认证服务器</strong>申请令牌。<br>（D）<strong>认证服务器</strong>对<strong>客户端进</strong>行认证以后，确认无误，同意发放<strong>令牌</strong>。<br>（E）<strong>客户端</strong>使用<strong>令牌</strong>，向<strong>资源服务器</strong>申请获取资源。<br>（F）<strong>资源服务器</strong>确认<strong>令牌</strong>无误，同意向<strong>客户端</strong>开放资源。</p><p>上面六个步骤之中，<strong>（B）</strong>是关键，即<strong>用户怎样才能给于客户端授权</strong>。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p><p>客户端获取授权的<strong>四种模式</strong>。</p><h1 id="客户端的四种授权模式"><a href="#客户端的四种授权模式" class="headerlink" title="客户端的四种授权模式"></a>客户端的四种授权模式</h1><p>客户端必须得到用户的<strong>授权（authorization grant）</strong>，才能获得<strong>令牌（access token）</strong>。OAuth 2.0定义了四种授权方式。</p><ul><li><strong>授权码模式（authorization code）</strong></li><li><strong>简化模式（implicit）</strong></li><li><strong>密码模式（resource owner password credentials）</strong></li><li><strong>客户端模式（client credentials）</strong></li></ul><h2 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h2><p><strong>授权码模式（authorization code）</strong>是功能最完整、流程最严密的授权模式。它的特点就是<strong>通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</strong></p><p><img data-src="bg2014051204.png" alt="img"></p><p>它的步骤如下：</p><p>（A）<strong>用户</strong>访问<strong>客户端</strong>，后者将前者导向<strong>认证服务器</strong>。<br>（B）<strong>用户</strong>选择是否给予<strong>客户端</strong>授权。<br>（C）假设用户给予授权，<strong>认证服务器</strong>将用户导向客户端事先指定的<strong>“重定向URI”（redirection URI）</strong>，同时附上一个<strong>授权码</strong>。<br>（D）<strong>客户端</strong>收到<strong>授权码</strong>，附上早先的<strong>“重定向URI”</strong>，向<strong>认证服务器</strong>申请<strong>令牌</strong>。这一步是在客户端的后台的服务器上完成的，对<strong>用户不可见</strong>。<br>（E）<strong>认证服务器</strong>核对了<strong>授权码</strong>和<strong>重定向URI</strong>，确认无误后，向客户端发送访问<strong>令牌（access token）</strong>和<strong>更新令牌（refresh token）</strong>。</p><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端申请认证的URI，包含以下参数：</p><p><strong>response_type：</strong>表示授权类型，必选项，此处的值固定为”code”<br><strong>client_id：</strong>表示客户端的ID，必选项<br><strong>redirect_uri：</strong>表示重定向URI，可选项<br><strong>scope：</strong>表示申请的权限范围，可选项<br><strong>state：</strong>表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。<br>下面是一个例子。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br></pre></td></tr></table></figure><p>C步骤中，服务器回应客户端的URI，包含以下参数：</p><ul><li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Location</span>: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">          &amp;state=xyz</span><br></pre></td></tr></table></figure><p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p><ul><li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li><li>code：表示上一步获得的授权码，必选项。</li><li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li><li>client_id：表示客户端ID，必选项。</li></ul><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure><p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p><ul><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li></ul><p>下面是一个例子。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line">&#123;</span><br><span class="line">    "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">    "token_type":"example",</span><br><span class="line">    "expires_in":3600,</span><br><span class="line">    "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",</span><br><span class="line">    "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。</p><h2 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h2><p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p><p><img data-src="bg2014051205.png" alt="img"></p><p>它的步骤如下：</p><blockquote><p>（A）客户端将用户导向认证服务器。</p><p>（B）用户决定是否给于客户端授权。</p><p>（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。</p><p>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。</p><p>（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。</p><p>（F）浏览器执行上一步获得的脚本，提取出令牌。</p><p>（G）浏览器将令牌发给客户端。</p></blockquote><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li>response_type：表示授权类型，此处的值固定为”token”，必选项。</li><li>client_id：表示客户端的ID，必选项。</li><li>redirect_uri：表示重定向的URI，可选项。</li><li>scope：表示权限范围，可选项。</li><li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><p>下面是一个例子。</p><blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">    &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br></pre></td></tr></table></figure></blockquote><p>C步骤中，认证服务器回应客户端的URI，包含以下参数：</p><ul><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><p>下面是一个例子。</p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Location</span>: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA</span><br><span class="line">          &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</span><br></pre></td></tr></table></figure></blockquote><p>在上面的例子中，认证服务器用HTTP头信息的Location栏，指定浏览器重定向的网址。注意，在这个网址的Hash部分包含了令牌。</p><p>根据上面的D步骤，下一步浏览器会访问Location指定的网址，但是Hash部分不会发送。接下来的E步骤，服务提供商的资源服务器发送过来的代码，会提取出Hash中的令牌。</p><h2 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h2><p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。</p><p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p><p><img data-src="bg2014051206.png" alt="img"></p><p>它的步骤如下：</p><blockquote><p>（A）用户向客户端提供用户名和密码。</p><p>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</p><p>（C）认证服务器确认无误后，向客户端提供访问令牌。</p></blockquote><p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li>grant_type：表示授权类型，此处的值固定为”password”，必选项。</li><li>username：表示用户名，必选项。</li><li>password：表示用户的密码，必选项。</li><li>scope：表示权限范围，可选项。</li></ul><p>下面是一个例子。</p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</span><br></pre></td></tr></table></figure></blockquote><p>C步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">  "token_type":"example",</span><br><span class="line">  "expires_in":3600,</span><br><span class="line">  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",</span><br><span class="line">  "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，各个参数的含义参见《授权码模式》一节。</p><p>整个过程中，客户端不得保存用户的密码。</p><h2 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h2><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p><p><img data-src="bg2014051207.png" alt="img"></p><p>它的步骤如下：</p><blockquote><p>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。</p><p>（B）认证服务器确认无误后，向客户端提供访问令牌。</p></blockquote><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li>grant<em>type：表示授权类型，此处的值固定为”client</em>credentials”，必选项。</li><li>scope：表示权限范围，可选项。</li></ul><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=client_credentials</span><br></pre></td></tr></table></figure></blockquote><p>认证服务器必须以某种方式，验证客户端身份。</p><p>B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">  "token_type":"example",</span><br><span class="line">  "expires_in":3600,</span><br><span class="line">  "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，各个参数的含义参见《授权码模式》一节。</p><h2 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h2><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</p><p>客户端发出更新令牌的HTTP请求，包含以下参数：</p><ul><li>grant<em>type：表示使用的授权模式，此处的值固定为”refresh</em>token”，必选项。</li><li>refresh_token：表示早前收到的更新令牌，必选项。</li><li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li></ul><p>下面是一个例子。</p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> OAuth2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth2 Java EE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloudAlibaba之Seata处理分布式事务</title>
      <link href="/2020/06/30/SpringCloudAlibaba%E4%B9%8BSeata%E5%A4%84%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/06/30/SpringCloudAlibaba%E4%B9%8BSeata%E5%A4%84%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloudAlibaba之Seata处理分布式事务"><a href="#SpringCloudAlibaba之Seata处理分布式事务" class="headerlink" title="SpringCloudAlibaba之Seata处理分布式事务"></a>SpringCloudAlibaba之Seata处理分布式事务</h1><p>基于分布式的事务管理</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>分布式之前，单机单库没有这个问题，从 1:1 -&gt; 1:N -&gt; N:N</p><a id="more"></a><p><img data-src="image-20200417081113603.png" alt="image"></p><p>跨数据库，多数据源的统一调度，就会遇到分布式事务问题</p><p>如下图，单体应用被拆分成微服务应用，原来的三个模板被拆分成三个独立的应用，分别使用三个独立的数据源，业务操作需要调用三个服务来完成。此时每个服务内部的数据一致性由本地事务来保证，但是全局的数据一致性问题没法保证。</p><p><img data-src="image-20200417081239933.png" alt="image"></p><h2 id="Seata简介"><a href="#Seata简介" class="headerlink" title="Seata简介"></a>Seata简介</h2><p>官方文档：<a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html" target="_blank" rel="noopener">点我传送</a></p><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><p>分布式事务处理过程的一致性ID + 三组件模型</p><ul><li>Transaction ID XID：全局唯一的事务ID</li><li>三组件的概念<ul><li>Transaction  Coordinator（TC）：事务协调器，维护全局事务，驱动全局事务提交或者回滚</li><li>Transaction Manager（TM）：事务管理器，控制全局事务的范围，开始全局事务提交或回滚全局事务</li><li>Resource Manager（RM）：资源管理器，控制分支事务，负责分支注册分支事务和报告</li></ul></li></ul><h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h3><p><img data-src="image-20200417121037783.png" alt="image"></p><ul><li>TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID</li><li>XID在微服务调用链路的上下文中传播</li><li>RM向TC注册分支事务，将其纳入XID对应全局事务的管辖</li><li>TM向TC发起针对XID的全局提交或回滚决议</li><li>TM调度XID下管辖的全部分支事务完成提交或回滚请求</li></ul><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>地址：<a href="https://github.com/seata/seata/releases" target="_blank" rel="noopener">https://github.com/seata/seata/releases</a></p><p>下载 1.1版本完成后，修改conf目录下的file.conf配置文件</p><h4 id="修改file-conf"><a href="#修改file-conf" class="headerlink" title="修改file.conf"></a>修改file.conf</h4><p>首先我们需要备份原始的file.conf文件</p><p>主要修改，自定义事务组名称 + 事务日志存储模式为db + 数据库连接信息，也就是修改存储的数据库</p><h4 id="修改service模块"><a href="#修改service模块" class="headerlink" title="修改service模块"></a>修改service模块</h4><p>修改服务模块中的分组</p><p><img data-src="image-20200417133537054.png" alt="image"></p><h4 id="修改store模块"><a href="#修改store模块" class="headerlink" title="修改store模块"></a>修改store模块</h4><p>修改存储模块</p><p><img data-src="image-20200417134353031.png" alt="image"></p><p><img data-src="image-20200417133715606.png" alt="image"></p><h4 id="创建一个seata数据库"><a href="#创建一个seata数据库" class="headerlink" title="创建一个seata数据库"></a>创建一个seata数据库</h4><p>在seata数据库中建表，建表语句在 seata/conf目录下的 db_store.sql</p><h4 id="修改seata-server的registry-conf配置文件"><a href="#修改seata-server的registry-conf配置文件" class="headerlink" title="修改seata-server的registry.conf配置文件"></a>修改seata-server的registry.conf配置文件</h4><p><img data-src="image-20200417134800315.png" alt="image"></p><p>目的是：指明注册中心为nacos，及修改nacos连接信息</p><p>然后启动nacos 和 seata-server</p><h3 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h3><ul><li>本地：@Transaction </li><li>全局：@GlobalTransaction</li></ul><p>Spring自带的是 @Transaction 控制本地事务</p><p>而 @GlobalTransaction控制的是全局事务</p><p><img data-src="image-20200417133041311.png" alt="image"></p><p>我们只需要在需要支持分布式事务的业务类上，使用该注解即可</p><h2 id="订单-库存-账户业务微服务准备"><a href="#订单-库存-账户业务微服务准备" class="headerlink" title="订单/库存/账户业务微服务准备"></a>订单/库存/账户业务微服务准备</h2><p>在这之前首先需要先启动Nacos，然后启动Seata，保证两个都OK</p><h3 id="分布式事务的业务说明"><a href="#分布式事务的业务说明" class="headerlink" title="分布式事务的业务说明"></a>分布式事务的业务说明</h3><p>这里我们会创建三个微服务，一个订单服务，一个库存服务，一个账户服务。</p><p>当用户下单时，会在订单服务中创建一个订单，然后通过远程调用库存服务来扣减下单商品的库存，在通过远程调用账户服务来扣减用户账户里面的金额，最后在订单服务修改订单状态为已完成</p><p>该操作跨越了三个数据库，有两次远程调用，很明显会有分布式事务的问题。</p><p>一句话：下订单 -&gt; 扣库存 -&gt; 减余额</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ul><li>seata_order：存储订单的数据库</li><li>seata_storage：存储库存的数据库</li><li>seata_account：存储账户信息的数据库</li></ul><p>建库SQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create database seata_order;</span><br><span class="line">create database seata_storage;</span><br><span class="line">create database seata_account;</span><br></pre></td></tr></table></figure><h3 id="建立业务表"><a href="#建立业务表" class="headerlink" title="建立业务表"></a>建立业务表</h3><ul><li>seata_order库下建立t_order表</li><li>seata_storage库下建t_storage表</li><li>seata_account库下建t_account表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS &#96;t_order&#96;;</span><br><span class="line">CREATE TABLE &#96;t_order&#96;  (</span><br><span class="line">  &#96;int&#96; bigint(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;user_id&#96; bigint(20) DEFAULT NULL COMMENT &#39;用户id&#39;,</span><br><span class="line">  &#96;product_id&#96; bigint(11) DEFAULT NULL COMMENT &#39;产品id&#39;,</span><br><span class="line">  &#96;count&#96; int(11) DEFAULT NULL COMMENT &#39;数量&#39;,</span><br><span class="line">  &#96;money&#96; decimal(11, 0) DEFAULT NULL COMMENT &#39;金额&#39;,</span><br><span class="line">  &#96;status&#96; int(1) DEFAULT NULL COMMENT &#39;订单状态:  0:创建中 1:已完结&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;int&#96;) USING BTREE</span><br><span class="line">) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci COMMENT &#x3D; &#39;订单表&#39; ROW_FORMAT &#x3D; Dynamic;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS &#96;t_storage&#96;;</span><br><span class="line">CREATE TABLE &#96;t_storage&#96;  (</span><br><span class="line">  &#96;int&#96; bigint(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;product_id&#96; bigint(11) DEFAULT NULL COMMENT &#39;产品id&#39;,</span><br><span class="line">  &#96;total&#96; int(11) DEFAULT NULL COMMENT &#39;总库存&#39;,</span><br><span class="line">  &#96;used&#96; int(11) DEFAULT NULL COMMENT &#39;已用库存&#39;,</span><br><span class="line">  &#96;residue&#96; int(11) DEFAULT NULL COMMENT &#39;剩余库存&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;int&#96;) USING BTREE</span><br><span class="line">) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci COMMENT &#x3D; &#39;库存&#39; ROW_FORMAT &#x3D; Dynamic;</span><br><span class="line">INSERT INTO &#96;t_storage&#96; VALUES (1, 1, 100, 0, 100);</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;t_account&#96;  (</span><br><span class="line">  &#96;id&#96; bigint(11) NOT NULL COMMENT &#39;id&#39;,</span><br><span class="line">  &#96;user_id&#96; bigint(11) DEFAULT NULL COMMENT &#39;用户id&#39;,</span><br><span class="line">  &#96;total&#96; decimal(10, 0) DEFAULT NULL COMMENT &#39;总额度&#39;,</span><br><span class="line">  &#96;used&#96; decimal(10, 0) DEFAULT NULL COMMENT &#39;已用余额&#39;,</span><br><span class="line">  &#96;residue&#96; decimal(10, 0) DEFAULT NULL COMMENT &#39;剩余可用额度&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;) USING BTREE</span><br><span class="line">) ENGINE &#x3D; InnoDB CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci COMMENT &#x3D; &#39;账户表&#39; ROW_FORMAT &#x3D; Dynamic;</span><br><span class="line"> </span><br><span class="line">INSERT INTO &#96;t_account&#96; VALUES (1, 1, 1000, 0, 1000);</span><br></pre></td></tr></table></figure><h3 id="创建回滚日志表"><a href="#创建回滚日志表" class="headerlink" title="创建回滚日志表"></a>创建回滚日志表</h3><p>订单 - 库存 - 账户 3个库都需要建各自的回滚日志表，目录在 db_undo_log.sql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- the table to store seata xid data</span><br><span class="line">-- 0.7.0+ add context</span><br><span class="line">-- you must to init this sql for you business databese. the seata server not need it.</span><br><span class="line">-- 此脚本必须初始化在你当前的业务数据库中，用于AT 模式XID记录。与server端无关（注：业务数据库）</span><br><span class="line">-- 注意此处0.3.0+ 增加唯一索引 ux_undo_log</span><br><span class="line">DROP TABLE &#96;undo_log&#96;;</span><br><span class="line">CREATE TABLE &#96;undo_log&#96; (</span><br><span class="line">  &#96;id&#96; BIGINT(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;branch_id&#96; BIGINT(20) NOT NULL,</span><br><span class="line">  &#96;xid&#96; VARCHAR(100) NOT NULL,</span><br><span class="line">  &#96;context&#96; VARCHAR(128) NOT NULL,</span><br><span class="line">  &#96;rollback_info&#96; LONGBLOB NOT NULL,</span><br><span class="line">  &#96;log_status&#96; INT(11) NOT NULL,</span><br><span class="line">  &#96;log_created&#96; DATETIME NOT NULL,</span><br><span class="line">  &#96;log_modified&#96; DATETIME NOT NULL,</span><br><span class="line">  &#96;ext&#96; VARCHAR(100) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;ux_undo_log&#96; (&#96;xid&#96;,&#96;branch_id&#96;)</span><br><span class="line">) ENGINE&#x3D;INNODB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><h2 id="订单-库存-账户业务微服务准备-1"><a href="#订单-库存-账户业务微服务准备-1" class="headerlink" title="订单/库存/账户业务微服务准备"></a>订单/库存/账户业务微服务准备</h2><h3 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h3><p>下订单 -&gt; 减库存 -&gt; 扣余额 -&gt; 改（订单）状态</p><h3 id="新建Order-Module表"><a href="#新建Order-Module表" class="headerlink" title="新建Order-Module表"></a>新建Order-Module表</h3><h4 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h4><p>entity，domain：相当于实体类层</p><p>vo：view object，value object</p><p>dto：前台传到后台的数据传输类</p><h4 id="新建module2001"><a href="#新建module2001" class="headerlink" title="新建module2001"></a>新建module2001</h4><h4 id="引入POM"><a href="#引入POM" class="headerlink" title="引入POM"></a>引入POM</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--seata--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;exclusions&gt;</span><br><span class="line">              &lt;exclusion&gt;</span><br><span class="line">                  &lt;artifactId&gt;seata-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">                  &lt;groupId&gt;io.seata&lt;&#x2F;groupId&gt;</span><br><span class="line">              &lt;&#x2F;exclusion&gt;</span><br><span class="line">          &lt;&#x2F;exclusions&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;io.seata&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;seata-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;version&gt;0.9.0&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="修改yml"><a href="#修改yml" class="headerlink" title="修改yml"></a>修改yml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 2001</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: seata-order-service</span><br><span class="line">  cloud:</span><br><span class="line">    alibaba:</span><br><span class="line">      seata:</span><br><span class="line">        #自定义事务组名称需要与seata-server中的对应</span><br><span class="line">        tx-service-group: fsp_tx_group</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;seata_order</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line"></span><br><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: false</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    io:</span><br><span class="line">      seata: info</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapperLocations: classpath:mapper&#x2F;*.xml</span><br></pre></td></tr></table></figure><h4 id="增加file-conf"><a href="#增加file-conf" class="headerlink" title="增加file.conf"></a>增加file.conf</h4><p>在resources目录下，创建file.conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">transport &#123;</span><br><span class="line">  # tcp udt unix-domain-socket</span><br><span class="line">  type &#x3D; &quot;TCP&quot;</span><br><span class="line">  #NIO NATIVE</span><br><span class="line">  server &#x3D; &quot;NIO&quot;</span><br><span class="line">  #enable heartbeat</span><br><span class="line">  heartbeat &#x3D; true</span><br><span class="line">  #thread factory for netty</span><br><span class="line">  thread-factory &#123;</span><br><span class="line">    boss-thread-prefix &#x3D; &quot;NettyBoss&quot;</span><br><span class="line">    worker-thread-prefix &#x3D; &quot;NettyServerNIOWorker&quot;</span><br><span class="line">    server-executor-thread-prefix &#x3D; &quot;NettyServerBizHandler&quot;</span><br><span class="line">    share-boss-worker &#x3D; false</span><br><span class="line">    client-selector-thread-prefix &#x3D; &quot;NettyClientSelector&quot;</span><br><span class="line">    client-selector-thread-size &#x3D; 1</span><br><span class="line">    client-worker-thread-prefix &#x3D; &quot;NettyClientWorkerThread&quot;</span><br><span class="line">    # netty boss thread size,will not be used for UDT</span><br><span class="line">    boss-thread-size &#x3D; 1</span><br><span class="line">    #auto default pin or 8</span><br><span class="line">    worker-thread-size &#x3D; 8</span><br><span class="line">  &#125;</span><br><span class="line">  shutdown &#123;</span><br><span class="line">    # when destroy server, wait seconds</span><br><span class="line">    wait &#x3D; 3</span><br><span class="line">  &#125;</span><br><span class="line">  serialization &#x3D; &quot;seata&quot;</span><br><span class="line">  compressor &#x3D; &quot;none&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service &#123;</span><br><span class="line"></span><br><span class="line">  vgroup_mapping.fsp_tx_group &#x3D; &quot;default&quot; #修改自定义事务组名称</span><br><span class="line"></span><br><span class="line">  default.grouplist &#x3D; &quot;127.0.0.1:8091&quot;</span><br><span class="line">  enableDegrade &#x3D; false</span><br><span class="line">  disable &#x3D; false</span><br><span class="line">  max.commit.retry.timeout &#x3D; &quot;-1&quot;</span><br><span class="line">  max.rollback.retry.timeout &#x3D; &quot;-1&quot;</span><br><span class="line">  disableGlobalTransaction &#x3D; false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client &#123;</span><br><span class="line">  async.commit.buffer.limit &#x3D; 10000</span><br><span class="line">  lock &#123;</span><br><span class="line">    retry.internal &#x3D; 10</span><br><span class="line">    retry.times &#x3D; 30</span><br><span class="line">  &#125;</span><br><span class="line">  report.retry.count &#x3D; 5</span><br><span class="line">  tm.commit.retry.count &#x3D; 1</span><br><span class="line">  tm.rollback.retry.count &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## transaction log store</span><br><span class="line">store &#123;</span><br><span class="line">  ## store mode: file、db</span><br><span class="line">  mode &#x3D; &quot;db&quot;</span><br><span class="line"></span><br><span class="line">  ## file store</span><br><span class="line">  file &#123;</span><br><span class="line">    dir &#x3D; &quot;sessionStore&quot;</span><br><span class="line"></span><br><span class="line">    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span><br><span class="line">    max-branch-session-size &#x3D; 16384</span><br><span class="line">    # globe session size , if exceeded throws exceptions</span><br><span class="line">    max-global-session-size &#x3D; 512</span><br><span class="line">    # file buffer size , if exceeded allocate new buffer</span><br><span class="line">    file-write-buffer-cache-size &#x3D; 16384</span><br><span class="line">    # when recover batch read size</span><br><span class="line">    session.reload.read_size &#x3D; 100</span><br><span class="line">    # async, sync</span><br><span class="line">    flush-disk-mode &#x3D; async</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ## database store</span><br><span class="line">  db &#123;</span><br><span class="line">    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)&#x2F;BasicDataSource(dbcp) etc.</span><br><span class="line">    datasource &#x3D; &quot;dbcp&quot;</span><br><span class="line">    ## mysql&#x2F;oracle&#x2F;h2&#x2F;oceanbase etc.</span><br><span class="line">    db-type &#x3D; &quot;mysql&quot;</span><br><span class="line">    driver-class-name &#x3D; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">    url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;seata&quot;</span><br><span class="line">    user &#x3D; &quot;root&quot;</span><br><span class="line">    password &#x3D; &quot;123456&quot;</span><br><span class="line">    min-conn &#x3D; 1</span><br><span class="line">    max-conn &#x3D; 3</span><br><span class="line">    global.table &#x3D; &quot;global_table&quot;</span><br><span class="line">    branch.table &#x3D; &quot;branch_table&quot;</span><br><span class="line">    lock-table &#x3D; &quot;lock_table&quot;</span><br><span class="line">    query-limit &#x3D; 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">lock &#123;</span><br><span class="line">  ## the lock store mode: local、remote</span><br><span class="line">  mode &#x3D; &quot;remote&quot;</span><br><span class="line"></span><br><span class="line">  local &#123;</span><br><span class="line">    ## store locks in user&#39;s database</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remote &#123;</span><br><span class="line">    ## store locks in the seata&#39;s server</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">recovery &#123;</span><br><span class="line">  #schedule committing retry period in milliseconds</span><br><span class="line">  committing-retry-period &#x3D; 1000</span><br><span class="line">  #schedule asyn committing retry period in milliseconds</span><br><span class="line">  asyn-committing-retry-period &#x3D; 1000</span><br><span class="line">  #schedule rollbacking retry period in milliseconds</span><br><span class="line">  rollbacking-retry-period &#x3D; 1000</span><br><span class="line">  #schedule timeout retry period in milliseconds</span><br><span class="line">  timeout-retry-period &#x3D; 1000</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transaction &#123;</span><br><span class="line">  undo.data.validation &#x3D; true</span><br><span class="line">  undo.log.serialization &#x3D; &quot;jackson&quot;</span><br><span class="line">  undo.log.save.days &#x3D; 7</span><br><span class="line">  #schedule delete expired undo_log in milliseconds</span><br><span class="line">  undo.log.delete.period &#x3D; 86400000</span><br><span class="line">  undo.log.table &#x3D; &quot;undo_log&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## metrics settings</span><br><span class="line">metrics &#123;</span><br><span class="line">  enabled &#x3D; false</span><br><span class="line">  registry-type &#x3D; &quot;compact&quot;</span><br><span class="line">  # multi exporters use comma divided</span><br><span class="line">  exporter-list &#x3D; &quot;prometheus&quot;</span><br><span class="line">  exporter-prometheus-port &#x3D; 9898</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">support &#123;</span><br><span class="line">  ## spring</span><br><span class="line">  spring &#123;</span><br><span class="line">    # auto proxy the DataSource bean</span><br><span class="line">    datasource.autoproxy &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="registry-conf-注册器"><a href="#registry-conf-注册器" class="headerlink" title="registry.conf 注册器"></a>registry.conf 注册器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  type &#x3D; &quot;nacos&quot;</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;localhost:8848&quot;</span><br><span class="line">    namespace &#x3D; &quot;&quot;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl &#x3D; &quot;http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&quot;</span><br><span class="line">    application &#x3D; &quot;default&quot;</span><br><span class="line">    weight &#x3D; &quot;1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  redis &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;localhost:6379&quot;</span><br><span class="line">    db &#x3D; &quot;0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:2181&quot;</span><br><span class="line">    session.timeout &#x3D; 6000</span><br><span class="line">    connect.timeout &#x3D; 2000</span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:8500&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">    serverAddr &#x3D; &quot;http:&#x2F;&#x2F;localhost:2379&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  sofa &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:9603&quot;</span><br><span class="line">    application &#x3D; &quot;default&quot;</span><br><span class="line">    region &#x3D; &quot;DEFAULT_ZONE&quot;</span><br><span class="line">    datacenter &#x3D; &quot;DefaultDataCenter&quot;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">    group &#x3D; &quot;SEATA_GROUP&quot;</span><br><span class="line">    addressWaitTime &#x3D; &quot;3000&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name &#x3D; &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config &#123;</span><br><span class="line">  # file、nacos 、apollo、zk、consul、etcd3</span><br><span class="line">  type &#x3D; &quot;file&quot;</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;localhost&quot;</span><br><span class="line">    namespace &#x3D; &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:8500&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  apollo &#123;</span><br><span class="line">    app.id &#x3D; &quot;seata-server&quot;</span><br><span class="line">    apollo.meta &#x3D; &quot;http:&#x2F;&#x2F;192.168.1.204:8801&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:2181&quot;</span><br><span class="line">    session.timeout &#x3D; 6000</span><br><span class="line">    connect.timeout &#x3D; 2000</span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;http:&#x2F;&#x2F;localhost:2379&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name &#x3D; &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class CommonResult&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private Integer code;</span><br><span class="line">    private String  message;</span><br><span class="line">    private T       data;</span><br><span class="line"></span><br><span class="line">    public CommonResult(Integer code, String message)</span><br><span class="line">    &#123;</span><br><span class="line">        this(code,message,null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class Order</span><br><span class="line">&#123;</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private Long userId;</span><br><span class="line"></span><br><span class="line">    private Long productId;</span><br><span class="line"></span><br><span class="line">    private Integer count;</span><br><span class="line"></span><br><span class="line">    private BigDecimal money;</span><br><span class="line"></span><br><span class="line">    private Integer status; &#x2F;&#x2F;订单状态：0：创建中；1：已完结</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dao接口及实现"><a href="#Dao接口及实现" class="headerlink" title="Dao接口及实现"></a>Dao接口及实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface OrderDao</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;1 新建订单</span><br><span class="line">    void create(Order order);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2 修改订单状态，从零改为1</span><br><span class="line">    void update(@Param(&quot;userId&quot;) Long userId,@Param(&quot;status&quot;) Integer status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.atguigu.springcloud.alibaba.dao.OrderDao&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id&#x3D;&quot;BaseResultMap&quot; type&#x3D;&quot;com.atguigu.springcloud.alibaba.domain.Order&quot;&gt;</span><br><span class="line">        &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot; jdbcType&#x3D;&quot;BIGINT&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;user_id&quot; property&#x3D;&quot;userId&quot; jdbcType&#x3D;&quot;BIGINT&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;product_id&quot; property&#x3D;&quot;productId&quot; jdbcType&#x3D;&quot;BIGINT&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;count&quot; property&#x3D;&quot;count&quot; jdbcType&#x3D;&quot;INTEGER&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;money&quot; property&#x3D;&quot;money&quot; jdbcType&#x3D;&quot;DECIMAL&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;status&quot; property&#x3D;&quot;status&quot; jdbcType&#x3D;&quot;INTEGER&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id&#x3D;&quot;create&quot;&gt;</span><br><span class="line">        insert into t_order (id,user_id,product_id,count,money,status)</span><br><span class="line">        values (null,#&#123;userId&#125;,#&#123;productId&#125;,#&#123;count&#125;,#&#123;money&#125;,0);</span><br><span class="line">    &lt;&#x2F;insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id&#x3D;&quot;update&quot;&gt;</span><br><span class="line">        update t_order set status &#x3D; 1</span><br><span class="line">        where user_id&#x3D;#&#123;userId&#125; and status &#x3D; #&#123;status&#125;;</span><br><span class="line">    &lt;&#x2F;update&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure><h4 id="Service实现类"><a href="#Service实现类" class="headerlink" title="Service实现类"></a>Service实现类</h4><p>OrderService接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface OrderService</span><br><span class="line">&#123;</span><br><span class="line">    void create(Order order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StorageService的Feign接口，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value &#x3D; &quot;seata-storage-service&quot;)</span><br><span class="line">public interface StorageService</span><br><span class="line">&#123;</span><br><span class="line">    @PostMapping(value &#x3D; &quot;&#x2F;storage&#x2F;decrease&quot;)</span><br><span class="line">    CommonResult decrease(@RequestParam(&quot;productId&quot;) Long productId, @RequestParam(&quot;count&quot;) Integer count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AccountService的Feign接口，账户接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value &#x3D; &quot;seata-account-service&quot;)</span><br><span class="line">public interface AccountService</span><br><span class="line">&#123;</span><br><span class="line">    @PostMapping(value &#x3D; &quot;&#x2F;account&#x2F;decrease&quot;)</span><br><span class="line">    CommonResult decrease(@RequestParam(&quot;userId&quot;) Long userId, @RequestParam(&quot;money&quot;) BigDecimal money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderServiceImpl实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl implements OrderService</span><br><span class="line">&#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private OrderDao orderDao;</span><br><span class="line">    @Resource</span><br><span class="line">    private StorageService storageService;</span><br><span class="line">    @Resource</span><br><span class="line">    private AccountService accountService;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态</span><br><span class="line">     * 简单说：下订单-&gt;扣库存-&gt;减余额-&gt;改状态</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    @GlobalTransactional(name &#x3D; &quot;fsp-create-order&quot;,rollbackFor &#x3D; Exception.class)</span><br><span class="line">    public void create(Order order)</span><br><span class="line">    &#123;</span><br><span class="line">        log.info(&quot;-----&gt;开始新建订单&quot;);</span><br><span class="line">        &#x2F;&#x2F;1 新建订单</span><br><span class="line">        orderDao.create(order);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2 扣减库存</span><br><span class="line">        log.info(&quot;-----&gt;订单微服务开始调用库存，做扣减Count&quot;);</span><br><span class="line">        storageService.decrease(order.getProductId(),order.getCount());</span><br><span class="line">        log.info(&quot;-----&gt;订单微服务开始调用库存，做扣减end&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;3 扣减账户</span><br><span class="line">        log.info(&quot;-----&gt;订单微服务开始调用账户，做扣减Money&quot;);</span><br><span class="line">        accountService.decrease(order.getUserId(),order.getMoney());</span><br><span class="line">        log.info(&quot;-----&gt;订单微服务开始调用账户，做扣减end&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;4 修改订单状态，从零到1,1代表已经完成</span><br><span class="line">        log.info(&quot;-----&gt;修改订单状态开始&quot;);</span><br><span class="line">        orderDao.update(order.getUserId(),0);</span><br><span class="line">        log.info(&quot;-----&gt;修改订单状态结束&quot;);</span><br><span class="line"></span><br><span class="line">        log.info(&quot;-----&gt;下订单结束了，O(∩_∩)O哈哈~&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class OrderController</span><br><span class="line">&#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;order&#x2F;create&quot;)</span><br><span class="line">    public CommonResult create(Order order)</span><br><span class="line">    &#123;</span><br><span class="line">        orderService.create(order);</span><br><span class="line">        return new CommonResult(200,&quot;订单创建成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Config配置"><a href="#Config配置" class="headerlink" title="Config配置"></a>Config配置</h4><p>Mybatis DataSourceProxyConfig配置，这里是使用Seata对数据源进行代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DataSourceProxyConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)</span><br><span class="line">    private String mapperLocations;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource&quot;)</span><br><span class="line">    public DataSource druidDataSource()&#123;</span><br><span class="line">        return new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSourceProxy dataSourceProxy(DataSource dataSource) &#123;</span><br><span class="line">        return new DataSourceProxy(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSourceProxy);</span><br><span class="line">        sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations));</span><br><span class="line">        sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory());</span><br><span class="line">        return sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mybatis配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(&#123;&quot;com.atguigu.springcloud.alibaba.dao&quot;&#125;)</span><br><span class="line">public class MyBatisConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableFeignClients</span><br><span class="line">@SpringBootApplication(exclude &#x3D; DataSourceAutoConfiguration.class)&#x2F;&#x2F;取消数据源的自动创建</span><br><span class="line">public class SeataOrderMainApp2001</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(SeataOrderMainApp2001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新建Storage-Module"><a href="#新建Storage-Module" class="headerlink" title="新建Storage-Module"></a>新建Storage-Module</h3><p>参考项目：seata-storage-service2002</p><h3 id="新建账户Account-Module"><a href="#新建账户Account-Module" class="headerlink" title="新建账户Account-Module"></a>新建账户Account-Module</h3><p>参考项目：seata-account-service2003</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="数据库初始情况"><a href="#数据库初始情况" class="headerlink" title="数据库初始情况"></a>数据库初始情况</h4><p><img data-src="image-20200417225230939.png" alt="image"></p><h4 id="正常下单"><a href="#正常下单" class="headerlink" title="正常下单"></a>正常下单</h4><p>访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:2001&#x2F;order&#x2F;create?userId&#x3D;1&amp;productId&#x3D;1&amp;count&#x3D;10&amp;money&#x3D;100</span><br></pre></td></tr></table></figure><p><img data-src="image-20200417225932063.png" alt="image"></p><h4 id="超时异常，没加-GlobalTransaction"><a href="#超时异常，没加-GlobalTransaction" class="headerlink" title="超时异常，没加@GlobalTransaction"></a>超时异常，没加@GlobalTransaction</h4><p>我们在account-module模块，添加睡眠时间20秒，因为openFeign默认时间是1秒</p><p><img data-src="image-20200417230124982.png" alt="image"></p><p>出现了数据不一致的问题</p><p>故障情况</p><ul><li>当库存和账户金额扣减后，订单状态并没有设置成已经完成，没有从零改成1</li><li>而且由于Feign的重试机制，账户余额还有可能被多次扣除</li></ul><h4 id="超时异常，添加-GlobalTransaction"><a href="#超时异常，添加-GlobalTransaction" class="headerlink" title="超时异常，添加@GlobalTransaction"></a>超时异常，添加@GlobalTransaction</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@GlobalTransactional(name &#x3D; &quot;fsp-create-order&quot;,rollbackFor &#x3D; Exception.class)</span><br></pre></td></tr></table></figure><p>rollbackFor表示，什么什么错误就会回滚</p><p>添加这个后，发现下单后的数据库并没有改变，记录都添加不进来</p><h2 id="一部分补充"><a href="#一部分补充" class="headerlink" title="一部分补充"></a>一部分补充</h2><h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><p>2019年1月份，蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案</p><p>Seata：Simple Extensible Autonomous Transaction Architecture，简单可扩展自治事务框架</p><p>2020起始，参加工作以后用1.0以后的版本。</p><h3 id="再看TC-TM-RM三大组件"><a href="#再看TC-TM-RM三大组件" class="headerlink" title="再看TC/TM/RM三大组件"></a>再看TC/TM/RM三大组件</h3><p><img data-src="image-20200417231145550.png" alt="image"></p><p>什么是TC，TM，RM</p><p>TC：seata服务器</p><p>TM：带有@GlobalTransaction注解的方法</p><p>RM：数据库，也就是事务参与方</p><p><img data-src="image-20200417231314748.png" alt="image"></p><h3 id="分布式事务的执行流程"><a href="#分布式事务的执行流程" class="headerlink" title="分布式事务的执行流程"></a>分布式事务的执行流程</h3><ul><li>TM开启分布式事务（TM向TC注册全局事务记录），相当于注解 <code>@GlobelTransaction</code>注解</li><li>按业务场景，编排数据库，服务等事务内部资源（RM向TC汇报资源准备状态）</li><li>TM结束分布式事务，事务一阶段结束（TM通知TC提交、回滚分布式事务）</li><li>TC汇总事务信息，决定分布式事务是提交还是回滚</li><li>TC通知所有RM提交、回滚资源，事务二阶段结束</li></ul><h3 id="AT模式如何做到对业务的无侵入"><a href="#AT模式如何做到对业务的无侵入" class="headerlink" title="AT模式如何做到对业务的无侵入"></a>AT模式如何做到对业务的无侵入</h3><p>默认AT模式，阿里云GTS</p><h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><ul><li>基于支持本地ACID事务的关系型数据库</li><li>Java应用，通过JDBC访问数据库</li></ul><h4 id="整体机制"><a href="#整体机制" class="headerlink" title="整体机制"></a>整体机制</h4><p>两阶段提交协议的演变</p><ul><li>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源</li><li>二阶段<ul><li>提交异步化，非常快速的完成</li><li>回滚通过一阶段的回滚日志进行反向补偿</li></ul></li></ul><h4 id="一阶段加载"><a href="#一阶段加载" class="headerlink" title="一阶段加载"></a>一阶段加载</h4><p>在一阶段，Seata会拦截 业务SQL</p><ul><li>解析SQL语义，找到业务SQL，要更新的业务数据，在业务数据被更新前，将其保存成 <code>before image（前置镜像）</code></li><li>执行业务SQL更新业务数据，在业务数据更新之后</li><li>将其保存成 after image，最后生成行锁</li></ul><p>以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性</p><p><img data-src="image-20200417232316157.png" alt="image"></p><h4 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h4><p>二阶段如果顺利提交的话，因为业务SQL在一阶段已经提交至数据库，所以Seata框架只需将一阶段保存的快照和行锁删除掉，完成数据清理即可</p><p><img data-src="image-20200417232502282.png" alt="image"></p><h4 id="二阶段回滚"><a href="#二阶段回滚" class="headerlink" title="二阶段回滚"></a>二阶段回滚</h4><p>二阶段如果回滚的话，Seata就需要回滚到一阶段已经执行的 业务SQL，还原业务数据</p><p>回滚方式便是用 before image 还原业务数据，但是在还原前要首先校验脏写，对比数据库当前业务数据 和after image，如果两份数据完全一致，没有脏写，可以还原业务数据，如果不一致说明有脏读，出现脏读就需要转人工处理</p><p><img data-src="image-20200417232859708.png" alt="image"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img data-src="image-20200417233926182.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloudAlibaba </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> SpringCloudAlibaba </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloudAlibaba之Sentinel实现熔断和限流</title>
      <link href="/2020/06/28/SpringCloudAlibaba%E4%B9%8BSentinel%E5%AE%9E%E7%8E%B0%E7%86%94%E6%96%AD%E5%92%8C%E9%99%90%E6%B5%81/"/>
      <url>/2020/06/28/SpringCloudAlibaba%E4%B9%8BSentinel%E5%AE%9E%E7%8E%B0%E7%86%94%E6%96%AD%E5%92%8C%E9%99%90%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloudAlibabaSentinel实现熔断和限流"><a href="#SpringCloudAlibabaSentinel实现熔断和限流" class="headerlink" title="SpringCloudAlibabaSentinel实现熔断和限流"></a>SpringCloudAlibabaSentinel实现熔断和限流</h1><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p>Github：<a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel</a></p><p>Sentinel：分布式系统的流量防卫兵，相当于Hystrix</p><a id="more"></a><p>Hystrix存在的问题</p><ul><li>需要我们程序员自己手工搭建监控平台</li><li>没有一套web界面可以给我们进行更加细粒度化的配置，流量控制，速率控制，服务熔断，服务降级。。</li></ul><p>这个时候Sentinel运营而生</p><ul><li>单独一个组件，可以独立出来</li><li>直接界面化的细粒度统一配置</li></ul><p>约定 &gt; 配置 &gt;编码，都可以写在代码里，但是尽量使用注解和配置代替编码</p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><p>Sentinel 具有以下特征:</p><ul><li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li><li><strong>完善的 SPI 扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><h3 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h3><p><img data-src="image-20200416073841558.png" alt="image"></p><h3 id="生态圈"><a href="#生态圈" class="headerlink" title="生态圈"></a>生态圈</h3><p><img data-src="image-20200416073905426.png" alt="image"></p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>Github：<a href="https://github.com/alibaba/Sentinel/releases" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/releases</a></p><p><img data-src="image-20200416074923500.png" alt="image"></p><h2 id="安装Sentinel控制台"><a href="#安装Sentinel控制台" class="headerlink" title="安装Sentinel控制台"></a>安装Sentinel控制台</h2><p>sentinel组件由两部分组成，后台和前台8080</p><p>Sentinel分为两部分</p><ul><li>核心库（Java客户端）不依赖任何框架/库，能够运行在所有Java运行时环境，同时对Dubbo、SpringCloud等框架也有较好的支持。</li><li>控制台（Dashboard）基于SpringBoot开发，打包后可以直接运行，不需要额外的Tomcat等应用容器</li></ul><p>使用 <code>java -jar</code> 启动，同时Sentinel默认的端口号是8080，因此不能被占用</p><p>注意，下载时候，由于Github经常抽风，因此可以使用Gitee进行下，首先先去Gitee下载源码</p><p><img data-src="image-20200416080109354.png" alt="image"></p><p>然后执行<code>mvn package</code> 进行构建，本博客同级目录下了，已经有个已经下载好的，欢迎自取</p><h2 id="初始化演示工程"><a href="#初始化演示工程" class="headerlink" title="初始化演示工程"></a>初始化演示工程</h2><p>启动Nacos8848成功</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-datasource-nacos&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--SpringCloud ailibaba sentinel --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="修改YML"><a href="#修改YML" class="headerlink" title="修改YML"></a>修改YML</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8401</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloudalibaba-sentinel-service</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848 #Nacos服务注册中心地址</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: localhost:8080 #配置Sentinel dashboard地址</span><br><span class="line">        port: 8719</span><br></pre></td></tr></table></figure><h3 id="增加业务类"><a href="#增加业务类" class="headerlink" title="增加业务类"></a>增加业务类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class FlowLimitController</span><br><span class="line">&#123;</span><br><span class="line">    @GetMapping(&quot;&#x2F;testA&quot;)</span><br><span class="line">    public String testA()</span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;------testA&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;testB&quot;)</span><br><span class="line">    public String testB()</span><br><span class="line">    &#123;</span><br><span class="line">        log.info(Thread.currentThread().getName()+&quot;\t&quot;+&quot;...testB&quot;);</span><br><span class="line">        return &quot;------testB&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动8401微服务，查看Sentinel控制台</p><p>我们会发现Sentinel里面空空如也，什么也没有，这是因为Sentinel采用的懒加载</p><p>执行一下访问即可：<code>http://localhost:8401/testA</code> <code>http://localhost:8401/testB</code></p><p><img data-src="image-20200416083940979.png" alt="image"></p><h2 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><img data-src="image-20200416084144709.png" alt="image"></p><p><strong>字段说明</strong></p><ul><li>资源名：唯一名称，默认请求路径</li><li>针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）</li><li>阈值类型 / 单机阈值<ul><li>QPS：（每秒钟的请求数量）：但调用该API的QPS达到阈值的时候，进行限流</li><li>线程数：当调用该API的线程数达到阈值的时候，进行限流</li></ul></li><li>是否集群：不需要集群</li><li>流控模式<ul><li>直接：api都达到限流条件时，直接限流</li><li>关联：当关联的资源达到阈值，就限流自己</li><li>链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流）【API级别的针对来源】</li></ul></li><li>流控效果<ul><li>快速失败：直接失败，抛异常</li><li>Warm UP：根据codeFactory（冷加载因子，默认3），从阈值/CodeFactor，经过预热时长，才达到设置的QPS阈值</li><li>排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置QPS，否则无效</li></ul></li></ul><h3 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h3><h4 id="直接（默认）"><a href="#直接（默认）" class="headerlink" title="直接（默认）"></a>直接（默认）</h4><p>我们给testA增加流控</p><p><img data-src="image-20200416084934271.png" alt="image"></p><p><img data-src="image-20200416085039034.png" alt="image"></p><p><img data-src="image-20200416085226574.png" alt="image"></p><p>然后我们请求 <code>http://localhost:8401/testA</code>，就会出现失败，被限流，快速失败</p><p><img data-src="image-20200416085117306.png" alt="image"></p><p>思考：</p><p>直接调用的是默认报错信息，能否有我们的后续处理，比如更加友好的提示，类似有hystrix的fallback方法</p><p>线程数</p><p>这里的线程数表示一次只有一个线程进行业务请求，当前出现请求无法响应的时候，会直接报错，例如，在方法的内部增加一个睡眠，那么后面来的就会失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;testD&quot;)</span><br><span class="line">public String testD()</span><br><span class="line">&#123;</span><br><span class="line">    try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    return &quot;------testD&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><p>当关联的资源达到阈值时，就限流自己</p><p>当与A关联的资源B达到阈值后，就限流A自己，B惹事，A挂了</p><p>场景：支付接口达到阈值后，就限流下订单的接口</p><p>设置：</p><p>当关联资源 /testB的QPS达到阈值超过1时，就限流/testA的Rest访问地址，当关联资源达到阈值后，限制配置好的资源名</p><p><img data-src="image-20200416090827339.png" alt="image"></p><p>这个使用我们利用postman模拟并发密集访问<code>testB</code></p><p>首先我们需要使用postman，创建一个请求</p><p><img data-src="image-20200416091302584.png" alt="image"></p><p>同时将请求保存在 Collection中</p><p>然后点击箭头，选中接口，选择run</p><p><img data-src="image-20200416091349552.png" alt="image"></p><p><img data-src="image-20200416091517551.png" alt="image"></p><p>点击运行，大批量线程高并发访问B，导致A失效了，同时我们点击访问 <code>http://localhost:8401/testA</code>，结果发现，我们的A已经挂了</p><p><img data-src="image-20200416091801271.png" alt="image"></p><p>在测试A接口</p><p><img data-src="image-20200416091815140.png" alt="image"></p><p>这就是我们的关联限流</p><h4 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h4><p>多个请求调用了同一个微服务</p><h3 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h3><h4 id="直接"><a href="#直接" class="headerlink" title="直接"></a>直接</h4><p>快速失败，默认的流控处理</p><ul><li>直接失败，抛出异常：Blocked by Sentinel（Flow limiting）</li></ul><h4 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h4><p>系统最怕的就是出现，平时访问是0，然后突然一瞬间来了10W的QPS</p><p>公式：阈值 除以 clodFactor（默认值为3），经过预热时长后，才会达到阈值</p><p>Warm Up方式，即预热/冷启动方式，当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能会瞬间把系统压垮。通过冷启动，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值，给冷系统一个预热的时间，避免冷系统被压垮。通常冷启动的过程系统允许的QPS曲线如下图所示</p><p><img data-src="image-20200416093702689.png" alt="image"></p><p>默认clodFactor为3，即请求QPS从threshold / 3开始，经预热时长逐渐提升至设定的QPS阈值</p><p><img data-src="image-20200416093919458.png" alt="image"></p><p>假设这个系统的QPS是10，那么最开始系统能够接受的 QPS  = 10 / 3 = 3，然后从3逐渐在5秒内提升到10</p><p>应用场景：</p><p>秒杀系统在开启的瞬间，会有很多流量上来，很可能把系统打死，预热的方式就是为了保护系统，可能慢慢的把流量放进来，慢慢的把阈值增长到设置的阈值。</p><p><img data-src="image-20200416094419813.png" alt="image"></p><h4 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a>排队等待</h4><p>大家均速排队，让请求以均匀的速度通过，阈值类型必须设置成QPS，否则无效</p><p>均速排队方式必须严格控制请求通过的间隔时间，也即让请求以匀速的速度通过，对应的是漏桶算法。</p><p><img data-src="image-20200416094734543.png" alt="image"></p><p>这种方式主要用于处理间隔性突发的流量，例如消息队列，想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒处于空闲状态，我们系统系统能够接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p><p>设置含义：/testA 每秒1次请求，超过的话，就排队等待，等待时间超过20000毫秒</p><p><img data-src="image-20200416094609143.png" alt="image"></p><h2 id="降级规则"><a href="#降级规则" class="headerlink" title="降级规则"></a>降级规则</h2><h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h3><p><img data-src="image-20200416095515859.png" alt="image"></p><ul><li><p>RT（平均响应时间，秒级）</p><ul><li>平均响应时间，超过阈值 且 时间窗口内通过的请求 &gt;= 5，两个条件同时满足后出发降级</li><li>窗口期过后，关闭断路器</li><li>RT最大4900（更大的需要通过 -Dcsp.sentinel.staticstic.max.rt=XXXXX才能生效）</li></ul></li><li><p>异常比例（秒级）</p><ul><li>QPA &gt;= 5 且异常比例（秒级）超过阈值时，触发降级；时间窗口结束后，关闭降级</li></ul></li><li><p>异常数（分钟级）</p><ul><li>异常数（分钟统计）超过阈值时，触发降级，时间窗口结束后，关闭降级</li></ul></li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Sentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。</p><p>当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都进行自动熔断（默认行为是抛出DegradeException）</p><p>Sentinel的断路器是没有半开状态</p><p>半开的状态，系统自动去检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常则继续打开断路器不可用，具体可以参考hystrix</p><p><img data-src="image-20200416100340083.png" alt="image"></p><h3 id="降级策略实战"><a href="#降级策略实战" class="headerlink" title="降级策略实战"></a>降级策略实战</h3><h4 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h4><p>平均响应时间 (<code>DEGRADE_GRADE_RT</code>)：当 1s 内持续进入 N 个请求，对应时刻的平均响应时间（秒级）均超过阈值（<code>count</code>，以 ms 为单位），那么在接下的时间窗口（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 <code>DegradeException</code>）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，<strong>超出此阈值的都会算作 4900 ms</strong>，若需要变更此上限可以通过启动配置项 <code>-Dcsp.sentinel.statistic.max.rt=xxx</code> 来配置。</p><p><img data-src="image-20200416102754797.png" alt="image"></p><p>代码测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;testD&quot;)</span><br><span class="line">public String testD()</span><br><span class="line">&#123;</span><br><span class="line">    try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    log.info(&quot;testD 异常比例&quot;);</span><br><span class="line">    return &quot;------testD&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用Jmeter压力测试工具进行测试</p><p><img data-src="image-20200416103619799.png" alt="image"></p><p>按照上述操作，永远1秒种打进来10个线程，大于5个了，调用tesetD，我们希望200毫秒内处理完本次任务，如果200毫秒没有处理完，在未来的1秒的时间窗口内，断路器打开（保险丝跳闸）微服务不可用，保险丝跳闸断电</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blocked by Sentinel (flow limiting)</span><br></pre></td></tr></table></figure><p><img data-src="image-20200416103959047.png" alt="image"></p><p>后续我们停止使用jmeter，没有那么大的访问量了，断路器关闭（保险丝恢复），微服务恢复OK</p><h4 id="异常比例"><a href="#异常比例" class="headerlink" title="异常比例"></a>异常比例</h4><p>异常比例 (<code>DEGRADE_GRADE_EXCEPTION_RATIO</code>)：当资源的每秒请求量 &gt;= N（可配置），并且每秒异常总数占通过量的比值超过阈值（<code>DegradeRule</code> 中的 <code>count</code>）之后，资源进入降级状态，即在接下的时间窗口（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</p><p><img data-src="image-20200416104157714.png" alt="image"></p><p>单独访问一次，必然来一次报错一次，开启jmeter后，直接高并发发送请求，多次调用达到我们的配置条件了，断路器开启（保险丝跳闸），微服务不可用，不在报错，而是服务降级了</p><p><img data-src="image-20200416104919798.png" alt="image"></p><p>设置3秒内，如果请求百分50出错，那么就会熔断</p><p><img data-src="image-20200416104908479.png" alt="image"></p><p>我们用jmeter每秒发送10次请求，3秒后，再次调用  <code>localhost:8401/testD</code> 出现服务降级</p><p><img data-src="image-20200416104858019.png" alt="image"></p><h4 id="异常数"><a href="#异常数" class="headerlink" title="异常数"></a>异常数</h4><p>异常数 (<code>DEGRADE_GRADE_EXCEPTION_COUNT</code>)：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 <code>timeWindow</code> 小于 60s，则结束熔断状态后仍可能再进入熔断状态</p><p>时间窗口一定要大于等于60秒</p><p>异常数是按分钟来统计的</p><p><img data-src="image-20200416105132256.png" alt="image"></p><p>下面设置是，一分钟内出现5次，则熔断</p><p><img data-src="image-20200416105535535.png" alt="image"></p><p>首先我们再次访问 <code>http://localhost:8401/testE</code>，第一次访问绝对报错，因为除数不能为0，我们看到error窗口，但是达到5次报错后，进入熔断后的降级</p><h2 id="Sentinel热点规则"><a href="#Sentinel热点规则" class="headerlink" title="Sentinel热点规则"></a>Sentinel热点规则</h2><h3 id="什么是热点数据"><a href="#什么是热点数据" class="headerlink" title="什么是热点数据"></a>什么是热点数据</h3><p><a href="https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81" target="_blank" rel="noopener">Github文档传送门</a></p><p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</p><ul><li>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</li><li>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</li></ul><p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</p><p><img data-src="image-20200416121306501.png" alt="image"></p><p>Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。热点参数限流支持集群模式。</p><h3 id="兜底的方法"><a href="#兜底的方法" class="headerlink" title="兜底的方法"></a>兜底的方法</h3><p>分为系统默认的和客户自定义的，两种，之前的case中，限流出现问题了，都用sentinel系统默认的提示：Blocked By Sentinel，我们能不能自定义，类似于hystrix，某个方法出现问题了，就找到对应的兜底降级方法。</p><p>从 <code>@HystrixCommand</code> 到 <code>@SentinelResource</code></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>@SentinelResource的value，就是我们的资源名，也就是对哪个方法配置热点规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;testHotKey&quot;)</span><br><span class="line">@SentinelResource(value &#x3D; &quot;testHotKey&quot;,blockHandler &#x3D; &quot;deal_testHotKey&quot;)</span><br><span class="line">public String testHotKey(@RequestParam(value &#x3D; &quot;p1&quot;,required &#x3D; false) String p1,</span><br><span class="line">                         @RequestParam(value &#x3D; &quot;p2&quot;,required &#x3D; false) String p2)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;int age &#x3D; 10&#x2F;0;</span><br><span class="line">    return &quot;------testHotKey&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 和上面的参数一样，不错需要加入 BlockException</span><br><span class="line">public String deal_testHotKey (String p1, String p2, BlockException exception)</span><br><span class="line">&#123;</span><br><span class="line">    return &quot;------deal_testHotKey,o(╥﹏╥)o&quot;;  &#x2F;&#x2F;  兜底的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对参数0，设置热点key进行限流</p><p><img data-src="image-20200416122406091.png" alt="image"></p><p>配置完成后</p><p><img data-src="image-20200416122450886.png" alt="image"></p><p>当我们不断的请求时候，也就是以第一个参数为目标，请求接口，我们会发现多次请求后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8401&#x2F;testHotKey?p1&#x3D;a</span><br></pre></td></tr></table></figure><p>就会出现以下的兜底错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">------deal_testHotKey,o(╥﹏╥)o</span><br></pre></td></tr></table></figure><p>这是因为我们针对第一个参数进行了限制，当我们QPS超过1的时候，就会触发兜底的错误</p><p>假设我们请求的接口是：<code>http://localhost:8401/testHotKey?p2=a</code> ，我们会发现他就没有进行限流</p><p><img data-src="image-20200416123605410.png" alt="image"></p><h3 id="参数例外项"><a href="#参数例外项" class="headerlink" title="参数例外项"></a>参数例外项</h3><p>上述案例演示了第一个参数p1，当QPS超过1秒1次点击狗，马上被限流</p><ul><li>普通：超过一秒1个后，达到阈值1后马上被限流</li><li>我们期望p1参数当它达到某个特殊值时，它的限流值和平时不一样</li><li>特例：假设当p1的值等于5时，它的阈值可以达到200</li><li>一句话说：当key为特殊值的时候，不被限制</li></ul><p><img data-src="image-20200416123922325.png" alt="image"></p><p>平时的时候，参数1的QPS是1，超过的时候被限流，但是有特殊值，比如5，那么它的阈值就是200</p><p>我们通过 <code>http://localhost:8401/testHotKey?p1=5</code> 一直刷新，发现不会触发兜底的方法，这就是参数例外项</p><p>热点参数的注意点，参数必须是基本类型或者String</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><code>@SentinelResource</code> 处理的是Sentinel控制台配置的违规情况，有blockHandler方法配置的兜底处理</p><p>RuntimeException，如  int a = 10/0 ; 这个是java运行时抛出的异常，RuntimeException，@RentinelResource不管</p><p>也就是说：<code>@SentinelResource</code> 主管配置出错，运行出错不管。</p><p>如果想要有配置出错，和运行出错的话，那么可以设置 fallback</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;testHotKey&quot;)</span><br><span class="line">@SentinelResource(value &#x3D; &quot;testHotKey&quot;,blockHandler &#x3D; &quot;deal_testHotKey&quot;, fallback &#x3D; &quot;fallBack&quot;)</span><br><span class="line">public String testHotKey(@RequestParam(value &#x3D; &quot;p1&quot;,required &#x3D; false) String p1,</span><br><span class="line">                         @RequestParam(value &#x3D; &quot;p2&quot;,required &#x3D; false) String p2)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;int age &#x3D; 10&#x2F;0;</span><br><span class="line">    return &quot;------testHotKey&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sentinel系统配置"><a href="#Sentinel系统配置" class="headerlink" title="Sentinel系统配置"></a>Sentinel系统配置</h2><p>Sentinel 系统自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><p>系统保护规则是应用整体维度的，而不是资源维度的，并且<strong>仅对入口流量生效</strong>。入口流量指的是进入应用的流量（<code>EntryType.IN</code>），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。</p><p>系统规则支持以下的模式：</p><ul><li><strong>Load 自适应</strong>（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li><li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li><li><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li><li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li><li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li></ul><p><img data-src="image-20200416144836658.png" alt="image"></p><p>这样相当于设置了全局的QPS过滤</p><h2 id="SentinelResource注解"><a href="#SentinelResource注解" class="headerlink" title="@SentinelResource注解"></a>@SentinelResource注解</h2><ul><li>按资源名称限流 + 后续处理</li><li>按URL地址限流 + 后续处理</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>系统默认的，没有体现我们自己的业务要求</li><li>依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观</li><li>每个业务方法都添加一个兜底方法，那代码膨胀加剧</li><li>全局统一的处理方法没有体现</li><li>关闭8401，发现流控规则已经消失，说明这个是没有持久化</li></ul><h3 id="客户自定义限流处理逻辑"><a href="#客户自定义限流处理逻辑" class="headerlink" title="客户自定义限流处理逻辑"></a>客户自定义限流处理逻辑</h3><p>创建CustomerBlockHandler类用于自定义限流处理逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CustomerBlockHandler</span><br><span class="line">&#123;</span><br><span class="line">    public static CommonResult handlerException(BlockException exception)</span><br><span class="line">    &#123;</span><br><span class="line">        return new CommonResult(4444,&quot;按客戶自定义,global handlerException----1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static CommonResult handlerException2(BlockException exception)</span><br><span class="line">    &#123;</span><br><span class="line">        return new CommonResult(4444,&quot;按客戶自定义,global handlerException----2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们在使用的时候，就可以首先指定是哪个类，哪个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;rateLimit&#x2F;customerBlockHandler&quot;)</span><br><span class="line">@SentinelResource(value &#x3D; &quot;customerBlockHandler&quot;,</span><br><span class="line">        blockHandlerClass &#x3D; CustomerBlockHandler.class,</span><br><span class="line">        blockHandler &#x3D; &quot;handlerException2&quot;)</span><br><span class="line">public CommonResult customerBlockHandler()</span><br><span class="line">&#123;</span><br><span class="line">    return new CommonResult(200,&quot;按客戶自定义&quot;,new Payment(2020L,&quot;serial003&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="C:/Users/ylyang/Desktop/juc-jvm-%E5%91%A8%E9%98%B3-201906-201904/LearningNotes/SpringCloud/SpringCloud2020/14_SpringCloudAlibabaSentinel%E5%AE%9E%E7%8E%B0%E7%86%94%E6%96%AD%E5%92%8C%E9%99%90%E6%B5%81/images/image-20200416150947457.png" alt="image-20200416150947457"></p><h3 id="更多注解属性说明"><a href="#更多注解属性说明" class="headerlink" title="更多注解属性说明"></a>更多注解属性说明</h3><p>所有的代码都要用try - catch - finally 进行处理</p><p>sentinel主要有三个核心API</p><ul><li>Sphu定义资源</li><li>Tracer定义统计</li><li>ContextUtil定义了上下文</li></ul><h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><p>sentinel整合Ribbon + openFeign + fallback</p><p>搭建 9003 和 9004 服务提供者</p><h3 id="不设置任何参数"><a href="#不设置任何参数" class="headerlink" title="不设置任何参数"></a>不设置任何参数</h3><p>然后在使用 84作为服务消费者，当我们值使用 <code>@SentinelResource</code>注解时，不添加任何参数，那么如果出错的话，是直接返回一个error页面，对前端用户非常不友好，因此我们需要配置一个兜底的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;consumer&#x2F;fallback&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">@SentinelResource(value &#x3D; &quot;fallback&quot;) &#x2F;&#x2F;没有配置</span><br><span class="line">public CommonResult&lt;Payment&gt; fallback(@PathVariable Long id)</span><br><span class="line">&#123;</span><br><span class="line">    CommonResult&lt;Payment&gt; result &#x3D; restTemplate.getForObject(SERVICE_URL + &quot;&#x2F;paymentSQL&#x2F;&quot;+id,CommonResult.class,id);</span><br><span class="line"></span><br><span class="line">    if (id &#x3D;&#x3D; 4) &#123;</span><br><span class="line">        throw new IllegalArgumentException (&quot;IllegalArgumentException,非法参数异常....&quot;);</span><br><span class="line">    &#125;else if (result.getData() &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException (&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置fallback"><a href="#设置fallback" class="headerlink" title="设置fallback"></a>设置fallback</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;consumer&#x2F;fallback&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">@SentinelResource(value &#x3D; &quot;fallback&quot;,fallback &#x3D; &quot;handlerFallback&quot;) &#x2F;&#x2F;fallback只负责业务异常</span><br><span class="line">public CommonResult&lt;Payment&gt; fallback(@PathVariable Long id)</span><br><span class="line">&#123;</span><br><span class="line">    CommonResult&lt;Payment&gt; result &#x3D; restTemplate.getForObject(SERVICE_URL + &quot;&#x2F;paymentSQL&#x2F;&quot;+id,CommonResult.class,id);</span><br><span class="line"></span><br><span class="line">    if (id &#x3D;&#x3D; 4) &#123;</span><br><span class="line">        throw new IllegalArgumentException (&quot;IllegalArgumentException,非法参数异常....&quot;);</span><br><span class="line">    &#125;else if (result.getData() &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException (&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;本例是fallback</span><br><span class="line">public CommonResult handlerFallback(@PathVariable  Long id,Throwable e) &#123;</span><br><span class="line">    Payment payment &#x3D; new Payment(id,&quot;null&quot;);</span><br><span class="line">    return new CommonResult&lt;&gt;(444,&quot;兜底异常handlerFallback,exception内容  &quot;+e.getMessage(),payment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入fallback后，当我们程序运行出错时，我们会有一个兜底的异常执行，但是服务限流和熔断的异常还是出现默认的</p><h3 id="设置blockHandler"><a href="#设置blockHandler" class="headerlink" title="设置blockHandler"></a>设置blockHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;consumer&#x2F;fallback&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">@SentinelResource(value &#x3D; &quot;fallback&quot;,blockHandler &#x3D; &quot;blockHandler&quot; ,fallback &#x3D; &quot;handlerFallback&quot;) &#x2F;&#x2F;blockHandler只负责sentinel控制台配置违规</span><br><span class="line">public CommonResult&lt;Payment&gt; fallback(@PathVariable Long id)</span><br><span class="line">&#123;</span><br><span class="line">    CommonResult&lt;Payment&gt; result &#x3D; restTemplate.getForObject(SERVICE_URL + &quot;&#x2F;paymentSQL&#x2F;&quot;+id,CommonResult.class,id);</span><br><span class="line"></span><br><span class="line">    if (id &#x3D;&#x3D; 4) &#123;</span><br><span class="line">        throw new IllegalArgumentException (&quot;IllegalArgumentException,非法参数异常....&quot;);</span><br><span class="line">    &#125;else if (result.getData() &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException (&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;本例是blockHandler</span><br><span class="line">public CommonResult blockHandler(@PathVariable  Long id,BlockException blockException) &#123;</span><br><span class="line">    Payment payment &#x3D; new Payment(id,&quot;null&quot;);</span><br><span class="line">    return new CommonResult&lt;&gt;(445,&quot;blockHandler-sentinel限流,无此流水: blockException  &quot;+blockException.getMessage(),payment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="blockHandler和fallback一起配置"><a href="#blockHandler和fallback一起配置" class="headerlink" title="blockHandler和fallback一起配置"></a>blockHandler和fallback一起配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;consumer&#x2F;fallback&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">@SentinelResource(value &#x3D; &quot;fallback&quot;,blockHandler &#x3D; &quot;blockHandler&quot;) &#x2F;&#x2F;blockHandler只负责sentinel控制台配置违规</span><br><span class="line">public CommonResult&lt;Payment&gt; fallback(@PathVariable Long id)</span><br><span class="line">&#123;</span><br><span class="line">    CommonResult&lt;Payment&gt; result &#x3D; restTemplate.getForObject(SERVICE_URL + &quot;&#x2F;paymentSQL&#x2F;&quot;+id,CommonResult.class,id);</span><br><span class="line"></span><br><span class="line">    if (id &#x3D;&#x3D; 4) &#123;</span><br><span class="line">        throw new IllegalArgumentException (&quot;IllegalArgumentException,非法参数异常....&quot;);</span><br><span class="line">    &#125;else if (result.getData() &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException (&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若blockHandler 和 fallback都进行了配置，则被限流降级而抛出 BlockException时，只会进入blockHandler处理逻辑</p><h3 id="异常忽略"><a href="#异常忽略" class="headerlink" title="异常忽略"></a>异常忽略</h3><p><img data-src="image-20200416213834495.png" alt="image"></p><h2 id="Feign系列"><a href="#Feign系列" class="headerlink" title="Feign系列"></a>Feign系列</h2><h4 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud openfeign --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="修改YML-1"><a href="#修改YML-1" class="headerlink" title="修改YML"></a>修改YML</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 84</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-order-consumer</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        #配置Sentinel dashboard地址</span><br><span class="line">        dashboard: localhost:8080</span><br><span class="line">        #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span><br><span class="line">        port: 8719</span><br><span class="line"></span><br><span class="line">#消费者将要去访问的微服务名称(注册成功进nacos的微服务提供者)</span><br><span class="line">service-url:</span><br><span class="line">  nacos-user-service: http:&#x2F;&#x2F;nacos-payment-provider</span><br><span class="line"></span><br><span class="line"># 激活Sentinel对Feign的支持</span><br><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure><h4 id="启动类激活Feign"><a href="#启动类激活Feign" class="headerlink" title="启动类激活Feign"></a>启动类激活Feign</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public class OrderNacosMain84</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(OrderNacosMain84.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引入Feign接口"><a href="#引入Feign接口" class="headerlink" title="引入Feign接口"></a>引入Feign接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value &#x3D; &quot;nacos-payment-provider&quot;,fallback &#x3D; PaymentFallbackService.class)</span><br><span class="line">public interface PaymentService</span><br><span class="line">&#123;</span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;paymentSQL&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult&lt;Payment&gt; paymentSQL(@PathVariable(&quot;id&quot;) Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加入fallback兜底方法实现"><a href="#加入fallback兜底方法实现" class="headerlink" title="加入fallback兜底方法实现"></a>加入fallback兜底方法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class PaymentFallbackService implements PaymentService</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public CommonResult&lt;Payment&gt; paymentSQL(Long id)</span><br><span class="line">    &#123;</span><br><span class="line">        return new CommonResult&lt;&gt;(44444,&quot;服务降级返回,---PaymentFallbackService&quot;,new Payment(id,&quot;errorSerial&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>请求接口：<code>http://localhost:84/consumer/paymentSQL/1</code></p><p>测试84调用9003，此时故意关闭9003微服务提供者，看84消费侧自动降级</p><p>我们发现过了一段时间后，会触发服务降级，返回失败的方法</p><h2 id="熔断框架对比"><a href="#熔断框架对比" class="headerlink" title="熔断框架对比"></a>熔断框架对比</h2><p><img data-src="image-20200416215711875.png" alt="image"></p><h2 id="Sentinel规则持久化"><a href="#Sentinel规则持久化" class="headerlink" title="Sentinel规则持久化"></a>Sentinel规则持久化</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>一旦我们重启应用，sentinel规则将会消失，生产环境需要将规则进行持久化</p><h3 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h3><p>将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上的流控规则持续有效</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>使用nacos持久化保存</p><h4 id="引入依赖-2"><a href="#引入依赖-2" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-datasource-nacos&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="修改yml"><a href="#修改yml" class="headerlink" title="修改yml"></a>修改yml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8401</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloudalibaba-sentinel-service</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848 #Nacos服务注册中心地址</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: localhost:8080 #配置Sentinel dashboard地址</span><br><span class="line">        port: 8719</span><br><span class="line">      datasource:</span><br><span class="line">        ds1:</span><br><span class="line">          nacos:</span><br><span class="line">            server-addr: localhost:8848</span><br><span class="line">            dataId: cloudalibaba-sentinel-service</span><br><span class="line">            groupId: DEFAULT_GROUP</span><br><span class="line">            data-type: json</span><br><span class="line">            rule-type: flow</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#39;*&#39;</span><br><span class="line"></span><br><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: true # 激活Sentinel对Feign的支持</span><br></pre></td></tr></table></figure><h4 id="添加nacos配置"><a href="#添加nacos配置" class="headerlink" title="添加nacos配置"></a>添加nacos配置</h4><p><img data-src="image-20200416222218661.png" alt="image"></p><p>内容解析</p><p><img data-src="image-20200416222317824.png" alt="image"></p><ul><li>resource：资源名称</li><li>limitApp：来源应用</li><li>grade：阈值类型，0表示线程数，1表示QPS</li><li>count：单机阈值</li><li>strategy：流控模式，0表示直接，1表示关联，2表示链路</li><li>controlBehavior：流控效果，0表示快速失败，1表示Warm，2表示排队等待</li><li>clusterMode：是否集群</li></ul><p>这样启动的时候，调用一下接口，我们的限流规则就会重新出现~</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloudAlibaba </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> SpringCloudAlibaba </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloudAlibaba之Nacos</title>
      <link href="/2020/06/24/SpringCloudAlibaba%E4%B9%8BNacos/"/>
      <url>/2020/06/24/SpringCloudAlibaba%E4%B9%8BNacos/</url>
      
        <content type="html"><![CDATA[<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><h2 id="SpringCloud-Alibaba简介"><a href="#SpringCloud-Alibaba简介" class="headerlink" title="SpringCloud Alibaba简介"></a>SpringCloud Alibaba简介</h2><p>SpringCloud Alibaba诞生的主要原因是：因为Spring Cloud Netflix项目进入了维护模式</p><a id="more"></a><h3 id="维护模式"><a href="#维护模式" class="headerlink" title="维护模式"></a>维护模式</h3><p>将模块置为维护模式，意味着SpringCloud团队将不再向模块添加新功能，我们将恢复block级别的bug以及安全问题，我们也会考虑并审查社区的小型pull request</p><p>我们打算继续支持这些模块，知道Greenwich版本被普遍采用至少一年</p><h3 id="意味着"><a href="#意味着" class="headerlink" title="意味着"></a>意味着</h3><p>Spring Cloud Netflix将不再开发新的组件，我们都知道Spring Cloud项目迭代算是比较快，因此出现了很多重大issue都还来不及Fix，就又推出了另一个Release。进入维护模式意思就是以后一段时间Spring Cloud Netflix提供的服务和功能就这么多了，不在开发新的组件和功能了，以后将以维护和Merge分支Pull Request为主，新组件将以其他替代</p><p><img data-src="image-20200414154600906.png" alt="image"></p><p><img data-src="image-20200414155024158.png" alt="image"></p><h3 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h3><p>官网：<a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md" target="_blank" rel="noopener">SpringCloud Alibaba</a></p><p>2018.10.31，Spring Cloud Alibaba正式入驻Spring Cloud官方孵化器，并在Maven仓库发布了第一个</p><p><img data-src="image-20200414155158301.png" alt="image"></p><h3 id="能做啥"><a href="#能做啥" class="headerlink" title="能做啥"></a>能做啥</h3><ul><li>服务限流降级：默认支持servlet，Feign，RestTemplate，Dubbo和RocketMQ限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级Metrics监控</li><li>服务注册与发现：适配Spring Cloud服务注册与发现标准，默认集成了Ribbon的支持</li><li>分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新</li><li>消息驱动能力：基于Spring Cloud Stream （内部用RocketMQ）为微服务应用构建消息驱动能力</li><li>阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务，支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li>分布式任务调度：提供秒级，精准、高可靠、高可用的定时（基于Cron表达式）任务调度服务，同时提供分布式的任务执行模型，如网格任务，网格任务支持海量子任务均匀分配到所有Worker</li></ul><h3 id="引入依赖版本控制"><a href="#引入依赖版本控制" class="headerlink" title="引入依赖版本控制"></a>引入依赖版本控制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure><h3 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h3><ul><li>Sentinel：阿里巴巴开源产品，把流量作为切入点，从流量控制，熔断降级，系统负载 保护等多个维度保护系统服务的稳定性</li><li>Nacos：阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台</li><li>RocketMQ：基于Java的高性能，高吞吐量的分布式消息和流计算平台</li><li>Dubbo：Apache Dubbo是一款高性能Java RPC框架</li><li>Seata：一个易于使用的高性能微服务分布式事务解决方案</li><li>Alibaba Cloud OOS：阿里云对象存储（Object Storage Service，简称OOS），是阿里云提供的海量，安全，低成本，高可靠的云存储服务，您可以在任何应用，任何时间，任何地点存储和访问任意类型的数据。</li><li>Alibaba Cloud SchedulerX：阿里中间件团队开发的一款分布式任务调度产品，支持周期的任务与固定时间点触发</li></ul><h2 id="Nacos简介"><a href="#Nacos简介" class="headerlink" title="Nacos简介"></a>Nacos简介</h2><p>Nacos服务注册和配置中心，兼顾两种</p><h3 id="为什么叫Nacos"><a href="#为什么叫Nacos" class="headerlink" title="为什么叫Nacos"></a>为什么叫Nacos</h3><p>前四个字母分别为：Naming（服务注册） 和 Configuration（配置中心） 的前两个字母，后面的s 是 Service</p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>一个更易于构建云原生应用的动态服务发现，配置管理和服务</p><p>Nacos：Dynamic Naming and Configuration Server</p><p>Nacos就是注册中心 + 配置中心的组合</p><p>等价于：Nacos = Eureka + Config</p><h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><p>替代Eureka做服务注册中心</p><p>替代Config做服务配置中心</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>官网：<a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener">https://github.com/alibaba/nacos</a></p><p>nacos文档：<a href="https://nacos.io/zh-cn/docs/what-is-nacos.html" target="_blank" rel="noopener">https://nacos.io/zh-cn/docs/what-is-nacos.html</a></p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><img data-src="image-20200414165716292.png" alt="image"></p><p>Nacos在阿里巴巴内部有超过10万的实例运行，已经过了类似双十一等各种大型流量的考验</p><h3 id="安装并运行"><a href="#安装并运行" class="headerlink" title="安装并运行"></a>安装并运行</h3><p>本地需要 java8 + Maven环境</p><p>下载：<a href="https://github.com/alibaba/nacos/releases/tag/1.1.4" target="_blank" rel="noopener">地址</a></p><p>github经常抽风，可以使用：<a href="https://blog.csdn.net/buyaopa/article/details/104582141" target="_blank" rel="noopener">https://blog.csdn.net/buyaopa/article/details/104582141</a></p><p>解压后：运行bin目录下的：startup.cmd</p><p>打开：<code>http://localhost:8848/nacos</code></p><p>结果页面</p><p><img data-src="image-20200414181458943.png" alt="image"></p><h2 id="Nacos作为服务注册中心"><a href="#Nacos作为服务注册中心" class="headerlink" title="Nacos作为服务注册中心"></a>Nacos作为服务注册中心</h2><h3 id="服务提供者注册Nacos"><a href="#服务提供者注册Nacos" class="headerlink" title="服务提供者注册Nacos"></a>服务提供者注册Nacos</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud alibaba nacos--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="修改yml"><a href="#修改yml" class="headerlink" title="修改yml"></a>修改yml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9002</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-payment-provider</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 127.0.0.1:8848   # 配置nacos地址</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#39;*&#39;</span><br></pre></td></tr></table></figure><h4 id="主启动类"><a href="#主启动类" class="headerlink" title="主启动类"></a>主启动类</h4><p>添加 <code>@EnableDiscoveryClient</code> 注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class PaymentMain9002 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain9002.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class PaymentController &#123;</span><br><span class="line">    @Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">    private String serverPort;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;payment&#x2F;nacos&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public String getPayment(@PathVariable(&quot;id&quot;) Integer id) &#123;</span><br><span class="line">        return &quot;nacos registry ,serverPore:&quot;+serverPort+&quot;\t id:&quot;+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>nacos-payment-provider已经成功注册了</p><p><img data-src="image-20200414182221528.png" alt="image"></p><p>这个时候 nacos服务注册中心 + 服务提供者 9001 都OK了</p><p>通过IDEA的拷贝映射</p><p><img data-src="image-20200414215206684.png" alt="image"></p><p>添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DServer.port&#x3D;9003</span><br></pre></td></tr></table></figure><p><img data-src="image-20200414215128701.png" alt="image"></p><p>最后能够看到两个实例</p><p><img data-src="C:/Users/ylyang/Desktop/juc-jvm-%E5%91%A8%E9%98%B3-201906-201904/LearningNotes/SpringCloud/SpringCloud2020/13_Nacos%E6%98%AF%E4%BB%80%E4%B9%88/images/image-20200414215440351.png" alt="image-20200414215440351"></p><p><img data-src="image-20200414215621673.png" alt="image"></p><h3 id="服务消费者注册到Nacos"><a href="#服务消费者注册到Nacos" class="headerlink" title="服务消费者注册到Nacos"></a>服务消费者注册到Nacos</h3><p>Nacos天生集成了Ribbon，因此它就具备负载均衡的能力</p><h4 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringCloud alibaba nacos--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="修改yml-1"><a href="#修改yml-1" class="headerlink" title="修改yml"></a>修改yml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 83</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-order-consumer</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848</span><br><span class="line"></span><br><span class="line"># 消费者将要去访问的微服务名称（注册成功进nacos的微服务提供者）</span><br><span class="line">service-url:</span><br><span class="line">  nacos-user-service: http:&#x2F;&#x2F;nacos-payment-provider</span><br></pre></td></tr></table></figure><h4 id="增加配置类"><a href="#增加配置类" class="headerlink" title="增加配置类"></a>增加配置类</h4><p>因为nacos集成了Ribbon，因此需要配置RestTemplate，同时通过注解 <code>@LoadBalanced</code>实现负载均衡，默认是轮询的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ApplicationContextConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    public RestTemplate getRestTemple() &#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务类-1"><a href="#业务类-1" class="headerlink" title="业务类"></a>业务类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderNacosController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)</span><br><span class="line">    private String serverURL;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;consumer&#x2F;payment&#x2F;nacos&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public String paymentInfo(@PathVariable(&quot;id&quot;)Long id)&#123;</span><br><span class="line">       return restTemplate.getForObject(serverURL+&quot;&#x2F;payment&#x2F;nacos&#x2F;&quot; + id, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:83&#x2F;consumer&#x2F;payment&#x2F;nacos&#x2F;13</span><br></pre></td></tr></table></figure><p>得到的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nacos registry ,serverPore:9001 id:13</span><br><span class="line">nacos registry ,serverPore:9002 id:13</span><br></pre></td></tr></table></figure><p>我们发现只需要配置了nacos，就轻松实现负载均衡</p><h3 id="服务中心对比"><a href="#服务中心对比" class="headerlink" title="服务中心对比"></a>服务中心对比</h3><p>之前我们提到的注册中心对比图</p><p><img data-src="image-20200415193857281.png" alt="image"></p><p>但是其实Nacos不仅支持AP，而且还支持CP，它的支持模式是可以切换的，我们首先看看Spring Cloud Alibaba的全景图，</p><p><img data-src="image-20200415194047564.png" alt="image"></p><h4 id="Nacos和CAP"><a href="#Nacos和CAP" class="headerlink" title="Nacos和CAP"></a>Nacos和CAP</h4><p>CAP：分别是一致性，可用性，分容容忍</p><p><img data-src="image-20200415194123634.png" alt="image"></p><p>我们从下图能够看到，nacos不仅能够和Dubbo整合，还能和K8s，也就是偏运维的方向</p><p><img data-src="image-20200415194203594.png" alt="image"></p><h4 id="Nacos支持AP和CP切换"><a href="#Nacos支持AP和CP切换" class="headerlink" title="Nacos支持AP和CP切换"></a>Nacos支持AP和CP切换</h4><p>C是指所有的节点同一时间看到的数据是一致的，而A的定义是所有的请求都会收到响应</p><p>合适选择何种模式？</p><p>一般来说，如果不需要存储服务级别的信息且服务实例是通过nacos-client注册，并能够保持心跳上报，那么就可以选择AP模式。当前主流的服务如Spring Cloud 和 Dubbo服务，都是适合AP模式，AP模式为了服务的可用性而减弱了一致性，因此AP模式下只支持注册临时实例。</p><p>如果需要在服务级别编辑或存储配置信息，那么CP是必须，K8S服务和DNS服务则适用于CP模式。</p><p>CP模式下则支持注册持久化实例，此时则是以Raft协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。</p><h2 id="Nacos作为服务配置中心演示"><a href="#Nacos作为服务配置中心演示" class="headerlink" title="Nacos作为服务配置中心演示"></a>Nacos作为服务配置中心演示</h2><p>我们将我们的配置写入Nacos，然后以Spring Cloud Config的方式，用于抓取配置</p><h3 id="Nacos作为配置中心-基础配置"><a href="#Nacos作为配置中心-基础配置" class="headerlink" title="Nacos作为配置中心 - 基础配置"></a>Nacos作为配置中心 - 基础配置</h3><h4 id="引入依赖-2"><a href="#引入依赖-2" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入nacos config--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="修改YML"><a href="#修改YML" class="headerlink" title="修改YML"></a>修改YML</h4><p>Nacos同SpringCloud Config一样，在项目初始化时，要保证先从配置中心进行配置拉取，拉取配置之后，才能保证项目的正常运行。</p><p>SpringBoot中配置文件的加载是存在优先级顺序的：bootstrap优先级 高于 application</p><p><strong>application.yml配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line"> #   active: dev # 开发环境</span><br><span class="line"> #   active: test # 测试环境</span><br><span class="line">    active: info # 开发环境</span><br></pre></td></tr></table></figure><p><strong>bootstrap.yml配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 3377</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-config-client</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848 # 注册中心</span><br><span class="line">      config:</span><br><span class="line">        server-addr: localhost:8848 # 配置中心</span><br><span class="line">        file-extension: yml # 这里指定的文件格式需要和nacos上新建的配置文件后缀相同，否则读不到</span><br><span class="line">        group: TEST_GROUP</span><br><span class="line">        namespace: 1bdf1418-3ed4-442c-97c1-f525b6a85b34</span><br><span class="line"></span><br><span class="line">#  $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br></pre></td></tr></table></figure><h4 id="主启动类-1"><a href="#主启动类-1" class="headerlink" title="主启动类"></a>主启动类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class NacosConfigClientMain3377 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(NacosConfigClientMain3377.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务类-2"><a href="#业务类-2" class="headerlink" title="业务类"></a>业务类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RefreshScope &#x2F;&#x2F; 支持nacos的动态刷新</span><br><span class="line">public class ConfigClientController &#123;</span><br><span class="line">    @Value(&quot;$&#123;config.info&#125;&quot;)</span><br><span class="line">    private String configInfo;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;config&#x2F;info&quot;)</span><br><span class="line">    public String getConfigInfo()&#123;</span><br><span class="line">        return configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过SpringCloud原生注解 <code>@RefreshScope</code> 实现配置自动刷新</p><h4 id="在Nacos中添加配置信息"><a href="#在Nacos中添加配置信息" class="headerlink" title="在Nacos中添加配置信息"></a>在Nacos中添加配置信息</h4><h5 id="Nacos中匹配规则"><a href="#Nacos中匹配规则" class="headerlink" title="Nacos中匹配规则"></a>Nacos中匹配规则</h5><p>Nacos中的dataid的组成格式及与SpringBoot配置文件中的匹配规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span><br></pre></td></tr></table></figure><p>这样，就对应我们Nacos中的这样一个配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nacos-config-client-dev.yml</span><br></pre></td></tr></table></figure><p>配置说明</p><p><img data-src="image-20200415201834108.png" alt="image"></p><p>我们在Nacos中添加配置</p><p><img data-src="image-20200415201605809.png" alt="image"></p><p><img data-src="image-20200415201532098.png" alt="image"></p><p>这里需要注意的是，在<code>config:</code> 的后面必须加上一个空格</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>启动前需要在nacos客户端-配置管理下有对应的yml配置文件，然后运行cloud-config-nacos-client:3377的主启动类，调用接口查看配置信息。</p><p>启动的时候出现问题</p><p><img data-src="image-20200415202334437.png" alt="image"></p><p>这是因为无法读取配置所引起的，解决方案就是我们的文件名不能用 .yml 而应该是 .yaml</p><p><img data-src="image-20200415202411451.png" alt="image"></p><p>我们需要删除重新建立。</p><h4 id="自带动态刷新"><a href="#自带动态刷新" class="headerlink" title="自带动态刷新"></a>自带动态刷新</h4><p>修改Nacos中的yaml配置文件，再次查看配置的接口，就会发现配置已经刷新了</p><h3 id="Nacos作为配置中心-分类配置"><a href="#Nacos作为配置中心-分类配置" class="headerlink" title="Nacos作为配置中心 - 分类配置"></a>Nacos作为配置中心 - 分类配置</h3><p>从上面的配置中心 + 动态刷新 ， 就相当于 有了 SpringCloud Config + Spring Cloud Bus的功能</p><p>作为后起之秀的Nacos，还具备分类配置的功能</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>用于解决多环境多项目管理</p><p>在实际开发中，通常一个系统会准备</p><ul><li>dev开发环境</li><li>test测试环境</li><li>prod生产环境</li></ul><p>如何保证指定环境启动时，服务能正确读取到Nacos上相应环境的配置文件呢？</p><p>同时，一个大型分布式微服务系统会有很多微服务子项目，每个微服务子项目又都会有相应的开发环境，测试环境，预发环境，正式环境，那怎么对这些微服务配置进行管理呢？</p><h4 id="Nacos图形化界面"><a href="#Nacos图形化界面" class="headerlink" title="Nacos图形化界面"></a>Nacos图形化界面</h4><p>配置管理:</p><p><img data-src="image-20200415203545643.png" alt="image"></p><p>命名空间：</p><p><img data-src="image-20200415203611077.png" alt="image"></p><h4 id="Namespace-Group-Data-ID-三者关系"><a href="#Namespace-Group-Data-ID-三者关系" class="headerlink" title="Namespace + Group + Data ID 三者关系"></a>Namespace + Group + Data ID 三者关系</h4><p>这种分类的设计思想，就类似于java里面的package名 和 类名，最外层的namespace是可以用于区分部署环境的，Group 和 DataID逻辑上区分两个目标对象</p><p><img data-src="image-20200415203750816.png" alt="image"></p><p>默认情况：</p><p>Namespace=public，Group=DEFAULT_GROUP，默认Cluster是DEFAULT</p><p>Nacos默认的命名空间是public，Namespace主要用来实现隔离</p><p>比如说我们现在有三个环境：开发，测试，生产环境，我们就可以建立三个Namespace，不同的Namespace之间是隔离的。</p><p>Group默认是DEFAULT_GROUP，Group可以把不同微服务划分到同一个分组里面去</p><p>Service就是微服务，一个Service可以包含多个Cluster（集群），Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。比如说为了容灾，将Service微服务分别部署在了杭州机房，这时就可以给杭州机房的Service微服务起一个集群名称（HZ），给广州机房的Service微服务起一个集群名称，还可以尽量让同一个机房的微服务相互调用，以提升性能，最后Instance，就是微服务的实例。</p><h4 id="三种方案加载配置"><a href="#三种方案加载配置" class="headerlink" title="三种方案加载配置"></a>三种方案加载配置</h4><h5 id="DataID方案"><a href="#DataID方案" class="headerlink" title="DataID方案"></a>DataID方案</h5><ul><li>指定spring.profile.active 和 配置文件的DataID来使不同环境下读取不同的配置</li><li>默认空间 + 默认分组 + 新建dev 和 test两个DataID</li></ul><h5 id="Group方案"><a href="#Group方案" class="headerlink" title="Group方案"></a>Group方案</h5><p>在创建的时候，添加分组信息</p><p><img data-src="image-20200415211944859.png" alt="image"></p><p>然后就可以添加分组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 3377</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-config-client</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848 # 注册中心</span><br><span class="line">      config:</span><br><span class="line">        server-addr: localhost:8848 # 配置中心</span><br><span class="line">        file-extension: yaml # 这里指定的文件格式需要和nacos上新建的配置文件后缀相同，否则读不到</span><br><span class="line">        group: TEST_GROUP</span><br></pre></td></tr></table></figure><h5 id="Namspace方案"><a href="#Namspace方案" class="headerlink" title="Namspace方案"></a>Namspace方案</h5><p>首先我们需要新建一个命名空间</p><p><img data-src="image-20200415212414302.png" alt="image"></p><p>新建完成后，能够看到有命名空间id</p><p><img data-src="image-20200415212455416.png" alt="image"></p><p>创建完成后，我们会发现，多出了几个命名空间切换</p><p><img data-src="image-20200415212550443.png" alt="image"></p><p>同时，我们到服务列表，发现也多了命名空间的切换</p><p><img data-src="image-20200415212638006.png" alt="image"></p><p>下面我们就可以通过引入namespaceI，来创建到指定的命名空间下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 3377</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-config-client</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848 # 注册中心</span><br><span class="line">      config:</span><br><span class="line">        server-addr: localhost:8848 # 配置中心</span><br><span class="line">        file-extension: yaml # 这里指定的文件格式需要和nacos上新建的配置文件后缀相同，否则读不到</span><br><span class="line">        group: DEV_GROUP</span><br><span class="line">        namespace: bbf379fb-f979-4eab-8947-2f38cfae6c0c</span><br></pre></td></tr></table></figure><p>最后通过 namespace + group + DataID 形成三级分类</p><h2 id="Nacos集群和持久化配置"><a href="#Nacos集群和持久化配置" class="headerlink" title="Nacos集群和持久化配置"></a>Nacos集群和持久化配置</h2><h3 id="官网说明"><a href="#官网说明" class="headerlink" title="官网说明"></a>官网说明</h3><p>用于部署生产中的集群模式</p><p><img data-src="image-20200415214554761.png" alt="image"></p><p>默认Nacos使用嵌入数据库实现数据的存储，所以，如果启动多个默认配置下的Nacos节点，数据存储是存在一致性问题的。为了解决这个问题，Nacos采用了集中式存储的方式来支持集群化部署，目前只支持MySQL的存储。</p><p>Nacos支持三种部署模式</p><ul><li>单机模式：用于测试和单机使用</li><li>集群模式：用于生产环境，确保高可用</li><li>多集群模式：用于多数据中心场景</li></ul><h3 id="单机模式支持mysql"><a href="#单机模式支持mysql" class="headerlink" title="单机模式支持mysql"></a>单机模式支持mysql</h3><p>在0.7版本之前，在单机模式下nacos使用嵌入式数据库实现数据的存储，不方便观察数据存储的基本情况。0.7版本增加了支持mysql数据源能力，具体的操作流程：</p><ul><li>安装数据库，版本要求：5.6.5 + </li><li>初始化数据库，数据库初始化文件：nacos-mysql.sql</li><li>修改conf/application.properties文件，增加mysql数据源配置，目前仅支持mysql，添加mysql数据源的url，用户名和密码</li></ul><p><img data-src="image-20200415215209988.png" alt="image"></p><p>再次以单机模式启动nacos，nacos所有写嵌入式数据库的数据都写到了mysql中。</p><h3 id="Nacos持久化配置解释"><a href="#Nacos持久化配置解释" class="headerlink" title="Nacos持久化配置解释"></a>Nacos持久化配置解释</h3><p>Nacos默认自带的是嵌入式数据库derby</p><p>因此我们需要完成derby到mysql切换配置步骤</p><ul><li>在nacos\conf目录下，找到SQL脚本</li></ul><p><img data-src="image-20200415231605632.png" alt="image"></p><p>然后执行SQL脚本，同时修改application.properties目录</p><p><a href="https://nacos.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">官网地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.platform&#x3D;mysql</span><br><span class="line"></span><br><span class="line">db.num&#x3D;1</span><br><span class="line">db.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;nacos_devtest?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true</span><br><span class="line">db.user&#x3D;root</span><br><span class="line">db.password&#x3D;root</span><br></pre></td></tr></table></figure><p>修改完成后，启动nacos，可以看到是一个全新的空记录页面，以前是记录进derby</p><h3 id="Linux版Nacos-Mysql生产环境配置"><a href="#Linux版Nacos-Mysql生产环境配置" class="headerlink" title="Linux版Nacos + Mysql生产环境配置"></a>Linux版Nacos + Mysql生产环境配置</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>预计需要：1个Nginx + 3个nacos注册中心 + 1个mysql</p><p>所有的请求过来，首先先打到nginx上</p><h4 id="Nacos下载Linux版本"><a href="#Nacos下载Linux版本" class="headerlink" title="Nacos下载Linux版本"></a>Nacos下载Linux版本</h4><p>在nacos github下载：<code>https://github.com/alibaba/nacos/releases</code></p><p>选择Linux版本下载</p><p><img data-src="image-20200415232903575.png" alt="image"></p><h4 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h4><p>如果是一个nacos：启动 8848即可</p><p>如果是多个nacos：3333,4444,5555</p><p>那么就需要修改startup.sh里面的，传入端口号</p><p>步骤：</p><ul><li>Linux服务器上mysql数据库配置</li><li>application.properties配置</li><li>Linux服务器上nacos的集群配置cluster.conf<ul><li>梳理出3台nacos集群的不同服务端口号</li><li>复制出cluster.conf（备份）</li><li>修改</li></ul></li></ul><p><img data-src="image-20200415233933223.png" alt="image"></p><ul><li><p>编辑Nacos的启动脚本startup.sh，使它能够接受不同的启动端口</p><ul><li>/nacos/bin 目录下有startup.sh</li><li>平时单机版的启动，直接./startup.sh</li><li>但是集群启动时，我们希望可以类似其它软件的shell命令，传递不同的端口号启动不同的nacos实例，命令：./startup.sh -p 3333表示启动端口号为3333的nacos服务器实例，和上一步的cluster.conf配置一样。</li></ul><p>修改启动脚本，添加P，这样能够明确nacos启动的什么脚本</p></li></ul><p><img data-src="image-20200415235915453.png" alt="image"></p><p><img data-src="image-20200415235932505.png" alt="image"></p><p>修改完成后，就能够使用下列命令启动集群了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;startup.sh -p 3333</span><br><span class="line">.&#x2F;startup.sh -p 4444</span><br><span class="line">.&#x2F;startup.sh -p 5555</span><br></pre></td></tr></table></figure><ul><li>Nginx的配置，由它作为负载均衡器<ul><li>修改nginx的配置文件</li></ul></li></ul><p><img data-src="image-20200416000415104.png" alt="image"></p><p>作为负载均衡分流，同时upstream 支持weight</p><p>通过nginx访问nacos节点：<code>http://192.168.111.144:1111/nacos/#/login</code></p><p>微服务注册进集群中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9002</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-payment-provider</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 192.168.111.144:1111 # 换成nginx的1111端口，做负债均衡</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#39;*&#39;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Nginx + 3个Nacos + mysql的集群化配置</p><p><img data-src="image-20200416001145081.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloudAlibaba </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> SpringCloudAlibaba </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud之分布式请求链路跟踪Sleuth</title>
      <link href="/2020/06/21/SpringCloud%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%B7%E6%B1%82%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AASleuth/"/>
      <url>/2020/06/21/SpringCloud%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%B7%E6%B1%82%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AASleuth/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloudSleuth分布式请求链路跟踪"><a href="#SpringCloudSleuth分布式请求链路跟踪" class="headerlink" title="SpringCloudSleuth分布式请求链路跟踪"></a>SpringCloudSleuth分布式请求链路跟踪</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务节点调用来协同产生最后的请求结果，每一个前端请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。</p><a id="more"></a><p><img data-src="image-20200414142800496.png" alt="image"></p><p>当链路特别多的时候</p><p><img data-src="image-20200414142915202.png" alt="image"></p><p>就需要有一个用于调用链路的监控和服务跟踪的解决方案</p><p>SpringCloudSleuth提供了一套完整的服务跟踪解决方案，在分布式系统中，提供了追踪解决方案，并且兼容支持了zipkin。</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="zipkin"><a href="#zipkin" class="headerlink" title="zipkin"></a>zipkin</h3><p>SpringCloud从F版起，已经不需要自己构建Zipkin Server了，只需要调用jar包即可</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar zipkin.jar</span><br></pre></td></tr></table></figure><h4 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:9441&#x2F;zipkin</span><br></pre></td></tr></table></figure><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li>Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识</li><li>Span：表示调用链路来源，通俗的理解span就是一次请求信息</li></ul><h4 id="完整的调用链路"><a href="#完整的调用链路" class="headerlink" title="完整的调用链路"></a>完整的调用链路</h4><p>表示一请求链路， 一条链路通过Trace ID唯一标识，Span标识发起请求信息，各span通过parent id关联起来。</p><p><img data-src="image-20200414152236173.png" alt="image"></p><p>一条链路通过Trace Id唯一标识，Span表示发起的请求信息，各span通过parent id关联起来</p><p><img data-src="image-20200414152425574.png" alt="image"></p><p>整个链路的依赖关系如下：</p><p><img data-src="image-20200414152440036.png" alt="image"></p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--链路监控包含sleuth+zipkin--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="修改yml"><a href="#修改yml" class="headerlink" title="修改yml"></a>修改yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-order-service</span><br><span class="line">  zipkin:</span><br><span class="line">    base-url: http:&#x2F;&#x2F;localhost:9411</span><br><span class="line">  sleuth:</span><br><span class="line">    sampler:</span><br><span class="line">      # 采集率介于0到1之间，1表示全部采集</span><br><span class="line">      probability: 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud之消息驱动SpringCloudStream</title>
      <link href="/2020/06/18/SpringCloud%E4%B9%8B%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8Stream/"/>
      <url>/2020/06/18/SpringCloud%E4%B9%8B%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8Stream/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud-Stream-消息驱动"><a href="#SpringCloud-Stream-消息驱动" class="headerlink" title="SpringCloud Stream 消息驱动"></a>SpringCloud Stream 消息驱动</h1><h2 id="为什么引入消息驱动？"><a href="#为什么引入消息驱动？" class="headerlink" title="为什么引入消息驱动？"></a>为什么引入消息驱动？</h2><p>首先看到消息驱动，我们会想到，消息中间件</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><a id="more"></a><p><img data-src="image-20200414090346586.png" alt="image"></p><p>存在的问题就是，中台和后台 可能存在两种MQ，那么他们之间的实现都是不一样的，这样会导致多种问题出现，而且上述我们也看到了，目前主流的MQ有四种，我们不可能每个都去学习</p><p>这个时候的痛点就是：有没有一种新的技术诞生，让我们不在关注具体MQ的细节，我们只需要用一种适配绑定的方式，自动的给我们在各种MQ内切换。</p><p>这个时候，SpringCloudStream就运营而生，解决的痛点就是屏蔽了消息中间件的底层的细节差异，我们操作Stream就可以操作各种消息中间件了，从而降低开发人员的开发成本。</p><h2 id="消息驱动概述"><a href="#消息驱动概述" class="headerlink" title="消息驱动概述"></a>消息驱动概述</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型</p><p>这就有点像Hibernate，它同时支持多种数据库，同时还提供了Hibernate Session的语法，也就是HQL语句，这样屏蔽了SQL具体实现细节，我们只需要操作HQL语句，就能够操作不同的数据库。</p><h3 id="什么是SpringCloudStream"><a href="#什么是SpringCloudStream" class="headerlink" title="什么是SpringCloudStream"></a>什么是SpringCloudStream</h3><p>官方定义 SpringCloudStream是一个构件消息驱动微服务的框架</p><p>应用程序通过inputs或者outputs来与SpringCloudStream中binder对象（绑定器）交互。</p><p>通过我们配置来binding(绑定)，而SpringCloudStream的binder对象负责与消息中间件交互</p><p>所以，我们只需要搞清楚如何与SpringCloudStream交互，就可以方便的使用消息驱动的方式。</p><p>通过使用SpringIntegration来连接消息代理中间件以实现消息事件驱动。</p><p>SpringCloudStream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅，消费组，分区的三个核心概念</p><p>目前仅支持RabbitMQ 和 Kafka</p><h3 id="SpringCloudStrem设计思想"><a href="#SpringCloudStrem设计思想" class="headerlink" title="SpringCloudStrem设计思想"></a>SpringCloudStrem设计思想</h3><h4 id="标准MQ"><a href="#标准MQ" class="headerlink" title="标准MQ"></a>标准MQ</h4><p><img data-src="image-20200414091850411.png" alt="image1"></p><ul><li>生产者/消费者之间靠消息媒介传递消息内容：Message</li><li>消息必须走特定的通道：Channel</li><li>消息通道里的消息如何被消费呢，谁负责收发处理<ul><li>消息通道MessageChannel的子接口SubscribableChannel，由MessageHandler消息处理器所订阅</li></ul></li></ul><h4 id="为什么用SpringCloudStream"><a href="#为什么用SpringCloudStream" class="headerlink" title="为什么用SpringCloudStream"></a>为什么用SpringCloudStream</h4><p>RabbitMQ和Kafka，由于这两个消息中间件的架构上不同</p><p>像RabbitMQ有exchange，kafka有Tpic和Partitions分区</p><p><img data-src="image-20200414092237268.png" alt="image"></p><p>这些中间件的差异导致我们实际项目开发给我们造成了一定的困扰，我们如果用了两个消息队列的其中一种，后面的业务需求，我们想往另外一种消息队列进行迁移，这时候无疑就是灾难性的，一大堆东西都要推到重新做，因为它根我们的系统耦合了，这时候SpringCloudStream给我们提供了一种解耦的方式</p><p>这个时候，我们就需要一个绑定器，可以想成是翻译官，用于实现两种消息之间的转换</p><h4 id="SpringCloudStream为什么能屏蔽底层差异"><a href="#SpringCloudStream为什么能屏蔽底层差异" class="headerlink" title="SpringCloudStream为什么能屏蔽底层差异"></a>SpringCloudStream为什么能屏蔽底层差异</h4><p>在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行消息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性。通过定义绑定器作为中间件，完美的实现了应用程序与消息中间件细节之间的隔离。</p><p>通过向应用程序暴露统一的Channel通道，使得应用程序不需要在考虑各种不同消息中间件的实现。</p><p>通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。</p><h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h4><ul><li>input：对应消费者</li><li>output：对应生产者</li></ul><p>Stream对消息中间件的进一步封装，可以做到代码层面对中间件的无感知，甚至于动态的切换中间件（RabbitMQ切换Kafka），使得微服务开发的高度解耦，服务可以关注更多的自己的业务流程。</p><p><img data-src="image-20200414093128482.png" alt="image"></p><p>通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。</p><p>Stream中的消息通信方式遵循了发布-订阅模式，Topic主题进行广播，在RabbitMQ中就是Exchange，在Kafka中就是Topic</p><h4 id="Stream标准流程套路"><a href="#Stream标准流程套路" class="headerlink" title="Stream标准流程套路"></a>Stream标准流程套路</h4><p>我们的消息生产者和消费者只和Stream交互</p><p><img data-src="image-20200414093537489.png" alt="image"></p><ul><li>Binder：很方便的连接中间件，屏蔽差异</li><li>Channel：通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的没接，通过Channel对队列进行配置</li><li>Source和Sink：简单的可以理解为参照对象是SpringCloudStream自身，从Stream发布消息就是输出，接受消息就是输入。</li></ul><h4 id="编码中的注解"><a href="#编码中的注解" class="headerlink" title="编码中的注解"></a>编码中的注解</h4><p><img data-src="image-20200414093854499.png" alt="image"></p><h2 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h2><p>前提是已经安装好了RabbitMQ</p><ul><li>cloud-stream-rabbitmq-procider8801，作为消息生产者进行发消息模块</li><li>cloud-stream-rabbitmq-procider8802，消息接收模块</li><li>cloud-stream-rabbitmq-procider8803，消息接收模块</li></ul><h2 id="消息驱动之生产者"><a href="#消息驱动之生产者" class="headerlink" title="消息驱动之生产者"></a>消息驱动之生产者</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Stream--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="修改yml"><a href="#修改yml" class="headerlink" title="修改yml"></a>修改yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-stream-provider</span><br><span class="line">  cloud:</span><br><span class="line">    stream:</span><br><span class="line">      binders: # 在此处配置要绑定的rabbitMQ的服务信息</span><br><span class="line">        defaultRabbit: # 表示定义的名称，用于binding的整合</span><br><span class="line">          type: rabbit # 消息中间件类型</span><br><span class="line">          environment: # 设置rabbitMQ的相关环境配置</span><br><span class="line">            spring:</span><br><span class="line">              rabbitmq:</span><br><span class="line">                host: localhost</span><br><span class="line">                port: 5672</span><br><span class="line">                username: guest</span><br><span class="line">                password: guest</span><br><span class="line">      bindings: # 服务的整合处理</span><br><span class="line">        output: # 这个名字是一个通道的名称</span><br><span class="line">          destination: studyExchange # 表示要使用的exchange名称定义</span><br><span class="line">          content-type: application&#x2F;json # 设置消息类型，本次为json，文本则设为text&#x2F;plain</span><br><span class="line">          binder: defaultRabbit # 设置要绑定的消息服务的具体设置</span><br></pre></td></tr></table></figure><h3 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h3><h4 id="发送消息的接口"><a href="#发送消息的接口" class="headerlink" title="发送消息的接口"></a>发送消息的接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IMassageProvider &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义一个发送方法</span><br><span class="line">    public String send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送消息的接口实现类"><a href="#发送消息的接口实现类" class="headerlink" title="发送消息的接口实现类"></a>发送消息的接口实现类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @EnableBinding： 指信道channel 和 exchange绑定在一起</span><br><span class="line">@EnableBinding(Source.class) &#x2F;&#x2F;定义消息的推送管道</span><br><span class="line">public class MessageProviderImpl implements IMassageProvider &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private MessageChannel output; &#x2F;&#x2F;消息发送管道（原来这里是操作dao，现在是操作消息中间件发送消息）</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String send() &#123;</span><br><span class="line">        String serial&#x3D; UUID.randomUUID().toString();</span><br><span class="line">        &#x2F;&#x2F; 消息构建器构建一个消息 MessageBuilder</span><br><span class="line">        output.send(MessageBuilder.withPayload(serial).build());</span><br><span class="line">        System.out.println(&quot;***********serial&quot;+serial);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class SendMessageController &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private IMassageProvider massageProvider;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;sendMessage&quot;)</span><br><span class="line">    public String sendMessage()&#123;</span><br><span class="line">        return massageProvider.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个REST接口，调用的时候，发送一个消息</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>我们进入RabbitAdmin页面  <code>http://localhost:15672</code></p><p><img data-src="image-20200414095920920.png" alt="image"></p><p>会发现它已经成功创建了一个studyExchange的交换机，这个就是我们上面配置的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bindings: # 服务的整合处理</span><br><span class="line">  output: # 这个名字是一个通道的名称</span><br><span class="line">    destination: studyExchange # 表示要使用的exchange名称定义</span><br><span class="line">    content-type: application&#x2F;json # 设置消息类型，本次为json，文本则设为text&#x2F;plain</span><br><span class="line">    binder: defaultRabbit # 设置要绑定的消息服务的具体设置</span><br></pre></td></tr></table></figure><p>以后就会通过这个交换机进行消息的消费</p><p>我们运行下列代码，进行测试消息发送 <code>http://localhost:8801/sendMessage</code></p><p>能够发现消息已经成功被RabbitMQ捕获，这个时候就完成了消息的发送</p><p><img data-src="image-20200414100125220.png" alt="image"></p><h2 id="消息驱动之消费者"><a href="#消息驱动之消费者" class="headerlink" title="消息驱动之消费者"></a>消息驱动之消费者</h2><h3 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Stream--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="修改yml-1"><a href="#修改yml-1" class="headerlink" title="修改yml"></a>修改yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-stream-consumer</span><br><span class="line">  cloud:</span><br><span class="line">    stream:</span><br><span class="line">      binders: # 在此处配置要绑定的rabbitMQ的服务信息</span><br><span class="line">        defaultRabbit: # 表示定义的名称，用于binding的整合</span><br><span class="line">          type: rabbit # 消息中间件类型</span><br><span class="line">          environment: # 设置rabbitMQ的相关环境配置</span><br><span class="line">            spring:</span><br><span class="line">              rabbitmq:</span><br><span class="line">                host: localhost</span><br><span class="line">                port: 5672</span><br><span class="line">                username: guest</span><br><span class="line">                password: guest</span><br><span class="line">      bindings: # 服务的整合处理</span><br><span class="line">        input: # 这个名字是一个通道的名称</span><br><span class="line">          destination: studyExchange # 表示要使用的exchange名称定义</span><br><span class="line">          content-type: application&#x2F;json # 设置消息类型，本次为json，文本则设为text&#x2F;plain</span><br><span class="line">          binder: defaultRabbit # 设置要绑定的消息服务的具体设置</span><br><span class="line">          group: atguiguA</span><br></pre></td></tr></table></figure><h3 id="业务类-1"><a href="#业务类-1" class="headerlink" title="业务类"></a>业务类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@EnableBinding(Sink.class)  &#x2F;&#x2F; 绑定通道</span><br><span class="line">public class ReceiveMessageListenerController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">    private String serverPort;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 监听队列，用于消费者队列的消息接收</span><br><span class="line">    @StreamListener(Sink.INPUT)</span><br><span class="line">    public void input(Message&lt;String&gt; message) &#123;</span><br><span class="line">        System.out.println(&quot;消费者1号，0------&gt;接收到消息：&quot;+message.getPayload()+&quot;\t port:&quot;+serverPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组消费"><a href="#分组消费" class="headerlink" title="分组消费"></a>分组消费</h2><p>我们在创建一个8803的消费者服务，需要启动的服务</p><ul><li>RabbitMQ：消息中间件</li><li>7001：服务注册</li><li>8801：消息生产</li><li>8802：消息消费</li><li>8803：消息消费</li></ul><h3 id="运行后有两个问题"><a href="#运行后有两个问题" class="headerlink" title="运行后有两个问题"></a>运行后有两个问题</h3><ul><li>有重复消费问题</li><li>消息持久化问题</li></ul><h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><p>目前8802 、8803同时都收到了，存在重复消费的问题</p><p>如何解决：使用分组和持久化属性 group来解决</p><p>比如在如下场景中，订单系统我们做集群部署，都会从RabbitMQ中获取订单信息，那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况，这时我们就可以使用Stream中的消息分组来解决。</p><p><img data-src="image-20200414123004267.png" alt="image"></p><p>注意：在Stream中处于同一个group中的多个消费者是竞争关系，就能够保证消息只能被其中一个消费一次</p><p>不同组是可以全面消费的（重复消费）</p><p>同一组会发生竞争关系，只能其中一个可以消费</p><p>分布式微服务应用为了实现高可用和负载均衡，实际上都会部署多个实例，这里部署了8802 8803</p><p>多数情况下，生产者发送消息给某个具体微服务时，只希望被消费一次，按照上面我们启动两个应用的例子，虽然它们同属一个应用，但是这个消息出现了被重复消费两次的情况，为了解决这个情况，在SpringCloudStream中，就提供了 消费组 的概念</p><p><img data-src="image-20200414130034279.png" alt="image"></p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次，不同的组是可以消费的，同一组内会发生竞争关系，只有其中一个可以被消费。</p><p>我们将8802和8803划分为同一组</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment"># 在此处配置要绑定的rabbitMQ的服务信息</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment"># 表示定义的名称，用于binding的整合</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment"># 消息中间件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment"># 设置rabbitMQ的相关环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">      <span class="attr">bindings:</span> <span class="comment"># 服务的整合处理</span></span><br><span class="line">        <span class="attr">input:</span> <span class="comment"># 这个名字是一个通道的名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment"># 表示要使用的exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment"># 设置消息类型，本次为json，文本则设为text/plain</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment"># 设置要绑定的消息服务的具体设置</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">atguiguA</span></span><br></pre></td></tr></table></figure><p>引入：<code>group: atguiguA</code></p><p>然后我们执行消息发送的接口：<code>http://localhost:8801/sendMessage</code></p><p>我们在8801服务，同时发送了6条消息</p><p><img data-src="image-20200414125203160.png" alt="image"></p><p>然后看8802服务，接收到了3条</p><p><img data-src="image-20200414125231537.png" alt="image"></p><p>8803服务，也接收到了3条</p><p><img data-src="image-20200414125243408.png" alt="image"></p><p>这个时候，就通过分组，避免了消息的重复消费问题</p><p>8802、8803通过实现轮询分组，每次只有一个消费者，最后发送的消息只能够被一个接受</p><p>如果将他们的group变成两个不同的组，那么消息就会被重复消费</p><h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>通过上面的方式，我们解决了重复消费的问题，再看看持久化</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul><li>停止8802和8803，并移除8802的group，保留8803的group</li><li>8801先发送4条消息到RabbitMQ</li><li>先启动8802，无分组属性，后台没有打出来消息</li><li>在启动8803，有分组属性，后台打出来MQ上的消息</li></ul><p>这就说明消息已经被持久化了，等消费者登录后，会自动从消息队列中获取消息进行消费</p><p><img data-src="image-20200414131334047.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud之消息总线Bus</title>
      <link href="/2020/06/15/SpringCloud%E4%B9%8B%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BFBus/"/>
      <url>/2020/06/15/SpringCloud%E4%B9%8B%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BFBus/</url>
      
        <content type="html"><![CDATA[<h1 id="消息总线SpringCloudBUS"><a href="#消息总线SpringCloudBUS" class="headerlink" title="消息总线SpringCloudBUS"></a>消息总线SpringCloudBUS</h1><p>消息总线一般是配合SpringCloudConfig一起使用的</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>分布式自动刷新配置功能，SpringCloudBus配合SpringCloudConfig使用可以实现配置的动态刷新</p><p>Bus支持两种消息代理：RabbitMQ和Kafka</p><p><img data-src="image-20200413234036665.png" alt="image"></p><p>SpringCloudBus是用来将分布式系统的节点与轻量级消息系统链接起来的框架，它整合了Java的事件处理机制和消息中间件的功能。</p><p>SpringCloudBus能管理和传播分布式系统的消息，就像一个分布式执行器，可用于广播状态更改，事件推送等，也可以当做微服务的通信通道。</p><p><img data-src="image-20200413234506046.png" alt="image"></p><h3 id="什么是总线"><a href="#什么是总线" class="headerlink" title="什么是总线"></a>什么是总线</h3><p>在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以被称为消息总线。在总线上的各个实例，都可以方便的广播一些需要让其它连接在该主题上的实例都知道的消息。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>ConfigClient实例都监听MQ中同一个topic（默认是SpringCloudBus），但一个服务刷新数据的时候，它会被这个消息放到Topic中，这样其它监听同一个Topic的服务就能够得到通知，然后去更新自身的配置</p><p><img data-src="image-20200414085203534.png" alt="image"></p><p>通过topic进行广播通知</p><h2 id="RabbitMQ环境配置"><a href="#RabbitMQ环境配置" class="headerlink" title="RabbitMQ环境配置"></a>RabbitMQ环境配置</h2><p><a href="http://moguit.cn/#/info?blogUid=995e0fccd2b240aabd56a10a688e42d4" target="_blank" rel="noopener">蘑菇博客配置RabbitMQ</a></p><h2 id="SpringCloudBus动态刷新全局广播"><a href="#SpringCloudBus动态刷新全局广播" class="headerlink" title="SpringCloudBus动态刷新全局广播"></a>SpringCloudBus动态刷新全局广播</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>首先需要搭建好rabbitmq环境</p><p>然后引入RabbitMQ依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--添加消息总线Rabbitmq支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>增加yml中的rabbitmq配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-client</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      label: master #分支名称</span><br><span class="line">      name: config #配置文件名称</span><br><span class="line">      profile: dev #读取后缀文件名，即 master分支config-dev.yml</span><br><span class="line">      uri: http:&#x2F;&#x2F;localhost:3344 #配置中心地址</span><br><span class="line">  rabbitmq: #mq相关配置</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br></pre></td></tr></table></figure><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><ul><li>利用消息总线触发一个客户端/bus/refresh，而刷新所有客户端配置</li></ul><p><img data-src="image-20200413235715876.png" alt="image6"></p><ul><li>利用消息总线出发一个服务端ConfigServer的/bus/refresh断点，而刷新所有客户端的配置</li></ul><p><img data-src="image-20200413235736633.png" alt="image"></p><ul><li>图二的架构更加适合，图一不适合的原因有<ul><li>图一打破了微服务的职责单一性，因为微服务本身是业务模块，他不应该承担配置刷新的之职责</li><li>打破了微服务各节点的对等性</li><li>有一定的局限性，例如，微服务在迁移时，它的网络地址常常发生变化，此时如果想要做到自动刷新，那就会增加更多的修改。</li></ul></li></ul><h2 id="服务端添加消息总线"><a href="#服务端添加消息总线" class="headerlink" title="服务端添加消息总线"></a>服务端添加消息总线</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--添加消息总线Rabbitmq支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="增加配置"><a href="#增加配置" class="headerlink" title="增加配置"></a>增加配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-config-center</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https:&#x2F;&#x2F;github.com&#x2F;boytian&#x2F;springcloud-config.git</span><br><span class="line">          search-paths:</span><br><span class="line">            - springcloud-config</span><br><span class="line">      label: master</span><br><span class="line">  rabbitmq: #mq相关配置</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">    </span><br><span class="line"># rabbitmq相关配置，暴露bus刷新点</span><br><span class="line">management:</span><br><span class="line">  endpoints: #暴露bus刷新配置的端点</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#39;bus-refresh&#39;</span><br></pre></td></tr></table></figure><p>注意，上面的 <code>bus-refresh</code> 就是actuator的刷新机制，相当于提供了一个  /bus-refresh的post方法，当我们调用的时候，会刷新配置，然后一次发送，处处生效。</p><h2 id="客户端引入消息总线支持"><a href="#客户端引入消息总线支持" class="headerlink" title="客户端引入消息总线支持"></a>客户端引入消息总线支持</h2><h3 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--添加消息总线Rabbitmq支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="修改yml"><a href="#修改yml" class="headerlink" title="修改yml"></a>修改yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-client</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      label: master #分支名称</span><br><span class="line">      name: config #配置文件名称</span><br><span class="line">      profile: dev #读取后缀文件名，即 master分支config-dev.yml</span><br><span class="line">      uri: http:&#x2F;&#x2F;localhost:3344 #配置中心地址</span><br><span class="line">  rabbitmq: #mq相关配置</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line"></span><br><span class="line">#暴露监控端点</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br></pre></td></tr></table></figure><p>这里的暴露端点和上面的不太一样</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>当我们的服务端配置中心 和 客户端都增加完上述配置后，我们需要做的就是手动发送一个POST请求到服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST &quot;http:&#x2F;&#x2F;localhsot:33444&#x2F;actuator&#x2F;bus-refresh&quot;</span><br></pre></td></tr></table></figure><p>执行完成后，配置中心会通过BUS消息总线，发送到所有的客户端，并完成配置的刷新操作。</p><p>完成了一次修改，广播通知，处处生效的效果</p><h2 id="SpringCloudBus动态刷新定点通知"><a href="#SpringCloudBus动态刷新定点通知" class="headerlink" title="SpringCloudBus动态刷新定点通知"></a>SpringCloudBus动态刷新定点通知</h2><p>就是我想通知的目标是有差异化，有些客户端需要通过，有些不通知，也就是10个客户端，我只通知1个</p><p>简单一句话，就是指定某一个实例生效而不是全部</p><p>公式：<code>http://localhost:配置中心端口/actuator/bus-refresh/{destination}</code></p><p><code>/bus/refresh</code>请求不再发送到具体的服务实例上，而是发送给config server并通过destination参数类指定需要更新配置的服务或实例。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>以刷新运行在3355端口上的config-client为例，只通知3355，不通知3366，可以使用下面命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST &quot;http:&#x2F;&#x2F;localhsot:33444&#x2F;actuator&#x2F;bus-refresh&#x2F;config-client:3355&quot;</span><br></pre></td></tr></table></figure><p><img data-src="image-20200414085924123.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud之分布式配置中心SpringCloudConfig</title>
      <link href="/2020/06/12/SpringCloud%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83SpringCloudConfig/"/>
      <url>/2020/06/12/SpringCloud%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83SpringCloudConfig/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式配置中心SpringCloudConfig"><a href="#分布式配置中心SpringCloudConfig" class="headerlink" title="分布式配置中心SpringCloudConfig"></a>分布式配置中心SpringCloudConfig</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="面临的问题"><a href="#面临的问题" class="headerlink" title="面临的问题"></a>面临的问题</h3><p>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要必要的配置信息才能运行，所以需要一套集中式、动态的配置管理设施。</p><a id="more"></a><p>SpringCloud提供了ConfigServer来解决这个问题，原来四个微服务，需要配置四个application.yml，但需要四十个微服务，那么就需要配置40份配置文件，我们需要做的就是一处配置，到处生效。</p><p>所以这个时候就需要一个统一的配置管理</p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用提供了一个中心化的外部配置。</p><p><img data-src="image-20200411220940452.png" alt="image"></p><h3 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h3><p>服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口。</p><p>客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息，配置服务器默认采用git来存储配置信息，这样有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。</p><h3 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h3><ul><li>集中管理配置文件</li><li>不同环境不同配置，动态化的配置更新，分布式部署，比如 dev/test/prod/beta/release</li><li>运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取自己的信息</li><li>当配置发生变动时，服务不需要重启即可感知配置的变化并应用新的配置</li><li>将配置信息以REST接口的形式暴露：post，curl命令刷新</li></ul><h3 id="与Github整合部署"><a href="#与Github整合部署" class="headerlink" title="与Github整合部署"></a>与Github整合部署</h3><p>由于SpringCloud Config默认使用Git来存储配置文件（也有其他方式，比如支持SVN和本地文件），但最推荐的还是Git，而且使用的是Http/https访问的形式</p><h2 id="Config服务端配置与测试"><a href="#Config服务端配置与测试" class="headerlink" title="Config服务端配置与测试"></a>Config服务端配置与测试</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--添加消息总线Rabbitmq支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--config--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="修改YML"><a href="#修改YML" class="headerlink" title="修改YML"></a>修改YML</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 3344</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-config-center</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https:&#x2F;&#x2F;github.com&#x2F;boytian&#x2F;springcloud-config.git</span><br><span class="line">          search-paths:</span><br><span class="line">            - springcloud-config</span><br><span class="line">      label: master</span><br><span class="line">  rabbitmq: #mq相关配置</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    fetch-registry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka</span><br><span class="line"># rabbitmq相关配置，暴露bus刷新点</span><br><span class="line">management:</span><br><span class="line">  endpoints: #暴露bus刷新配置的端点</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#39;bus-refresh&#39;</span><br></pre></td></tr></table></figure><h3 id="配置读取规则"><a href="#配置读取规则" class="headerlink" title="配置读取规则"></a>配置读取规则</h3><ul><li>/{label}/{application}-{profile}.yml<ul><li><a href="http://config-3344.com:3344/master/config-dev.yml" target="_blank" rel="noopener">http://config-3344.com:3344/master/config-dev.yml</a></li></ul></li><li>/{application}-{profile}.yml<ul><li><a href="http://config-3344.com:3344/config-dev.yml：如果不写的话，默认就是从master分支上找" target="_blank" rel="noopener">http://config-3344.com:3344/config-dev.yml：如果不写的话，默认就是从master分支上找</a></li></ul></li></ul><h3 id="参数总结"><a href="#参数总结" class="headerlink" title="参数总结"></a>参数总结</h3><p>label：分支，branch</p><p>name：服务名</p><p>profiles：环境(dev/test/prod)</p><h2 id="Config客户端配置与测试"><a href="#Config客户端配置与测试" class="headerlink" title="Config客户端配置与测试"></a>Config客户端配置与测试</h2><h3 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--添加消息总线Rabbitmq支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--config--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="bootstrap-yml"><a href="#bootstrap-yml" class="headerlink" title="bootstrap.yml"></a>bootstrap.yml</h3><p>application.yml：是用户级的资源配置项</p><p>bootstrap.yml：是系统级别的，优先级更加高</p><p>Spring Cloud会创建一个Bootstrap Context，作为Spring应用的Application Context的父上下文。初始化的时候，Bootstrap Context负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的Environment。</p><p>Bootstrap属性有高优先级，默认情况下，他们不会被本地配置覆盖，Bootstrap context 和 Application Context有着不同的约定，所以新增了一个bootstrap.yml文件，保证Bootstrap Context 和 Application Context配置的分离。</p><p>要将客户端Client模块下的Application.yml文件改成bootstrap.yml这是很关键的，因为bootstrap.yml是比application.yml先加载的，bootstrap.yml优先级高于application.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 3355</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-client</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      label: master #分支名称</span><br><span class="line">      name: config #配置文件名称</span><br><span class="line">      profile: dev #读取后缀文件名，即 master分支config-dev.yml</span><br><span class="line">      uri: http:&#x2F;&#x2F;localhost:3344 #配置中心地址</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    fetch-registry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka</span><br><span class="line">#暴露监控端点</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br></pre></td></tr></table></figure><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>分布式配置的动态刷新问题？</p><ul><li>Linux运维修改Github上的配置文件内容做调整</li><li>刷新3344，发现ConfigServer配置中心立刻响应</li><li>刷新3355，发现ConfigClient客户端没有任何响应</li><li>3355没有变化除非自己重启或者重启加载</li><li>难道每次运维修改后，都需要重启？</li></ul><p>相当于直接修改Github上的配置文件，配置不会改变，这个时候就存在了分布式配置的动态刷新问题</p><h2 id="Config客户端之动态刷新"><a href="#Config客户端之动态刷新" class="headerlink" title="Config客户端之动态刷新"></a>Config客户端之动态刷新</h2><p>为了避免每次更新配置都要重启客户端微服务3355</p><h3 id="引入了动态刷新"><a href="#引入了动态刷新" class="headerlink" title="引入了动态刷新"></a>引入了动态刷新</h3><p>引入actuator监控依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--web启动器--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--监控--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>然后修改bootstrap.yml，暴露监控端点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#暴露监控端点</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br></pre></td></tr></table></figure><p>在业务类中，添加 <code>@RefreshScope</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">&#x2F;&#x2F;实现刷新功能</span><br><span class="line">@RefreshScope</span><br><span class="line">public class ConfigClientController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;config.info&#125;&quot;)</span><br><span class="line">    private String configInfo;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;configInfo&quot;)</span><br><span class="line">    public String getConfigInfo()&#123;</span><br><span class="line">        return configInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让运维人员发送一个post请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST &quot;http:&#x2F;&#x2F;localhost:3355&#x2F;actuator&#x2F;refresh&quot;</span><br></pre></td></tr></table></figure><p>然后就能够生效了，成功刷新了配置，避免了服务重启</p><p>这个方案存在问题：</p><ul><li>假设有多个微服务客户端 3355/ 3366 / 3377</li><li>每个微服务都要执行一次post请求，手动刷新？</li><li>可否广播，一次通知，处处生效？</li><li>….</li></ul><p>目前来说，暂时做不到这个，所以才有了Spring Cloud Bus，即，消息总线。</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud之服务网关Gateway</title>
      <link href="/2020/06/09/SpringCloud%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3Gateway/"/>
      <url>/2020/06/09/SpringCloud%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3Gateway/</url>
      
        <content type="html"><![CDATA[<h1 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>zuul目前已经出现了分歧，zuul  升级到 Zuul2的时候出现了内部分歧，并且导致Zuul的核心人员的离职，导致Zuul2一直跳票，等了两年，目前造成的局面是Zuul已经没人维护，Zuul2一直在开发中</p><a id="more"></a><p>目前主流的服务网关采用的是Spring Cloud 社区推出了 Gateway</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h3><p>官网：<a href="https://github.com/Netflix/zuul/wiki" target="_blank" rel="noopener">https://github.com/Netflix/zuul/wiki</a></p><blockquote><p>Zuul是所有来自设备和web站点到Netflix流媒体应用程序后端的请求的前门。作为一个边缘服务应用程序，Zuul的构建是为了支持动态路由、监视、弹性和安全性。它还可以根据需要将请求路由到多个Amazon自动伸缩组。</p></blockquote><h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><p>Cloud全家桶有个很重要的组件就是网关，在1.X版本中都是采用Zuul网关，但在2.X版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关替代Zuul，那就是SpringCloudGateway，一句话Gateway是原来Zuul 1.X 版本的替代品</p><p><img data-src="image-20200409142909500.png" alt="image"></p><p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2 和 Project Reactor等技术。Gateway旨在提供一种简单而且有效的方式来对API进行路由，以及提供一些强大的过滤器功能，例如：熔断，限流，重试等。</p><p>Spring Cloud Gateway 是Spring Cloud的一个全新项目，作为Spring Cloud生态系统中的网关，目标是替代Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 1.X非Reactor模式的老版本，而为了提高网关的性能，Spring Cloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。</p><p>Spring Cloud Gateway的目标提供统一的路由方式，且基于Filter链的方式提供了网关基本的功能，例如：安全，监控、指标 和 限流。</p><p><img data-src="image-20200409143630282.png" alt="image"></p><h3 id="能做啥"><a href="#能做啥" class="headerlink" title="能做啥"></a>能做啥</h3><ul><li>反向代理</li><li>鉴权</li><li>流量控制</li><li>熔断</li><li>日志监控</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><img data-src="image-20200409143804936.png" alt="image"></p><p>网关可以想象成是所有服务的入口</p><h3 id="为什么选用Gateway"><a href="#为什么选用Gateway" class="headerlink" title="为什么选用Gateway"></a>为什么选用Gateway</h3><p>目前已经有了Zuul了，为什么还要开发出Gateway呢？</p><p>一方面是因为Zuul 1.0已经进入了维护阶段，而且Gateway是Spring Cloud团队研发的，属于亲儿子，值得信赖，并且很多功能Zuul都没有用起来，同时Gateway也非常简单便捷</p><p>Gateway是基于异步非阻塞模型上进行开发的，性能方面不需要担心。虽然Netflix早就发布了Zuul 2.X，但是Spring Cloud没有整合计划，因为NetFlix相关组件都进入维护期，随意综合考虑Gateway是很理想的网关选择。</p><h3 id="Gateway特性"><a href="#Gateway特性" class="headerlink" title="Gateway特性"></a>Gateway特性</h3><p>基于Spring Framework 5，Project Reactor 和Spring boot 2.0 进行构建</p><ul><li>动态路由，能匹配任何请求属性</li><li>可以对路由指定Predicate（断言） 和 Filter（过滤器）</li><li>集成Hystrix的断路器功能</li><li>集成Spring Cloud服务发现功能</li><li>易于编写Predicate 和 Filter</li><li>请求限流功能</li><li>支持路径重写</li></ul><h3 id="Spring-Cloud-Gateway-和-Zuul的区别"><a href="#Spring-Cloud-Gateway-和-Zuul的区别" class="headerlink" title="Spring Cloud Gateway  和 Zuul的区别"></a>Spring Cloud Gateway  和 Zuul的区别</h3><p>在Spring Cloud Gateway Finchley正式版发布之前，Spring Cloud推荐网关是NetFlix提供的Zuul</p><ul><li>Zuul 1.X 是一个基于阻塞IO的API Gateway</li><li>Zuul 1.x 基于Servlet 2.5使用阻塞架构，它不支持任何场连接，Zuul的设计模式和Nginx比较像，每次IO操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx用C++实现，Zuul用Java实现，而JVM本身会有第一次加载较慢的情况，使得Zuul的性能较差。</li><li>Zuul 2.X理念更先进，想基于Netty非阻塞和支持长连接，但Spring Cloud目前还没有整合。Zuul 2.X的性能相比于1.X有较大提升，在性能方面，根据官方提供的基准测试，Spring Cloud Gateway的RPS（每秒请求数）是Zuul的1.6倍。</li><li>Spring Cloud Gateway建立在Spring 5，Spring Boot 2.X之上，使用非阻塞API</li><li>Spring Cloud Gateway还支持WebSocket，并且与Spring紧密集成拥有更好的开发体验。</li></ul><p>Spring Cloud 中所集成的Zuul版本，采用的是Tomcat容器，使用的还是传统的Servlet IO处理模型</p><p>Servlet的生命周期中，Servlet由Servlet Container进行生命周期管理。</p><p>Container启动时构建servlet对象，并调用servlet init()进行初始化</p><p>Container运行时接收请求，并为每个请求分配一个线程，（一般从线程池中获取空闲线程），然后调用Service</p><p>container关闭时，调用servlet destory() 销毁servlet</p><p><img data-src="image-20200409145343133.png" alt="image"></p><p>上述模式的缺点：</p><p>servlet是一个简单的网络IO模型，当请求进入Servlet container时，servlet container就会为其绑定一个线程，在并发不高的场景下，这种网络模型是适用的，但是一旦高并发（Jmeter测试），线程数就会上涨，而线程资源代价是昂贵的（上下文切换，内存消耗大），严重影响了请求的处理时间。在一些简单业务场景下，不希望为每个Request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下Servlet模型没有优势。</p><p>所以Zuul 1.X是基于Servlet之上的一种阻塞式锤模型，即Spring实现了处理所有request请求的Servlet（DispatcherServlet）并由该Servlet阻塞式处理，因此Zuul 1.X无法摆脱Servlet模型的弊端</p><h3 id="WebFlux框架"><a href="#WebFlux框架" class="headerlink" title="WebFlux框架"></a>WebFlux框架</h3><p>传统的Web框架，比如Struts2，Spring MVC等都是基于Servlet API 与Servlet容器基础之上运行的，但是在Servlet 3.1之后有了异步非阻塞的支持，而WebFlux是一个典型的非阻塞异步的框架，它的核心是基于Reactor的相关API实现的，相对于传统的Web框架来说，它可以运行在如 Netty，Undertow 及支持Servlet3.1的容器上。非阻塞式 + 函数式编程（Spring5必须让你使用Java8）</p><p>Spring WebFlux是Spring 5.0引入的新的响应式框架，区别与Spring MVC，他不依赖Servlet API，它是完全异步非阻塞的，并且基于Reactor来实现响应式流规范。</p><h2 id="三大核心概念"><a href="#三大核心概念" class="headerlink" title="三大核心概念"></a>三大核心概念</h2><h3 id="Route-路由"><a href="#Route-路由" class="headerlink" title="Route 路由"></a>Route 路由</h3><p>路由就是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为True则匹配该路由</p><h3 id="Predicate-断言"><a href="#Predicate-断言" class="headerlink" title="Predicate 断言"></a>Predicate 断言</h3><p>参考的Java8的 <code>java.util.function.Predicate</code></p><p>开发人员可以匹配HTTP请求中的所有内容，例如请求头和请求参数，如果请求与断言想匹配则进行路由</p><h3 id="Filter-过滤"><a href="#Filter-过滤" class="headerlink" title="Filter 过滤"></a>Filter 过滤</h3><p>指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。</p><h2 id="Gateway工作流程"><a href="#Gateway工作流程" class="headerlink" title="Gateway工作流程"></a>Gateway工作流程</h2><p>Web请求通过一些匹配条件，定位到真正的服务节点，并在这个转发过程的前后，进行了一些精细化的控制。</p><p>Predicate就是我们的匹配条件，而Filter就可以理解为一个无所不能的拦截器，有了这两个元素，在加上目标URL，就可以实现一个具体的路由了。</p><p><img data-src="image-20200409152623392.png" alt="image"></p><p>客户端向Spring Cloud Gateway发出请求，然后在Gateway Handler Mapping中找到与请求相匹配的路由，将其发送到Gateway Web Handler。</p><p>Handler在通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。</p><p>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求前（pre）或之后（post）执行业务逻辑。</p><p><img data-src="image-20200409153225014.png" alt="image"></p><p>Filter在 Pre 类型的过滤器可以做参数校验，权限校验，流量监控，日志输出，协议转换等。</p><p>在 Post类型的过滤器中可以做响应内容，响应头的修改，日志的输出，流量监控等有着非常重要的作用。</p><p>Gateway的核心逻辑：路由转发 + 执行过滤链</p><h2 id="入门配置"><a href="#入门配置" class="headerlink" title="入门配置"></a>入门配置</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="修改YML"><a href="#修改YML" class="headerlink" title="修改YML"></a>修改YML</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名称进行路由</span><br><span class="line">      routes:</span><br><span class="line">        - id: payment_route # 路由的id,没有规定规则但要求唯一,建议配合服务名</span><br><span class="line">          #匹配后提供服务的路由地址</span><br><span class="line">          #uri: http:&#x2F;&#x2F;localhost:8001</span><br><span class="line">          uri: lb:&#x2F;&#x2F;CLOUD-PAYMENT-SERVICE</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;payment&#x2F;get&#x2F;** # 断言，路径相匹配的进行路由</span><br><span class="line">        - id: payment_route2</span><br><span class="line">          #uri: http:&#x2F;&#x2F;localhost:8001</span><br><span class="line">          uri: lb:&#x2F;&#x2F;CLOUD-PAYMENT-SERVICE</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;payment&#x2F;lb&#x2F;** #断言,路径相匹配的进行路由</span><br><span class="line">            - After&#x3D;2020-03-09T22:40:37.365+08:00[Asia&#x2F;Shanghai]</span><br></pre></td></tr></table></figure><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>在添加网关之前，我们的访问是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8001&#x2F;payment&#x2F;get&#x2F;31</span><br></pre></td></tr></table></figure><p>添加网关之后，我们的访问路径是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:9527&#x2F;payment&#x2F;get&#x2F;31</span><br></pre></td></tr></table></figure><p>这么做的好处是慢慢淡化我们真实的IP端口号</p><h3 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h3><p><img data-src="image-20200409154741550.png" alt="image"></p><h3 id="路由配置的两种方式"><a href="#路由配置的两种方式" class="headerlink" title="路由配置的两种方式"></a>路由配置的两种方式</h3><ul><li>在配置文件yml中配置</li><li>代码中注入RouteLocator的Bean</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class GateWayConfig &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 配置了一个id为route-name的路由规则，当访问地址 http:&#x2F;&#x2F;localhost:9527&#x2F;guonei时，会自动转发到</span><br><span class="line">&#x2F;&#x2F; 地址 http;&#x2F;&#x2F;news.baidu.com&#x2F;guonei</span><br><span class="line">    @Bean</span><br><span class="line">    public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder)&#123;</span><br><span class="line">        RouteLocatorBuilder.Builder routes &#x3D; routeLocatorBuilder.routes();</span><br><span class="line">        routes.route(&quot;path route atguigu&quot;,</span><br><span class="line">                r -&gt;r.path(&quot;&#x2F;guonei&quot;).uri(&quot;https:&#x2F;&#x2F;www.baidu.com&quot;)).build();</span><br><span class="line">        return routes.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过微服务名实现动态路由"><a href="#通过微服务名实现动态路由" class="headerlink" title="通过微服务名实现动态路由"></a>通过微服务名实现动态路由</h2><p>默认情况下Gateway会根据注册中心的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能。</p><p>首先需要开启从注册中心动态创建路由的功能，利用微服务名进行路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名称进行路由</span><br></pre></td></tr></table></figure><p>URL换成服务名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uri: lb:&#x2F;&#x2F;CLOUD-PAYMENT-SERVICE</span><br></pre></td></tr></table></figure><h2 id="Predicate的使用"><a href="#Predicate的使用" class="headerlink" title="Predicate的使用"></a>Predicate的使用</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>断言，路径相匹配的进行路由</p><p><img data-src="image-20200409160651792.png" alt="image"></p><p>Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping基础架构的一部分</p><p>Spring Cloud Gateway包括许多内置的Route Predicate 工厂，所有这些Predicate都与Http请求的不同属性相匹配，多个Route Predicate工厂可以进行组合</p><p>Spring Cloud Gateway创建Route对象时，使用RoutePredicateFactory创建Predicate对象，Predicate对象可以赋值给Route，SpringCloudGateway包含许多内置的RoutePredicateFactores。</p><p>所有这些谓词都匹配Http请求的不同属性。多种谓词工厂可以组合，并通过逻辑 and</p><p><img data-src="image-20200409161216925.png" alt="image"></p><h3 id="常用的Predicate"><a href="#常用的Predicate" class="headerlink" title="常用的Predicate"></a>常用的Predicate</h3><ul><li><p>After Route Predicate：在什么时间之后执行</p><p><img data-src="image-20200409161713254.png" alt="image"></p></li></ul><ul><li><p>Before Route Predicate：在什么时间之前执行</p></li><li><p>Between Route Predicate：在什么时间之间执行</p></li><li><p>Cookie  Route Predicate：Cookie级别</p><p>常用的测试工具：</p><ul><li>jmeter</li><li>postman</li><li>curl</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; curl命令进行测试，携带Cookie</span><br><span class="line">curl http:&#x2F;&#x2F;localhost:9527&#x2F;payment&#x2F;lb --cookie &quot;username&#x3D;zzyy&quot;</span><br></pre></td></tr></table></figure></li><li><p>Header  Route Predicate：携带请求头</p></li><li><p>Host  Route Predicate：什么样的URL路径过来</p></li><li><p>Method  Route Predicate：什么方法请求的，Post，Get</p></li><li><p>Path  Route Predicate：请求什么路径     <code>- Path=/api-web/**</code></p></li><li><p>Query  Route Predicate：带有什么参数的</p></li></ul><h2 id="Filter的使用"><a href="#Filter的使用" class="headerlink" title="Filter的使用"></a>Filter的使用</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用</p><p>Spring Cloud Gateway内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生的</p><h3 id="Spring-Cloud-Gateway-Filter"><a href="#Spring-Cloud-Gateway-Filter" class="headerlink" title="Spring Cloud Gateway Filter"></a>Spring Cloud Gateway Filter</h3><p>生命周期：only Two：pre，Post</p><p>种类：Only Two</p><ul><li>GatewayFilter</li><li>GlobalFilter</li></ul><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p>主要作用：</p><ul><li>全局日志记录</li><li>统一网关鉴权</li></ul><p>需要实现接口：<code>implements GlobalFilter, Ordered</code></p><p>全局过滤器代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class MyLogGateWayFilter implements GlobalFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        log.info(&quot;come in global filter: &#123;&#125;&quot;, new Date());</span><br><span class="line"></span><br><span class="line">        ServerHttpRequest request &#x3D; exchange.getRequest();</span><br><span class="line">        String uname &#x3D; request.getQueryParams().getFirst(&quot;uname&quot;);</span><br><span class="line">        if (uname &#x3D;&#x3D; null) &#123;</span><br><span class="line">            log.info(&quot;用户名为null，非法用户&quot;);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            return exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 放行</span><br><span class="line">        return chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 过滤器加载的顺序 越小,优先级别越高</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud之Hystrix实现服务降级和熔断</title>
      <link href="/2020/06/06/SpringCloud%E4%B9%8BHystrix%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E5%92%8C%E7%86%94%E6%96%AD/"/>
      <url>/2020/06/06/SpringCloud%E4%B9%8BHystrix%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E5%92%8C%E7%86%94%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="Hystrix断路器"><a href="#Hystrix断路器" class="headerlink" title="Hystrix断路器"></a>Hystrix断路器</h1><p>Hystrix官宣停更，官方推荐使用：resilence4j替换，同时国内Spring Cloud Alibaba 提出了Sentinel实现熔断和限流</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="分布式面临的问题"><a href="#分布式面临的问题" class="headerlink" title="分布式面临的问题"></a>分布式面临的问题</h3><p>复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败（网络卡顿，网络超时）</p><p><img data-src="image-20200408192644381.png" alt="image"></p><h3 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h3><p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的 雪崩效应</p><p>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其它系统资源紧张，导致整个系统发生更多的级联故障，这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</p><p>通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩</p><h3 id="HyStrix的诞生"><a href="#HyStrix的诞生" class="headerlink" title="HyStrix的诞生"></a>HyStrix的诞生</h3><p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</p><p>断路器 本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似于熔断保险丝），向调用方返回一个符合预期的，可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中蔓延，乃至雪崩。</p><h3 id="Hystrix作用"><a href="#Hystrix作用" class="headerlink" title="Hystrix作用"></a>Hystrix作用</h3><ul><li>服务降级</li><li>服务熔断</li><li>接近实时的监控（Hystrix Dashboard）</li><li>。。。。</li></ul><h2 id="Hystrix重要概念"><a href="#Hystrix重要概念" class="headerlink" title="Hystrix重要概念"></a>Hystrix重要概念</h2><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>fallback，假设对方服务不可用了，那么至少需要返回一个兜底的解决方法，即向服务调用方返回一个符合预期的，可处理的备选响应。</p><p>例如：服务繁忙，请稍后再试，不让客户端等待并立刻返回一个友好的提示，fallback</p><p><strong>哪些情况会触发降级</strong></p><ul><li>程序运行异常</li><li>超时</li><li>服务熔断触发服务降级</li><li>线程池/信号量打满也会导致服务降级</li></ul><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>break，类比保险丝达到了最大服务访问后，直接拒绝访问，拉闸断电，然后调用服务降级的方法并返回友好提示</p><p>一般过程：服务降级 -&gt; 服务熔断 -&gt; 恢复调用链路</p><h3 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h3><p>flowlimit，秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</p><h2 id="Hystrix案例"><a href="#Hystrix案例" class="headerlink" title="Hystrix案例"></a>Hystrix案例</h2><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--hystrix--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="启动类添加Hystrix注解"><a href="#启动类添加Hystrix注解" class="headerlink" title="启动类添加Hystrix注解"></a>启动类添加Hystrix注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableCircuitBreaker</span><br><span class="line">public class PaymentHystrixMain8001 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 此配置是为了服务监控而配置，与服务容错本身无观，springCloud 升级之后的坑</span><br><span class="line">     * ServletRegistrationBean因为springboot的默认路径不是&#x2F;hystrix.stream</span><br><span class="line">     * 只要在自己的项目中配置上下面的servlet即可</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean getServlet()&#123;</span><br><span class="line">        HystrixMetricsStreamServlet streamServlet &#x3D; new HystrixMetricsStreamServlet();</span><br><span class="line">        ServletRegistrationBean&lt;HystrixMetricsStreamServlet&gt; registrationBean &#x3D; new ServletRegistrationBean&lt;&gt;(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(1);</span><br><span class="line">        registrationBean.addUrlMappings(&quot;&#x2F;hystrix.stream&quot;);</span><br><span class="line">        registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);</span><br><span class="line">        return registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class PaymentService &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 正常访问</span><br><span class="line">     *</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String paymentInfo_OK(Integer id) &#123;</span><br><span class="line">        return &quot;线程池:&quot; + Thread.currentThread().getName() + &quot; paymentInfo_OK,id:&quot; + id + &quot;\t&quot; + &quot;O(∩_∩)O哈哈~&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 超时访问</span><br><span class="line">     *</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @HystrixCommand(fallbackMethod &#x3D; &quot;paymentInfo_TimeOutHandler&quot;, commandProperties &#x3D; &#123;</span><br><span class="line">            @HystrixProperty(name &#x3D; &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value &#x3D; &quot;5000&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    public String paymentInfo_TimeOut(Integer id) &#123;</span><br><span class="line">        int timeNumber &#x3D; 3;</span><br><span class="line">        try &#123; TimeUnit.SECONDS.sleep(timeNumber); &#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">        return &quot;线程池:&quot; + Thread.currentThread().getName() + &quot; paymentInfo_TimeOut,id:&quot; + id + &quot;\t&quot; +</span><br><span class="line">                &quot;O(∩_∩)O哈哈~  耗时(秒)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String paymentInfo_TimeOutHandler(Integer id)&#123;</span><br><span class="line">        return &quot;线程池:&quot; + Thread.currentThread().getName() + &quot; 8001系统繁忙请稍后再试！！,id:&quot; + id + &quot;\t&quot;+&quot;我哭了！！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;服务熔断，上方是降级</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 在10秒窗口期中10次请求有6次是请求失败的,断路器将起作用</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @HystrixCommand(</span><br><span class="line">            fallbackMethod &#x3D; &quot;paymentCircuitBreaker_fallback&quot;, commandProperties &#x3D; &#123;</span><br><span class="line">            @HystrixProperty(name &#x3D; &quot;circuitBreaker.enabled&quot;, value &#x3D; &quot;true&quot;),&#x2F;&#x2F; 是否开启断路器</span><br><span class="line">            @HystrixProperty(name &#x3D; &quot;circuitBreaker.requestVolumeThreshold&quot;, value &#x3D; &quot;10&quot;),&#x2F;&#x2F; 请求次数</span><br><span class="line">            @HystrixProperty(name &#x3D; &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value &#x3D; &quot;10000&quot;),&#x2F;&#x2F; 时间窗口期&#x2F;时间范文</span><br><span class="line">            @HystrixProperty(name &#x3D; &quot;circuitBreaker.errorThresholdPercentage&quot;, value &#x3D; &quot;60&quot;)&#x2F;&#x2F; 失败率达到多少后跳闸</span><br><span class="line">    &#125;</span><br><span class="line">    )</span><br><span class="line">    public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id) &#123;</span><br><span class="line">        if (id &lt; 0) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;*****id不能是负数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        String serialNumber &#x3D; IdUtil.simpleUUID();</span><br><span class="line">        return Thread.currentThread().getName() + &quot;\t&quot; + &quot;调用成功,流水号:&quot; + serialNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String paymentCircuitBreaker_fallback(@PathVariable(&quot;id&quot;) Integer id) &#123;</span><br><span class="line">        return &quot;id 不能负数,请稍后重试,o(╥﹏╥)o id:&quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高并发测试"><a href="#高并发测试" class="headerlink" title="高并发测试"></a>高并发测试</h3><p>Jmeter高并发测试</p><p>我们创建20000个线程去访问</p><p><img data-src="image-20200408202319733.png" alt="image3"></p><p>访问刚刚我们写的两个 延时接口</p><p><img data-src="image-20200408202400666.png" alt="image"></p><p>我们会发现当线程多的时候，会直接卡死，甚至把其它正常的接口都已经拖累</p><p>这是因为我们使用20000个线程去访问那个延时的接口，这样会把该微服务的资源全部集中处理 延时接口，而导致正常的接口资源不够，出现卡顿的现象。</p><p>同时tomcat的默认工作线程数被打满，没有多余的线程来分解压力和处理。</p><h3 id="服务消费者加入"><a href="#服务消费者加入" class="headerlink" title="服务消费者加入"></a>服务消费者加入</h3><p>刚刚我们能够看到，光是调用服务提供者就不能支持20000的并发量，这个时候，在使用服务消费者的引入，同时请求该接口，这个时候我们就需要在服务消费端设置服务降级了</p><p>首先启动 hystrix，@EnableHystrix</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@EnableFeignClients</span><br><span class="line">@EnableHystrix</span><br><span class="line">public class OrderHystrixMain80 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(OrderHystrixMain80.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    fetch-registry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka</span><br><span class="line">  # 设置feign客户端超时时间(OpenFeign默认支持ribbon)</span><br><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure><p>最后我们在feign调用上增加 fallBack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@FeignClient(value &#x3D; &quot;cloud-provider-hystrix-payment&quot;, fallback &#x3D; PaymentFallbackService.class)</span><br><span class="line">public interface PaymentHystrixService &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 正常访问</span><br><span class="line">     *</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 超时访问</span><br><span class="line">     *</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时fallback的方法为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class PaymentFallbackService implements PaymentHystrixService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String paymentInfo_OK(Integer id) &#123;</span><br><span class="line">        return &quot;--- PaymentFallbackService  fall  paymentInfo_OK vack ，&#x2F;(ㄒoㄒ)&#x2F;~~&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String paymentInfo_TimeOut(Integer id) &#123;</span><br><span class="line">        return &quot;--- PaymentFallbackService  fall  paymentInfo_TimeOut， &#x2F;(ㄒoㄒ)&#x2F;~~&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>超时导致服务器变慢，超时不再等待</p><p>出错，宕机或者程序运行出错，出错要有兜底</p><p>解决</p><ul><li>对方服务8001超时了，调用者80不能一直卡死等待，必须有服务降级</li><li>对方服务8001宕机了，调用者80不能一直卡死，必须有服务降级</li><li>对方服务8001正常，调用者自己出故障或者有自我要求（自己的等待时间小于服务提供者），自己处理降级</li></ul><h3 id="服务降级-1"><a href="#服务降级-1" class="headerlink" title="服务降级"></a>服务降级</h3><p>使用新的注解 <code>@HystrixCommand</code></p><p>同时需要在主启动类上新增：<code>@EnableCircuiteBreaker</code></p><p>设置8001自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作为服务降级fallback</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 超时访问</span><br><span class="line"> *</span><br><span class="line"> * @param id</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@HystrixCommand(fallbackMethod &#x3D; &quot;paymentInfo_TimeOutHandler&quot;, commandProperties &#x3D; &#123;</span><br><span class="line">        @HystrixProperty(name &#x3D; &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value &#x3D; &quot;3000&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">public String paymentInfo_TimeOut(Integer id) &#123;</span><br><span class="line">    int timeNumber &#x3D; 3;</span><br><span class="line">    try &#123; TimeUnit.SECONDS.sleep(timeNumber); &#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">    return &quot;线程池:&quot; + Thread.currentThread().getName() + &quot; paymentInfo_TimeOut,id:&quot; + id + &quot;\t&quot; +</span><br><span class="line">            &quot;O(∩_∩)O哈哈~  耗时(秒)&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 兜底的解决方案</span><br><span class="line"> * @param id</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public String paymentInfo_TimeOutHandler(Integer id)&#123;</span><br><span class="line">    return &quot;线程池:&quot; + Thread.currentThread().getName() + &quot; 8001系统繁忙请稍后再试！！,id:&quot; + id + &quot;\t&quot;+&quot;我哭了！！&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的方法就是当在规定的5秒内没有完成，那么就会触发服务降级，返回一个兜底的解决方案</p><p>同时不仅是超时，假设服务内的方法出现了异常，也同样会触发兜底的解决方法，例如下面的代码，我们制造出一个除数为0的异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod &#x3D; &quot;paymentInfo_TimeOutHandler&quot;, commandProperties &#x3D; &#123;</span><br><span class="line">        @HystrixProperty(name &#x3D; &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value &#x3D; &quot;3000&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">public String paymentInfo_TimeOut(Integer id) &#123;</span><br><span class="line">    int timeNumber &#x3D; 10 &#x2F; 0;</span><br><span class="line">    return &quot;线程池:&quot; + Thread.currentThread().getName() + &quot; paymentInfo_TimeOut,id:&quot; + id + &quot;\t&quot; +</span><br><span class="line">            &quot;O(∩_∩)O哈哈~  耗时(秒)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述说的是服务提供方的降级，服务消费者也需要设置服务降级的处理保护，也就是对客户端进行保护</p><p>也就是说服务降级，既可以放在客户端，也可以放在服务端，一般而言是放在客户端进行服务降级的</p><p>首先主启动类设置：<code>@EnableHystrix</code></p><blockquote><p>配置过的devtool热部署对java代码的改动明显，但是对@HystrixCommand内属性的修改建议重启微服务</p></blockquote><p>然后yml开启hystrix</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure><p>服务消费端降级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">@HystrixCommand(fallbackMethod &#x3D; &quot;paymentTimeOutFallbackMethod&quot;, commandProperties &#x3D; &#123;</span><br><span class="line">        @HystrixProperty(name &#x3D; &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value &#x3D; &quot;1500&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id) &#123;</span><br><span class="line">    return paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>目前问题</strong></p><p>目前异常处理的方法，和业务代码耦合，这就造成耦合度比较高</p><p>解决方法就是使用统一的服务降级方法</p><p><strong>方法1：</strong></p><p>除了个别重要核心业务有专属，其它普通的可以通过<code>@DefaultProperties(defaultFallback = &quot;&quot;)</code>，这样通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量</p><p>可以在Controller处设置 <code>@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@Slf4j</span><br><span class="line">@DefaultProperties(defaultFallback &#x3D; &quot;payment_Global_FallbackMethod&quot;)</span><br><span class="line">public class OrderHystrixController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    @HystrixCommand  &#x2F;&#x2F; 这个方法也会走全局 fallback</span><br><span class="line">    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id) &#123;</span><br><span class="line">        int age &#x3D; 10&#x2F;0; &#x2F;&#x2F;方法前挂了，跟后面挂了两种</span><br><span class="line">        return paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;下面是全局fallback方法</span><br><span class="line">    public String payment_Global_FallbackMethod()&#123;</span><br><span class="line">        return &quot;Global异常处理信息，请稍后再试,&#x2F;(ㄒoㄒ)&#x2F;~~&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法2：</strong></p><p>我们现在还发现，兜底的方法 和 我们的业务代码耦合在一块比较混乱</p><p>我们可以在feign调用的时候，增加hystrix的服务降级处理的实现类，这样就可以进行解耦</p><p>格式：<code>@FeignClient(fallback = PaymentFallbackService.class)</code></p><p>我们要面对的异常主要有</p><ul><li>运行</li><li>超时</li><li>宕机</li></ul><p>需要新建一个FallbackService实现类，然后通过实现类统一为feign接口里面的方法进行异常处理</p><p>feign接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@FeignClient(value &#x3D; &quot;cloud-provider-hystrix-payment&quot;, fallback &#x3D; PaymentFallbackService.class)</span><br><span class="line">public interface PaymentHystrixService &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 正常访问</span><br><span class="line">     *</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public String paymentInfo_OK(@PathVariable(&quot;id&quot;) Integer id);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 超时访问</span><br><span class="line">     *</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public String paymentInfo_TimeOut(@PathVariable(&quot;id&quot;) Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class PaymentFallbackService implements PaymentHystrixService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String paymentInfo_OK(Integer id) &#123;</span><br><span class="line">        return &quot;--- PaymentFallbackService  fall  paymentInfo_OK vack ，&#x2F;(ㄒoㄒ)&#x2F;~~&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String paymentInfo_TimeOut(Integer id) &#123;</span><br><span class="line">        return &quot;--- PaymentFallbackService  fall  paymentInfo_TimeOut， &#x2F;(ㄒoㄒ)&#x2F;~~&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，如果我们将服务提供方进行关闭，但是我们在客户端做了服务降级处理，让客户端在服务端不可用时，也会获得提示信息，而不会挂起耗死服务器</p><h3 id="服务熔断-1"><a href="#服务熔断-1" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>服务熔断也是服务降级的一个 特例</p><h4 id="熔断概念"><a href="#熔断概念" class="headerlink" title="熔断概念"></a>熔断概念</h4><p>熔断机制是应对雪崩效应的一种微服务链路保护机制，当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应状态</p><p>当检测到该节点微服务调用响应正常后，恢复调用链路</p><p>在Spring Cloud框架里，熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定的阈值，缺省是5秒内20次调用失败，就会启动熔断机制，熔断机制的注解还是 <code>@HystrixCommand</code></p><p>来源，微服务提出者马丁福勒：<a href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_blank" rel="noopener">https://martinfowler.com/bliki/CircuitBreaker.html</a></p><blockquote><p>这个简单的断路器避免了在电路打开时进行保护调用，但是当情况恢复正常时需要外部干预来重置它。对于建筑物中的断路器，这是一种合理的方法，但是对于软件断路器，我们可以让断路器本身检测底层调用是否再次工作。我们可以通过在适当的间隔之后再次尝试protected调用来实现这种自重置行为，并在断路器成功时重置它</p></blockquote><p><img data-src="image-20200409095855788.png" alt="image"></p><p>熔断器的三种状态：打开，关闭，半开</p><p>这里提出了 半开的概念，首先打开一半的，然后慢慢的进行恢复，最后在把断路器关闭</p><p>降级 -&gt; 熔断 -&gt; 恢复</p><p>这里我们在服务提供方 8001，增加服务熔断</p><p>这里有四个字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 是否开启断路器</span><br><span class="line">@HystrixProperty(name &#x3D; &quot;circuitBreaker.enabled&quot;, value &#x3D; &quot;true&quot;),</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 请求次数</span><br><span class="line">@HystrixProperty(name &#x3D; &quot;circuitBreaker.requestVolumeThreshold&quot;, value &#x3D; &quot;10&quot;),</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 时间窗口期&#x2F;时间范文</span><br><span class="line">@HystrixProperty(name &#x3D; &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value &#x3D; &quot;10000&quot;),</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 失败率达到多少后跳闸</span><br><span class="line">@HystrixProperty(name &#x3D; &quot;circuitBreaker.errorThresholdPercentage&quot;, value &#x3D; &quot;60&quot;)</span><br></pre></td></tr></table></figure><p>首先是是否开启熔断器，然后是在一个时间窗口内，有60%的失败，那么就启动断路器，也就是10次里面，6次失败，完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 在10秒窗口期中10次请求有6次是请求失败的,断路器将起作用</span><br><span class="line"> * @param id</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">@HystrixCommand(</span><br><span class="line">        fallbackMethod &#x3D; &quot;paymentCircuitBreaker_fallback&quot;, commandProperties &#x3D; &#123;</span><br><span class="line">        @HystrixProperty(name &#x3D; &quot;circuitBreaker.enabled&quot;, value &#x3D; &quot;true&quot;),&#x2F;&#x2F; 是否开启断路器</span><br><span class="line">        @HystrixProperty(name &#x3D; &quot;circuitBreaker.requestVolumeThreshold&quot;, value &#x3D; &quot;10&quot;),&#x2F;&#x2F; 请求次数</span><br><span class="line">        @HystrixProperty(name &#x3D; &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value &#x3D; &quot;10000&quot;),&#x2F;&#x2F; 时间窗口期&#x2F;时间范文</span><br><span class="line">        @HystrixProperty(name &#x3D; &quot;circuitBreaker.errorThresholdPercentage&quot;, value &#x3D; &quot;60&quot;)&#x2F;&#x2F; 失败率达到多少后跳闸</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id) &#123;</span><br><span class="line">    if (id &lt; 0) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;*****id不能是负数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    String serialNumber &#x3D; IdUtil.simpleUUID();</span><br><span class="line">    return Thread.currentThread().getName() + &quot;\t&quot; + &quot;调用成功,流水号:&quot; + serialNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当断路器被打开的时候，即使是正确的请求，该方法也会被断路</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="熔断类型"><a href="#熔断类型" class="headerlink" title="熔断类型"></a>熔断类型</h4><ul><li>熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR（平均故障处理时间），当打开时长达所设时钟则进入半熔断状态</li><li>熔断关闭：熔断关闭不会对服务进行熔断</li><li>熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则，则认为当前服务恢复正常，关闭熔断</li></ul><h4 id="断路器启动条件"><a href="#断路器启动条件" class="headerlink" title="断路器启动条件"></a>断路器启动条件</h4><p><img data-src="image-20200409114527145.png" alt="image"></p><p>涉及到断路器的三个重要参数：快照时间窗，请求总阈值，错误百分比阈值</p><ul><li>快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</li><li>请求总数阈值：在快照时间窗口内，必须满足请求总数阈值才有资格熔断。默认为20，意味着在10秒内，如果hystrix的调用总次数不足20次，即使所有请求都超时或者其他原因失败，断路器都不会打开。</li><li>错误百分比阈值：当请求总数在快照时间窗内超过了阈值，比如发生了30次调用，并且有15次发生了超时异常，也就是超过了50的错误百分比，在默认设定的50%阈值情况下，这时候就会将断路器打开</li></ul><p>开启和关闭的条件</p><ul><li>当满足一定阈值的时候（默认10秒内超过20个请求）</li><li>当失败率达到一定的时候（默认10秒内超过50%的请求失败）</li><li>到达以上阈值，断路器将会开启 </li><li>当开启的时候，所有请求都不会进行转发</li><li>一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启，重复4和5</li></ul><p>断路器开启后</p><ul><li>再有请求调用的时候，将不会调用主逻辑，而是直接调用降级fallback，通过断路器，实现了自动的发现错误并将降级逻辑切换为主逻辑，减少相应延迟的效果。</li><li>原来的主逻辑如何恢复？<ul><li>对于这个问题，Hystrix实现了自动恢复功能，当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续保持打开状态，休眠时间窗重新计时。</li></ul></li></ul><h3 id="服务限流-1"><a href="#服务限流-1" class="headerlink" title="服务限流"></a>服务限流</h3><p>后面讲解Sentinel的时候进行说明</p><h2 id="Hystrix工作流程"><a href="#Hystrix工作流程" class="headerlink" title="Hystrix工作流程"></a>Hystrix工作流程</h2><p><img data-src="image-20200409120112552.png" alt="image"></p><p>蓝色：调用路径</p><p>红色：返回路径</p><p>完整的请求路线：</p><ol><li>选择一个Hystrix注册方式</li><li>二选一即可</li><li>判断缓存中是否包含需要返回的内容（如果有直接返回）</li><li>断路器是否为打开状态（如果是，直接跳转到8，返回）</li><li>断路器为健康状态，判断是否有可用资源（没有，直接跳转8）</li><li>构造方法和Run方法</li><li>将正常，超时，异常的消息发送给断路器</li><li>调用getFallback方法，也就是服务降级</li><li>直接返回正确结果</li></ol><h2 id="服务监控HystrixDashboard"><a href="#服务监控HystrixDashboard" class="headerlink" title="服务监控HystrixDashboard"></a>服务监控HystrixDashboard</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控（Hystrix Dashboard），Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形化的形式展示给用户，包括每秒执行多少请求，成功多少请求，失败多少，Netflix通过Hystrix-metrics-event-stream项目实现了对以上指标的监控，SpringCloud也提供了HystrixDashboard整合，对监控内容转化成可视化页面</p><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>引入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--hystrix dashboard--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--监控--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>application.yml添加端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9001</span><br></pre></td></tr></table></figure><p>主启动类：配置注解<code>@EnableHystrixDashboard</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableHystrixDashboard</span><br><span class="line">public class HystrixDashboardMain9001 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(HystrixDashboardMain9001.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，最后我们需要注意，每个服务类想要被监控的，都需要在pom文件中，添加一下注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--监控--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>同时在服务提供者的启动类上，需要添加以下的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableCircuitBreaker</span><br><span class="line">public class PaymentHystrixMain8001 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 此配置是为了服务监控而配置，与服务容错本身无观，springCloud 升级之后的坑</span><br><span class="line">     * ServletRegistrationBean因为springboot的默认路径不是&#x2F;hystrix.stream</span><br><span class="line">     * 只要在自己的项目中配置上下面的servlet即可</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean getServlet()&#123;</span><br><span class="line">        HystrixMetricsStreamServlet streamServlet &#x3D; new HystrixMetricsStreamServlet();</span><br><span class="line">        ServletRegistrationBean&lt;HystrixMetricsStreamServlet&gt; registrationBean &#x3D; new ServletRegistrationBean&lt;&gt;(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(1);</span><br><span class="line">        registrationBean.addUrlMappings(&quot;&#x2F;hystrix.stream&quot;);</span><br><span class="line">        registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);</span><br><span class="line">        return registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入以下地址，进入Hystrix的图形化界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:9001&#x2F;hystrix</span><br></pre></td></tr></table></figure><p><img data-src="image-20200409121425718.png" alt="image"></p><h3 id="使用监控"><a href="#使用监控" class="headerlink" title="使用监控"></a>使用监控</h3><p>我们需要使用当前hystrix需要监控的端口号，也就是使用 9001 去监控 8001，即使用hystrix dashboard去监控服务提供者的端口号</p><p><img data-src="image-20200409122102137.png" alt="image"></p><p>然后我们运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8001&#x2F;payment&#x2F;circuit&#x2F;31</span><br></pre></td></tr></table></figure><p>就能够发现Hystrix Dashboard能够检测到我们的请求</p><p><img data-src="image-20200409122312059.png" alt="image"></p><p>假设我们访问错误的方法后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8001&#x2F;payment&#x2F;circuit&#x2F;-31</span><br></pre></td></tr></table></figure><p>我们能够发现，此时断路器处于开启状态，并且错误率百分100</p><p><img data-src="image-20200409122448651.png" alt="image"></p><p>如何看懂图</p><p>首先是七种颜色</p><p><img data-src="image-20200409122754448.png" alt="image"></p><p>每个颜色都对应的一种结果</p><p><img data-src="image-20200409122820328.png" alt="image"></p><p>然后是里面的圆</p><p>实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，它的健康程度从</p><p>绿色 &lt; 黄色 &lt; 橙色 &lt;红色，递减</p><p>该实心圆除了颜色变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大，所以通过该实心圆的展示，就可以快速在大量的实例中快速发现故障实例和高压力实例</p><p>曲线：用于记录2分钟内流量的相对变化，可以通过它来观察到流量的上升和下降趋势</p><p><img data-src="image-20200409123214743.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Hystrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud之Ribbon实现负载均衡</title>
      <link href="/2020/06/04/SpringCloud%E4%B9%8BRibbon%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2020/06/04/SpringCloud%E4%B9%8BRibbon%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Ribbon实现负载均衡"><a href="#Ribbon实现负载均衡" class="headerlink" title="Ribbon实现负载均衡"></a>Ribbon实现负载均衡</h1><p>Ribbon目前已经进入了维护模式，但是目前主流还是使用Ribbon</p><p>Spring Cloud想通过LoadBalancer用于替换Ribbon</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端，负载均衡的工具</p><p>简单的说，Ribbon是NetFlix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供了一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。</p><h2 id="LB负载均衡是什么"><a href="#LB负载均衡是什么" class="headerlink" title="LB负载均衡是什么"></a>LB负载均衡是什么</h2><p>Load Balance，简单来说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用）。常见的负载均衡有软件Nginx，LVS，硬件F5等。</p><ul><li>集中式LB：即在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5，也可以是软件，如Nginx），由该设施负责把访问请求通过某种策略转发至服务的提供方</li><li>进程内LB：将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</li></ul><h2 id="Ribbon本地负载均衡客户端-VS-Nginx服务端负载均衡"><a href="#Ribbon本地负载均衡客户端-VS-Nginx服务端负载均衡" class="headerlink" title="Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡"></a>Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡</h2><p>Nginx是服务器负载均衡，客户端所有的请求都会交给nginx，然后由nginx实现转发请求，即负载均衡是由服务端实现的。</p><p>Ribbon本地负载均衡，在调用微服务接口的时候，会在注册中心上获取注册信息服务列表之后，缓存到JVM本地，从而在本地实现RPC远程调用的技术。</p><p>一句话就是：RIbbon = 负载均衡 + RestTemplate调用</p><h2 id="Ribbon工作原理"><a href="#Ribbon工作原理" class="headerlink" title="Ribbon工作原理"></a>Ribbon工作原理</h2><p>Ribbon其实就是一个软负载均衡的客户端组件，它可以和其它所需请求的客户端结合使用，和Eureka结合只是其中的一个实例。</p><p><img data-src="image-20200408104948953.png" alt="image"></p><p>Ribbon在工作时分成两步</p><ul><li>首先先选择EurekaServer，它优先选择在同一个区域内负载较少的Server</li><li>再根据用户的指定的策略，从Server取到服务注册列表中选择一个地址</li><li>其中Ribbon提供了多种策略：比如轮询，随机和根据响应时间加权</li></ul><h2 id="引入Ribbon"><a href="#引入Ribbon" class="headerlink" title="引入Ribbon"></a>引入Ribbon</h2><p>新版的Eureka已经默认引入Ribbon了，不需要额外引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Eureka客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><img data-src="image-20200408105549983.png" alt="image"></p><h2 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h2><p>主要方法为：</p><ul><li>reseTemplate.getForObject</li><li>reseTemplate.posttForObject</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;create&quot;)</span><br><span class="line">public CommonResult&lt;Payment&gt; create(Payment payment) &#123;</span><br><span class="line">    return restTemplate.postForObject(PAYMENT_URL + &quot;&#x2F;payment&#x2F;create&quot;, payment, CommonResult.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;get&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">public CommonResult&lt;Payment&gt; getPayment(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line">    return restTemplate.getForObject(PAYMENT_URL + &quot;&#x2F;payment&#x2F;get&#x2F;&quot; + id, CommonResult.class);</span><br><span class="line">&#125;</span><br><span class="line">@GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;getForEntity&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">public CommonResult&lt;Payment&gt; getForEntity(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line">    ResponseEntity&lt;CommonResult&gt; entity &#x3D; restTemplate.getForEntity(PAYMENT_URL + &quot;&#x2F;payment&#x2F;get&#x2F;&quot; + id, CommonResult.class);</span><br><span class="line">    if (entity.getStatusCode().is2xxSuccessful())&#123;</span><br><span class="line">        return entity.getBody();</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return new CommonResult&lt;&gt;(444,&quot;操作失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ribbon核心组件IRule"><a href="#Ribbon核心组件IRule" class="headerlink" title="Ribbon核心组件IRule"></a>Ribbon核心组件IRule</h2><p>Ribbon默认是使用轮询作为负载均衡算法</p><p>IRule根据特定算法从服务列表中选取一个要访问的服务，IRule是一个接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface IRule &#123;</span><br><span class="line">    Server choose(Object var1);</span><br><span class="line"></span><br><span class="line">    void setLoadBalancer(ILoadBalancer var1);</span><br><span class="line"></span><br><span class="line">    ILoadBalancer getLoadBalancer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对该接口，进行特定的实现</p><p><img data-src="image-20200408111538902.png" alt="image"></p><h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><p>IRule的实现主要有以下七种</p><ul><li>RoundRobinRule：轮询</li><li>RandomRule：随机</li><li>RetryRUle：先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用服务</li><li>WeightedResponseTimeRule：对RoundRobinRule的扩展，响应速度越快的实例选择的权重越大，越容易被选择</li><li>BestAvailableRule：会先过滤掉由于多次访问故障而处于短路跳闸状态的服务，然后选择一个并发量最小的服务</li><li>AvailabilityFilteringRule：先过滤掉故障实例，在选择并发较小的实例</li><li>ZoneAvoidanceRule：默认规则，符合判断server所在区域的性能和server的可用性选择服务器</li></ul><h3 id="默认负载均衡算法替换"><a href="#默认负载均衡算法替换" class="headerlink" title="默认负载均衡算法替换"></a>默认负载均衡算法替换</h3><p>官网警告：自定义的配置类不能放在@ComponentScanner所扫描的当前包下以及子包下，否者我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了</p><p><img data-src="image-20200408112458892.png" alt="image"></p><p>然后我们创建自定义Rule接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MySelfRule &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public IRule myRule()&#123;</span><br><span class="line">        return new RandomRule();&#x2F;&#x2F;自定义为随机</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主启动类中，添加<code>@RibbonClient</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@RibbonClient(name&#x3D;&quot;CLOUD-PAYMENT-SERVICE&quot;,configuration &#x3D; MySelfRule.class)</span><br><span class="line">public class OrderMain80 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写Ribbon负载均衡算法"><a href="#手写Ribbon负载均衡算法" class="headerlink" title="手写Ribbon负载均衡算法"></a>手写Ribbon负载均衡算法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>负载均衡算法：rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标，每次服务重启后rest接口计数从1开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假设现在有2台机器，同时 List &#x3D; 2 instance（也就是服务注册列表中，有两台）</span><br><span class="line">1 % 2 &#x3D; 1 -&gt; index &#x3D; list.get(1)</span><br><span class="line"></span><br><span class="line">2 % 2 &#x3D; 0 -&gt; index &#x3D; list.get(0)</span><br><span class="line"></span><br><span class="line">3 % 2 &#x3D; 1 -&gt; index &#x3D; list.get(1)</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>这就是轮询的原理，即</p><p><img data-src="image-20200408114805042.png" alt="image"></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>我们查看RandomRule的源码发现，其实内部就是利用的取余的技术，同时为了保证同步机制，还是使用了AtomicInteger原子整型类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class RandomRule extends AbstractLoadBalancerRule &#123;</span><br><span class="line">    public RandomRule() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123;&quot;RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE&quot;&#125;)</span><br><span class="line">    public Server choose(ILoadBalancer lb, Object key) &#123;</span><br><span class="line">        if (lb &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Server server &#x3D; null;</span><br><span class="line"></span><br><span class="line">            while(server &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (Thread.interrupted()) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                List&lt;Server&gt; upList &#x3D; lb.getReachableServers();</span><br><span class="line">                List&lt;Server&gt; allList &#x3D; lb.getAllServers();</span><br><span class="line">                int serverCount &#x3D; allList.size();</span><br><span class="line">                if (serverCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                int index &#x3D; this.chooseRandomInt(serverCount);</span><br><span class="line">                server &#x3D; (Server)upList.get(index);</span><br><span class="line">                if (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (server.isAlive()) &#123;</span><br><span class="line">                        return server;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    server &#x3D; null;</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return server;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected int chooseRandomInt(int serverCount) &#123;</span><br><span class="line">        return ThreadLocalRandom.current().nextInt(serverCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Server choose(Object key) &#123;</span><br><span class="line">        return this.choose(this.getLoadBalancer(), key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void initWithNiwsConfig(IClientConfig clientConfig) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写负载均衡算法"><a href="#手写负载均衡算法" class="headerlink" title="手写负载均衡算法"></a>手写负载均衡算法</h3><p>原理 + JUC（CAS+自旋锁）</p><p>首先需要在RestTemplate的配置上将 @LoadBalanced注解删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">&#x2F;&#x2F;@LoadBalanced 赋予RestTemplate负载均衡的能力</span><br><span class="line">public RestTemplate getRestTemplate() &#123;</span><br><span class="line">    return new RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个LoadBalanced接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 自定义负载均衡算法</span><br><span class="line"> * @Author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface LoadBalancer &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取注册的一个实例</span><br><span class="line">    ServiceInstance instances(List&lt;ServiceInstance&gt; serviceInstances);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个实现类，首先LoadBalanced接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyLB implements LoadBalancer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建原子整型类</span><br><span class="line">    private AtomicInteger atomicInteger &#x3D; new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取Rest调用的次数</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public final int getAndIncrement()&#123;</span><br><span class="line">        int current;</span><br><span class="line">        int next;</span><br><span class="line">        &#x2F;&#x2F; 自旋锁</span><br><span class="line">        do&#123;</span><br><span class="line">            &#x2F;&#x2F; 获取当前值</span><br><span class="line">            current&#x3D;this.atomicInteger.get();</span><br><span class="line"></span><br><span class="line">            &#x2F;*2147483647:整型最大值*&#x2F;</span><br><span class="line">            &#x2F;&#x2F; 发生越界，从0开始计数</span><br><span class="line">            next&#x3D; current &gt;&#x3D;2147483647 ? 0:current+1;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 比较并交换</span><br><span class="line">        &#125;while (!this.atomicInteger.compareAndSet(current,next));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;******第几次访问next&quot;+next);</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;负载均衡算法：第几次请求%服务器总数量&#x3D;实际访问。服务每次启动从1开始</span><br><span class="line">    @Override</span><br><span class="line">    public ServiceInstance instances(List&lt;ServiceInstance&gt; serviceInstances) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取当前计数 模  实例总数</span><br><span class="line">        int index&#x3D; getAndIncrement() % serviceInstances.size();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 返回选择的实例</span><br><span class="line">        return serviceInstances.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体使用</p><p>步骤就是，首先我们通过discoveryClient获取所有的注册实例，然后调用该实现类，获取到调用的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 在这边我为了以上程序的正常执行：把自定义接口注释掉，不用自定义负载均衡算法，若想再次启动</span><br><span class="line"> * 请操作一下步骤：</span><br><span class="line"> *          1.注释掉@LoadBalanced（在config下面），放开下方注释，同时会导致上方不可用，因为找不到具体服务</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">@GetMapping(value &#x3D; &quot;&#x2F;consumer&#x2F;payment&#x2F;lb&quot;)</span><br><span class="line">public String getPaymentLB()&#123;</span><br><span class="line">    List&lt;ServiceInstance&gt; instances &#x3D; discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);</span><br><span class="line">    if (instances &#x3D;&#x3D;null || instances.size()&lt;&#x3D;0)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;传入自己的</span><br><span class="line">    ServiceInstance serviceInstance &#x3D; loadBalancer.instances(instances);</span><br><span class="line">    URI uri &#x3D; serviceInstance.getUri();</span><br><span class="line">    return restTemplate.getForObject(uri+&quot;&#x2F;payment&#x2F;lb&quot;,String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud之Eureka停更后的替换以及CAP理论简介</title>
      <link href="/2020/06/02/SpringCloud%E4%B9%8BEureka%E5%81%9C%E6%9B%B4%E5%90%8E%E7%9A%84%E6%9B%BF%E6%8D%A2/"/>
      <url>/2020/06/02/SpringCloud%E4%B9%8BEureka%E5%81%9C%E6%9B%B4%E5%90%8E%E7%9A%84%E6%9B%BF%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Eureka停更后的替换"><a href="#Eureka停更后的替换" class="headerlink" title="Eureka停更后的替换"></a>Eureka停更后的替换</h1><p>Eureka停更后的替换有Zookeeper替换Eureka、Consul替换Eureka。</p><h2 id="Zookeeper替换Eureka"><a href="#Zookeeper替换Eureka" class="headerlink" title="Zookeeper替换Eureka"></a>Zookeeper替换Eureka</h2><h3 id="Zookeeper是什么"><a href="#Zookeeper是什么" class="headerlink" title="Zookeeper是什么"></a>Zookeeper是什么</h3><p>Zookeeper是一个分布式协调工具，可以实现注册中心功能</p><a id="more"></a><p>关闭Linux服务器防火墙后，启动Zookeeper服务器，Zookeeper服务器取代Eureka服务器，zk作为服务注册中心。</p><p><img data-src="image-20200408084706452.png" alt="image"></p><h3 id="搭建Zookeeper注册中心"><a href="#搭建Zookeeper注册中心" class="headerlink" title="搭建Zookeeper注册中心"></a>搭建Zookeeper注册中心</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--zookeeper客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;!--先排除自带的zookeeper3.5.3--&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.zookeeper&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zookeeper&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.zookeeper&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zookeeper&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.9&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>连接上Zookeeper客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-provider-payment</span><br><span class="line">  cloud:</span><br><span class="line">    zookeeper:</span><br><span class="line">      connect-string: 180.76.99.142:2181</span><br></pre></td></tr></table></figure><h4 id="修改主启动类"><a href="#修改主启动类" class="headerlink" title="修改主启动类"></a>修改主启动类</h4><p>使用<code>@EnableDiscoveryClient</code> 注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class PaymentMain8004 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8004.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>启动成功后，把服务注册进Zookeeper客户端</p><p><img data-src="image-20200408090101441.png" alt="image"></p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>服务已经成功注册到Zookeeper客户端，那么注册上去的节点被称为临时节点，还是持久节点？</p><p>首先Eureka有自我保护机制，也就是某个服务下线后，不会立刻清除该服务，而是将服务保留一段时间</p><p>Zookeeper也一样在服务下线后，会等待一段时间后，也会把该节点删除，这就说明Zookeeper上的节点是临时节点。</p><h2 id="Consul替换Eureka"><a href="#Consul替换Eureka" class="headerlink" title="Consul替换Eureka"></a>Consul替换Eureka</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>官网：<code>https://www.consul.io/</code></p><p>Consul是一套开源的分布式服务发现和配置管理系统，由HashiCorp公司用Go语言开发</p><p>提供了微服务系统中的服务治理、配置中心、控制总线等功能，这些功能中的每一个都可以根据需要单独使用，也可以一起使用构建全方位的服务网路，总之Consul提供了一种完整的服务网络解决方案。</p><p>它具有很多优点，包括：基于raft协议，比较简洁；支持健康检查，同时支持HTTP和DNS协议，支持跨数据中心的WAN集群，提供图形化界面，跨平台，支持Linux，MAC，Windows</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>服务发现：提供HTTP和DNS两种发现方式</li><li>健康监测：支持多种方法，HTTP，TCP，Docker，Shell脚本定制化</li><li>KV存储：Key，Value的存储方式</li><li>多数据中心：Consul支持多数据中心</li><li>可视化Web界面</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>官网：<code>https://www.consul.io/downloads.html</code></p><ul><li><p>查看版本：<code>consul --version</code></p></li><li><p>运行：<code>consul agent -dev</code></p></li></ul><p>运行成功后，然后访问 <code>http://localhost:8500</code>，进入consul的可视化界面</p><p><img data-src="image-20200408095337426.png" alt="image6"></p><h3 id="服务提供者注册Consul"><a href="#服务提供者注册Consul" class="headerlink" title="服务提供者注册Consul"></a>服务提供者注册Consul</h3><p>引入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--consul--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>修改yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#consul服务端口号</span><br><span class="line">server:</span><br><span class="line">  port: 8006</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consul-provider-payment</span><br><span class="line">#consul注册中心地址</span><br><span class="line">  cloud:</span><br><span class="line">    consul:</span><br><span class="line">      host: localhost</span><br><span class="line">      port: 8500</span><br><span class="line">      discovery:</span><br><span class="line">        service-name: $&#123;spring.application.name&#125;</span><br></pre></td></tr></table></figure><p>然后启动项目，即可发现服务提供者已经注册到Consul中了</p><p><img data-src="image-20200408100158576.png" alt="image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>组件名</th><th>语言</th><th>健康检查</th><th>对外暴露接口</th><th>CAP</th><th>Spring Clou集成</th></tr></thead><tbody><tr><td>Eureka</td><td>Java</td><td>可配支持</td><td>HTTP</td><td>AP</td><td>已集成</td></tr><tr><td>Consul</td><td>Go</td><td>支持</td><td>HTTP/DNS</td><td>CP</td><td>已集成</td></tr><tr><td>Zookeeper</td><td>Java</td><td>支持</td><td>客户端</td><td>CP</td><td>已集成</td></tr></tbody></table><h1 id="CAP理论简介"><a href="#CAP理论简介" class="headerlink" title="CAP理论简介"></a>CAP理论简介</h1><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>Availability：高可用</p><p>Consistency：强一致性</p><p>Partition Tolerance：分区容错性</p><p>CAP理论关注粒度是数据，而不是整体系统设计的策略</p><p>因此现在的微服务架构要么是 CP 要么是 AP，也就是P一定需要保证，最多只能较好的同时满足两个</p><p>CAP理论的核心：一个分布式系统不可能同时很好的满足：一致性，可用性和分区容错性这个三个需求</p><p>因此，根据CAP原理将NoSQL数据库分成了满足CA原则，满足CP原则，满足AP的三大类</p><ul><li>CA：单点集群，满足一致性，可用性的系统，通常在可扩展性上不太满足</li><li>CP：满足一致性，分区容忍性，通常性能不是特别高</li><li>AP：满足可用性，分区容忍性，通常对一致性要求低一些</li></ul><p><img data-src="image-20200408101128947.png" alt="image"></p><p>部分情况下，我们对数据一致性的要求没有这么高，比如蘑菇博客的点赞和浏览记录，都是每隔一段时间才写入数据库的。</p><h2 id="AP架构"><a href="#AP架构" class="headerlink" title="AP架构"></a>AP架构</h2><p>Eureka是AP架构</p><p><img data-src="image-20200408101854416.png" alt="image"></p><p>因为同步原因出现问题，而造成数据没有一致性</p><p>当出现网络分区后，为了保证高可用，系统B可以返回旧值，保证系统的可用性</p><p>结论：违背了一致性C的要求，只满足可用性和分区容错性，即AP</p><h2 id="CP架构"><a href="#CP架构" class="headerlink" title="CP架构"></a>CP架构</h2><p>Zookeeper和Consul是CP架构</p><p><img data-src="image-20200408102120317.png" alt="image"></p><p>当出现网络分区后，为了保证一致性，就必须拒绝请求，否者无法保证一致性</p><p>结论：违背了可用性A的要求，只满足一致性和分区容错性，即CP</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud之Eureka工作原理及集群搭建</title>
      <link href="/2020/05/30/SpringCloud%E4%B9%8BEureka%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/05/30/SpringCloud%E4%B9%8BEureka%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Eureka集群"><a href="#Eureka集群" class="headerlink" title="Eureka集群"></a>Eureka集群</h1><p>没有集群带来的高可用，会带来单点故障</p><h2 id="Eureka工作原理"><a href="#Eureka工作原理" class="headerlink" title="Eureka工作原理"></a>Eureka工作原理</h2><ul><li>服务注册：将服务信息注册进注册中心</li><li>服务发现：从注册中心上获取服务信息</li><li>实质：存key服务命名，取value调用地址</li></ul><a id="more"></a><ol><li>先启动eureka注册中心</li><li>启动服务提供者payment支付服务</li><li>支付服务启动后，会把自身信息（比如 服务地址以别名方式注册进eureka）</li><li>消费者order服务在调用接口时候使用服务别名去注册中心获取实际的RPC远程调用地址</li><li>消费者获得调用地址后，底层实际是利用HttpClient技术实现远程调用</li><li>消费者获取服务地址后会缓存在本地JVM内存中，默认每隔30秒更新一次服务调用地址</li></ol><p><img data-src="image-20200407214336639.png" alt="image"></p><p>微服务RPC远程调用最核心的就是：高可用</p><p>因为假设注册中心只有一个，如果出现了故障，那么将会导致整个微服务不可用，所以需要搭建Eureka注册中心集群，实现负载均衡 + 故障容错</p><h2 id="Eureka集群原理"><a href="#Eureka集群原理" class="headerlink" title="Eureka集群原理"></a>Eureka集群原理</h2><p>互相注册，相互守望</p><p><img data-src="image-20200407214903319.png" alt="image"></p><h2 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h2><p>原来单机版本时，我们的注册中心的配置文件为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7001</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost #eureka服务端实例名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false #表示不向注册中心注册自己</span><br><span class="line">    fetch-registry: false #false表示自己就是注册中心，我的职责就是维护服务实例,并不区检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p>但是如果使用了集群后，我们的eureka就需要相互注册了，也就是 7001的需要注册到7002, 而7002注册7001</p><p>同时 hostname也不能重复，需要有两个主机的ip</p><p>eureka 7001</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7001</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7001.com #eureka服务端实例名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false #表示不向注册中心注册自己</span><br><span class="line">    fetch-registry: false #false表示自己就是注册中心，我的职责就是维护服务实例,并不区检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      # 向另外一个eureka服务注册</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p>eureka 7002:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7002</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7002.com #eureka服务端实例名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false #表示不向注册中心注册自己</span><br><span class="line">    fetch-registry: false #false表示自己就是注册中心，我的职责就是维护服务实例,并不区检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      # 向另外一个eureka服务注册</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p>启动后，我们能发现，在eureka7001上，能看到7002注册上去了</p><p><img data-src="image-20200407215956351.png" alt="image"></p><p>同时在eureka7002上，能看到7001，这个时候说明我们的eureka集群已经搭建完毕</p><p><img data-src="image-20200407220030972.png" alt="image"></p><h2 id="服务注册Eureka集群"><a href="#服务注册Eureka集群" class="headerlink" title="服务注册Eureka集群"></a>服务注册Eureka集群</h2><p>我们修改服务提供者payment的yml配置，同时将两个eureka地址配置在defaultZone中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示向注册中心注册自己 默认为true</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为true,单节点无所谓,集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    fetch-registry: true</span><br><span class="line">    service-url:</span><br><span class="line">      # 入驻地址</span><br><span class="line">      # defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;</span><br><span class="line">      #集群版</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka&#x2F;</span><br><span class="line">  #服务名称</span><br><span class="line">  instance:</span><br><span class="line">    instance-id: payment8001</span><br><span class="line">    #访问路径显示IP地址</span><br><span class="line">    prefer-ip-address: true</span><br></pre></td></tr></table></figure><p>在上面的图中，我们能发现，payment服务已经成功注册到两台eureka集群中了</p><h2 id="服务提供者集群"><a href="#服务提供者集群" class="headerlink" title="服务提供者集群"></a>服务提供者集群</h2><p>我们需要搭建多个服务提供者</p><p>例如：payment8001：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-payment-service #服务名称</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource  #当前数据源操作类型</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;cloud2020?characterEncoding&#x3D;utf8&amp;useSSL&#x3D;false&amp;useUnicode&#x3D;true</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示向注册中心注册自己 默认为true</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为true,单节点无所谓,集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    fetch-registry: true</span><br><span class="line">    service-url:</span><br><span class="line">      # 入驻地址</span><br><span class="line">      # defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;</span><br><span class="line">      #集群版</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p>和payment8002：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8002</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-payment-service #服务名称</span><br><span class="line">  zipkin:</span><br><span class="line">    base-url: http:&#x2F;&#x2F;localhost:9411</span><br><span class="line">  sleuth:</span><br><span class="line">    sampler:</span><br><span class="line">    # 采集率介于0到1之间，1表示全部采集</span><br><span class="line">      probability: 1</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource  #当前数据源操作类型</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;cloud2020?characterEncoding&#x3D;utf8&amp;useSSL&#x3D;false&amp;useUnicode&#x3D;true</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    #表示向注册中心注册自己 默认为true</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    #是否从EurekaServer抓取已有的注册信息，默认为true,单节点无所谓,集群必须设置为true才能配合ribbon使用负载均衡</span><br><span class="line">    fetch-registry: true</span><br><span class="line">    service-url:</span><br><span class="line">      # 入驻地址</span><br><span class="line">#       defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;</span><br><span class="line">      #集群版</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka&#x2F;</span><br><span class="line">  #服务名称</span><br><span class="line">  instance:</span><br><span class="line">    instance-id: payment8001</span><br><span class="line">    #访问路径显示IP地址</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper&#x2F;*.xml</span><br><span class="line">  type-aliases-package: com.atguigu.springcloud.entity  #所有entity别名所在包</span><br></pre></td></tr></table></figure><p>这里需要注意的就是，为了保证这两个服务，对外暴露的都是同一个服务提供者，我们的服务名需要保持一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-payment-service #服务名称</span><br></pre></td></tr></table></figure><p>启动后，我们发现CLOUD-PAYMENT_SERVICE上有两个服务提供者了，分别为：8001和8002</p><p><img data-src="image-20200407223634503.png" alt="image"></p><p>同时我们需要服务名进行调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;CLOUD-PAYMENT_SERVICE</span><br></pre></td></tr></table></figure><p>通知在RestTemplate需要设置负载均衡策略，即 @LoadBalanced注解，不然它不知道调用哪个微服务地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ApplicationContextConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced &#x2F;&#x2F;赋予RestTemplate负载均衡的能力</span><br><span class="line">    public RestTemplate getRestTemplate() &#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是Rabbon的负载均衡功能，默认是轮询</p><blockquote><p>Ribbon和Eureka整合后，Consumer可以直接调用服务而不再关心地址和端口号，且该服务还有负载均衡的功能</p></blockquote><h2 id="actuator微服务信息完善"><a href="#actuator微服务信息完善" class="headerlink" title="actuator微服务信息完善"></a>actuator微服务信息完善</h2><p>要做图形化的展示这块，这两个依赖都需要导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--web启动器--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--监控--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>actuator：主要用于IP信息完善</p><p>actuator查看健康状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.80.1:8002&#x2F;actuator&#x2F;health</span><br></pre></td></tr></table></figure><h3 id="服务名称修改"><a href="#服务名称修改" class="headerlink" title="服务名称修改"></a>服务名称修改</h3><p>修改后，对外暴露的就是服务名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Erueka</span><br><span class="line">  #服务名称</span><br><span class="line">  instance:</span><br><span class="line"> instance-id: payment8001</span><br></pre></td></tr></table></figure><h3 id="设置服务的IP显示"><a href="#设置服务的IP显示" class="headerlink" title="设置服务的IP显示"></a>设置服务的IP显示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Erueka</span><br><span class="line">  #服务名称</span><br><span class="line">  instance:</span><br><span class="line">    #访问路径显示IP地址</span><br><span class="line">    prefer-ip-address: true</span><br></pre></td></tr></table></figure><h2 id="服务发现Discovery"><a href="#服务发现Discovery" class="headerlink" title="服务发现Discovery"></a>服务发现Discovery</h2><p>Eureka的新的注解标签 <code>@EurekaDiscovery</code></p><p>对于注册进Eureka里面的微服务，可以通过服务发现来获得该服务的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private DiscoveryClient discoveryClient;</span><br></pre></td></tr></table></figure><p>获得服务列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 获取列表</span><br><span class="line">List&lt;String&gt; services &#x3D; discoveryClient.getServices();</span><br><span class="line"></span><br><span class="line"># 获取实例</span><br><span class="line">List&lt;ServiceInstance&gt; instances &#x3D; discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);</span><br><span class="line"></span><br><span class="line"># 获取ServiceId</span><br><span class="line">instances.get(0).getServiceId();</span><br><span class="line"></span><br><span class="line"># 获取主机名</span><br><span class="line">instances.get(0).getHost();</span><br><span class="line"></span><br><span class="line"># 获取端口号</span><br><span class="line">instances.get(0).getPort();</span><br><span class="line"></span><br><span class="line"># 获取URL</span><br><span class="line">instances.get(0).getUrl();</span><br></pre></td></tr></table></figure><h2 id="Eureka自我保护机制"><a href="#Eureka自我保护机制" class="headerlink" title="Eureka自我保护机制"></a>Eureka自我保护机制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护，一旦进入保护模式，Eureka Server将会尝试保护其服务注册表的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。</p><p>如果在Eureka Server的首页看到以下这段提示，说明Eureka进入了保护模式</p><p><img data-src="image-20200407230432953.png" alt="image"></p><p>通俗的话来说：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存，属于CAP里面的AP分支。</p><h3 id="导致原因"><a href="#导致原因" class="headerlink" title="导致原因"></a>导致原因</h3><p>默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例，默认90秒。但是当网络分区故障发生（延时，卡顿，拥挤）时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了- 因为微服务本身其实是健康的，此时不应该注销这个微服务，Eureka通过 自我保护模式 来解决这个问题，当EurekaServer节点在短时间丢失过多客户端，那么这个节点就会进入自我保护模式</p><p><img data-src="image-20200407230731783.png" alt="image"></p><p>这是一种高可用的机制</p><p><img data-src="image-20200407231058929.png" alt="image"></p><p>在自我保护模式下，Eureka Server会保护服务注册表中的信息，不在注销任何服务实例</p><p>它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例</p><p>综上，自我保护模式是一种应对网络异常的安全保护措施，它的架构哲学是宁可保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加健壮，稳定。</p><h3 id="禁止自我保护"><a href="#禁止自我保护" class="headerlink" title="禁止自我保护"></a>禁止自我保护</h3><p>Eureka默认开启自我保护</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  server:</span><br><span class="line">    enable-self-preservation: true</span><br><span class="line">    peer-node-read-timeout-ms: 3000</span><br><span class="line">    peer-node-connect-timeout-ms: 3000</span><br></pre></td></tr></table></figure><p>同时在客户端进行设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    # Eureka客户端向服务端发送心跳的时间间隔，单位为秒，默认30</span><br><span class="line">    lease-renewal-interval-in-seconds: 1</span><br><span class="line">    # Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒，默认为90秒，超时将剔除服务</span><br><span class="line">    lease-expiration-duration-in-seconds: 2</span><br></pre></td></tr></table></figure><p>设置完成后，只要服务宕机，会马上从服务注册列表中清除</p><h2 id="关于Eureka停更"><a href="#关于Eureka停更" class="headerlink" title="关于Eureka停更"></a>关于Eureka停更</h2><p>Eureka停更后，出现了其它的替代者</p><ul><li>Zookeeper</li><li>Consul</li><li>Nacos</li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud之微服务简介</title>
      <link href="/2020/05/30/SpringCloud%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/05/30/SpringCloud%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="谈谈对微服务的理解"><a href="#谈谈对微服务的理解" class="headerlink" title="谈谈对微服务的理解"></a>谈谈对微服务的理解</h2><p>微服务架构下的一整套解决方案</p><ul><li>服务注册与发现</li><li>服务调用</li><li>服务熔断</li><li>负载均衡</li><li>服务降级</li></ul><a id="more"></a><ul><li>服务消息队列</li><li>配置中心</li><li>服务网关</li><li>服务监控</li><li>全链路追踪</li><li>自动化构建部署</li><li>服务定时任务调度操作</li></ul><p><img data-src="image-20200327091144073.png" alt="image"></p><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶</p><p>下面一张图是京东的促销架构</p><p><img data-src="image-20200327091044516.png" alt="image"></p><p>阿里的架构图：</p><p><img data-src="image-20200327091209496.png" alt="image"></p><p>京东物流的架构图：</p><p><img data-src="image-20200327091226696.png" alt="image"></p><p>基础服务：</p><p><img data-src="image-20200327091359549.png" alt="image"></p><h2 id="Spring-Cloud技术栈"><a href="#Spring-Cloud技术栈" class="headerlink" title="Spring Cloud技术栈"></a>Spring Cloud技术栈</h2><p><img data-src="image-20200327091441550.png" alt="image"></p><p>这是原来2020年以前的微服务方案</p><p><img data-src="image-20200327091724535.png" alt="image"></p><p>但是随着Eureka等组件的闭源，后续的一些解决方案也有了新的替换产品</p><h2 id="Spring-Cloud版本选型"><a href="#Spring-Cloud版本选型" class="headerlink" title="Spring Cloud版本选型"></a>Spring Cloud版本选型</h2><h3 id="SpringBoot2-X版-和-SpringCloud-H版"><a href="#SpringBoot2-X版-和-SpringCloud-H版" class="headerlink" title="SpringBoot2.X版 和 SpringCloud H版"></a>SpringBoot2.X版 和 SpringCloud H版</h3><p>SpringBoot官方已经强烈推荐 2.X版</p><p>SpringCloud采用英国伦敦地铁站的名称来命名，并由地铁站名称字母A-Z一次类推的形式发布迭代版本</p><p>SpringCloud是由许多子项目组成的综合项目，各子项目有不同的发布节奏，为了管理SpringCloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个SpringCloud版对应的子项目版本，为了避免SpringCloud版本号与子项目版本号混淆，SpringCloud版采用了名称而非版本号命名。例如Angel，Brixton。当SpringCloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个Service releases版本，俗称SRX版本，比如 Greenwich.SR2就是SpringCloud发布的Greenwich版本的第二个SRX版本</p><p><img data-src="image-20200327093143960.png" alt="image"></p><h2 id="SpringBoot和SpringCloud版本约束"><a href="#SpringBoot和SpringCloud版本约束" class="headerlink" title="SpringBoot和SpringCloud版本约束"></a>SpringBoot和SpringCloud版本约束</h2><p>SpringBoot和SpringCloud的版本选择也不是任意的，而是应该参考官网的约束配置</p><p><img data-src="image-20200327093337563.png" alt="image"></p><p>地址：<code>https://spring.io/projects/spring-cloud</code></p><p>版本对应：<code>https://start.spring.io/actuator/info</code></p><h2 id="关于Cloud各种组件的停更-升级-替换"><a href="#关于Cloud各种组件的停更-升级-替换" class="headerlink" title="关于Cloud各种组件的停更/升级/替换"></a>关于Cloud各种组件的停更/升级/替换</h2><h3 id="停更引发的升级惨案"><a href="#停更引发的升级惨案" class="headerlink" title="停更引发的升级惨案"></a>停更引发的升级惨案</h3><ul><li>被动修复Bugs</li><li>不再接受合并请求</li><li>不再发布新版本</li></ul><h3 id="明细条目"><a href="#明细条目" class="headerlink" title="明细条目"></a>明细条目</h3><ul><li>服务注册发现<ul><li>Eureka</li><li>Zookeeper</li><li>Consul</li><li>Nacos （推荐）</li></ul></li><li>服务负载调用<ul><li>Feign</li><li>OpenFeign  （推荐）</li><li>Ribbon</li><li>LoadBalancer</li></ul></li><li>服务熔断降级<ul><li>Hystrix   </li><li>resilience4j</li><li>sentienl （推荐）</li></ul></li><li>服务网关<ul><li>Zuul</li><li>Zuul2</li><li>Gateway（推荐）</li></ul></li><li>服务配置<ul><li>Config</li><li>Nacos（推荐）</li></ul></li><li>服务总线<ul><li>Bus</li><li>Nacos（推荐）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之策略模式</title>
      <link href="/2020/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="策略模式简介"><a href="#策略模式简介" class="headerlink" title="策略模式简介"></a>策略模式简介</h1><p><strong>行为型模式，</strong>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。<br>在策略模式中，我们创建各种策略对象和一个context对象（表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象）。策略对象改变 context 对象的执行算法。</p><a id="more"></a><p><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。<br><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。<br><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。<br><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。<br><strong>关键代码：</strong>实现同一个接口。<br><strong>应用实例：</strong><br>1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。<br>2、旅行的出游方式，选择骑自行车。<br>坐汽车，每一种旅行方式都是一个策略。<br>3、JAVA AWT 中的 LayoutManager。<br><strong>优点：</strong><br>1、算法可以自由切换。<br>2、避免使用多重条件判断。<br>3、扩展性良好。<br><strong>缺点：</strong><br>1、策略类会增多。<br>2、所有策略类都需要对外暴露。<br><strong>使用场景：</strong><br>1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。<br>2、一个系统需要动态地在几种算法中选择一种。<br>3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。<br><strong>注意事项：</strong>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p><h1 id="策略模式实现"><a href="#策略模式实现" class="headerlink" title="策略模式实现"></a>策略模式实现</h1><p>创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。<br><code>StrategyPatternDemo</code>，演示类使用<code>Context</code>和策略对象来演示<code>Context</code>在它所配置或使用的策略改变时的行为变化。  </p><p><img data-src="1.PNG" alt="1"></p><h2 id="创建一个接口：Strategy-java"><a href="#创建一个接口：Strategy-java" class="headerlink" title="创建一个接口：Strategy.java"></a>创建一个接口：Strategy.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建实现接口的实体类：OperationAdd-java、OperationSubstract-java、OperationMultiply-java"><a href="#创建实现接口的实体类：OperationAdd-java、OperationSubstract-java、OperationMultiply-java" class="headerlink" title="创建实现接口的实体类：OperationAdd.java、OperationSubstract.java、OperationMultiply.java"></a>创建实现接口的实体类：OperationAdd.java、OperationSubstract.java、OperationMultiply.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-Context-类：Context-java"><a href="#创建-Context-类：Context-java" class="headerlink" title="创建 Context 类：Context.java"></a>创建 Context 类：Context.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Context-来查看当它改变策略-Strategy-时的行为变化：StrategyPatternDemo-java"><a href="#使用-Context-来查看当它改变策略-Strategy-时的行为变化：StrategyPatternDemo-java" class="headerlink" title="使用 Context 来查看当它改变策略 Strategy 时的行为变化：StrategyPatternDemo.java"></a>使用 Context 来查看当它改变策略 Strategy 时的行为变化：StrategyPatternDemo.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());</span><br><span class="line">        System.out.println(<span class="string">"10 + 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubstract());</span><br><span class="line">        System.out.println(<span class="string">"10 - 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());</span><br><span class="line">        System.out.println(<span class="string">"10 * 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之观察者模式</title>
      <link href="/2020/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="观察者模式简介"><a href="#观察者模式简介" class="headerlink" title="观察者模式简介"></a>观察者模式简介</h1><p><strong>行为型模式：</strong>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。  </p><a id="more"></a><p>观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并被自动更新。因此又称为，发布 / 订阅、消息通知机制、事件监听、事件驱动编程。</p><p>利用观察者模式可以设计高扩展性的代码，利用Spring事件机制能够改造订单功能。</p><p><img data-src="1.PNG" alt="1"></p><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。<br><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。<br><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。<br><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。<br><strong>应用实例：</strong><br>1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。<br>2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。<br><strong>优点：</strong><br>1、观察者和被观察者是抽象耦合的。<br>2、建立一套触发机制。<br><strong>缺点：</strong><br>1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。<br>2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。<br><strong>使用场景：</strong><br>1、一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。<br>2、一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。<br>3、一个对象必须通知其他对象，而并不知道这些对象是谁。<br>4、需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。<br><strong>注意事项：</strong><br>1、JAVA 中已经有了对观察者模式的支持类。<br>2、避免循环引用。<br>3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。<br><strong>spring事件机制：</strong>下单完成、发送邮件、发送短信…  </p><h1 id="观察者模式实现"><a href="#观察者模式实现" class="headerlink" title="观察者模式实现"></a>观察者模式实现</h1><p>观察者模式使用三个类<code>Subject</code>、<code>Observer</code>和<code>Client</code>。<code>Subject</code>对象带有绑定观察者到 Client 对象和从<code>Client</code>对象解绑观察者的方法。我们创建<code>Subject</code>类、<code>Observer</code>抽象类和扩展了抽象类<code>Observer</code>的实<br>体类。<br><code>ObserverPatternDemo</code>，我们的演示类使用 Subject 和实体类对象来演示观察者模式。  </p><p><img data-src="2.PNG" alt="2"></p><h2 id="创建-Subject-类：Subject-java"><a href="#创建-Subject-类：Subject-java" class="headerlink" title="创建 Subject 类：Subject.java"></a>创建 Subject 类：Subject.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取状态</span></span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123; <span class="comment">// 更改状态并通知所有观察者</span></span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123; <span class="comment">// 增加新的观察者</span></span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span> </span>&#123; <span class="comment">// 通知所有观察者</span></span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建-Observer-类：Observer-java"><a href="#创建-Observer-类：Observer-java" class="headerlink" title="创建 Observer 类：Observer.java"></a>创建 Observer 类：Observer.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建实体观察者类：BinaryObserver-java、OctalObserver-java、HexaObserver-java"><a href="#创建实体观察者类：BinaryObserver-java、OctalObserver-java、HexaObserver-java" class="headerlink" title="创建实体观察者类：BinaryObserver.java、OctalObserver.java、HexaObserver.java"></a>创建实体观察者类：BinaryObserver.java、OctalObserver.java、HexaObserver.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Binary String: "</span></span><br><span class="line">            + Integer.toBinaryString(subject.getState()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OctalObserver</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Octal String: "</span></span><br><span class="line">                + Integer.toOctalString(subject.getState()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HexaObserver</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hex String: "</span></span><br><span class="line">            + Integer.toHexString(subject.getState()).toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Subject-和实体观察者对象：ObserverPatternDemo-java"><a href="#使用-Subject-和实体观察者对象：ObserverPatternDemo-java" class="headerlink" title="使用 Subject 和实体观察者对象：ObserverPatternDemo.java"></a>使用 Subject 和实体观察者对象：ObserverPatternDemo.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line">        <span class="keyword">new</span> HexaObserver(subject);</span><br><span class="line">        <span class="keyword">new</span> OctalObserver(subject);</span><br><span class="line">        <span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line">        System.out.println(<span class="string">"First state change: 15"</span>);</span><br><span class="line">        subject.setState(<span class="number">15</span>);</span><br><span class="line">        System.out.println(<span class="string">"Second state change: 10"</span>);</span><br><span class="line">        subject.setState(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">First state change: <span class="number">15</span></span><br><span class="line">Hex String: F</span><br><span class="line">Octal String: <span class="number">17</span></span><br><span class="line">Binary String: <span class="number">1111</span></span><br><span class="line">Second state change: <span class="number">10</span></span><br><span class="line">Hex String: A</span><br><span class="line">Octal String: <span class="number">12</span></span><br><span class="line">Binary String: <span class="number">1010</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之工厂模式</title>
      <link href="/2020/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-D/"/>
      <url>/2020/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-D/</url>
      
        <content type="html"><![CDATA[<h1 id="工厂模式简介"><a href="#工厂模式简介" class="headerlink" title="工厂模式简介"></a>工厂模式简介</h1><p><strong>创建型模式：</strong>它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><a id="more"></a><p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br><strong>主要解决：</strong>主要解决接口选择的问题。<br><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。<br><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。<br><strong>关键代码：</strong>创建过程在其子类执行。<br><strong>应用实例：</strong><br>1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。<br>2、Hibernate 换数据库只需换方言和驱动就可以。<br><strong>优点：</strong><br>1、一个调用者想创建一个对象，只要知道其名称就可以了。<br>2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。<br>3、屏蔽产品的具体实现，调用者只关心产品的接口。<br><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。<br><strong>使用场景：</strong><br>1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。<br>2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。<br>3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。<br><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过<code>new</code>就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会<strong>增加系统的复杂度</strong>。</p><h1 id="工厂模式实现"><a href="#工厂模式实现" class="headerlink" title="工厂模式实现"></a>工厂模式实现</h1><p>我们将创建一个<code>Shape</code>接口和实现<code>Shape</code>接口的实体类。下一步是定义工厂类 <code>ShapeFactory</code>。<code>FactoryPatternDemo</code>，我们的演示类使用<code>ShapeFactory</code>来获取<code>Shape</code>对象。它将向<code>ShapeFactory</code>传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。  </p><p><img data-src="1.PNG" alt="img"></p><h2 id="创建一个接口：shape-java"><a href="#创建一个接口：shape-java" class="headerlink" title="创建一个接口：shape.java"></a>创建一个接口：shape.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建实现接口的实体类：Rectangle-java、Square-java、Circle-java"><a href="#创建实现接口的实体类：Rectangle-java、Square-java、Circle-java" class="headerlink" title="创建实现接口的实体类：Rectangle.java、Square.java、Circle.java"></a>创建实现接口的实体类：Rectangle.java、Square.java、Circle.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Square::draw() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建一个工厂，生成基于给定信息的实体类的对象："><a href="#创建一个工厂，生成基于给定信息的实体类的对象：" class="headerlink" title="创建一个工厂，生成基于给定信息的实体类的对象："></a>创建一个工厂，生成基于给定信息的实体类的对象：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">        &#125; <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用该工厂，通过传递类型信息来获取实体类的对象：FactoryPatternDemo-java"><a href="#使用该工厂，通过传递类型信息来获取实体类的对象：FactoryPatternDemo-java" class="headerlink" title="使用该工厂，通过传递类型信息来获取实体类的对象：FactoryPatternDemo.java"></a>使用该工厂，通过传递类型信息来获取实体类的对象：FactoryPatternDemo.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">        <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">        Shape shape1 = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line">        <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">        shape1.draw();</span><br><span class="line">        <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">        Shape shape2 = shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line">        <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">        shape2.draw();</span><br><span class="line">        <span class="comment">//获取 Square 的对象，并调用它的 draw 方法</span></span><br><span class="line">        Shape shape3 = shapeFactory.getShape(<span class="string">"SQUARE"</span>);</span><br><span class="line">        <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">        shape3.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/2020/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式简介"><a href="#单例模式简介" class="headerlink" title="单例模式简介"></a>单例模式简介</h1><p>创建型模式：它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。</p><a id="more"></a><p>这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p>注意：<br>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。</p><p>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>主要解决：一个全局使用的类频繁地创建与销毁。</p><p>何时使用：当您想控制实例数目，节省系统资源的时候。</p><p>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p>关键代码：构造函数是私有的。</p><h2 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h2><p>1、一个班级只有一个班主任。<br>2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。<br>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首<br>页页面缓存）。<br>2、避免对资源的多重占用（比如写文件操作）。</p><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><p>1、要求生产唯一序列号。<br>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。<br>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p>getInstance() 方法中需要使用同步锁 synchronized(Singleton.class)，防止多线程同时进入造成 instance 被多次实例化。  </p><h1 id="单例模式实现原理"><a href="#单例模式实现原理" class="headerlink" title="单例模式实现原理"></a>单例模式实现原理</h1><p>我们将创建一个<code>SingleObject</code>类。<code>SingleObject</code>类有它的私有构造函数和本身的一个静态实例。<br><code>SingleObject</code>类提供了一个静态方法，供外界获取它的静态实例。<code>SingletonPatternDemo</code>，我们的演示类使用<code>SingleObject</code>类来获取<code>SingleObject</code>对象。<br>创建一个<code>Singleton</code>类：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建 SingleObject 的一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让构造函数为 private，这样该类就不会被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>singleton</code>类获取唯一的对象：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不合法的构造函数</span></span><br><span class="line">        <span class="comment">//编译时错误：构造函数 SingleObject() 是不可见的</span></span><br><span class="line">        <span class="comment">//SingleObject object = new SingleObject();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">        SingleObject object = SingleObject.getInstance();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//显示消息</span></span><br><span class="line">        object.showMessage(); <span class="comment">// Hello World!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单例模式的实现方式（6种）"><a href="#单例模式的实现方式（6种）" class="headerlink" title="单例模式的实现方式（6种）"></a>单例模式的实现方式（6种）</h1><p>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现<code>lazy loading</code>效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。  </p><h2 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h2><p><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>否<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁<code>synchronized</code>，所以严格意义上它并不算单例模式。这种方式<code>lazy loading</code>很明显，不要求线程安全，在多线程不能正常工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h2><p><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式具备很好的<code>lazy loading</code>，能够在多线程中很好的工作，但是，效率很低，<code>99%</code>情况下不需要同步。<br><strong>优点：</strong>第一次调用才初始化，避免内存浪费。<br><strong>缺点：</strong>必须加锁<code>synchronized</code>才能保证单例，但加锁会影响效率。<code>getInstance()</code>的性能对应用程序不是很关键（该方法使用不太频繁）<br><strong>相比第一种就是加了<code>synchronized</code>关键字</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p><strong>是否 Lazy 初始化：</strong>否<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。它<strong>基于classloader机制</strong>避免了多线程的同步问题，不过，<code>instance</code>在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用<code>getInstance</code>方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到<code>lazy loading</code>的效果。<br><strong>优点：</strong>没有加锁，执行效率会提高。<br><strong>缺点：</strong>类加载时就初始化，浪费内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h2><p><strong>双检锁/双重校验锁（DCL，即 double-checked locking）</strong><br><strong>JDK 版本：</strong>JDK1.5 起<br><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>较复杂<br><strong>描述：</strong>这种方式<strong>采用双锁机制</strong>，安全且在多线程情况下能保持高性能。<code>getInstance()</code>的性能对应用程序很关键。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// volatile禁止JVM指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让构造函数为 private，这样该类就不会被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="登记式-静态内部类"><a href="#登记式-静态内部类" class="headerlink" title="登记式 / 静态内部类"></a>登记式 / 静态内部类</h2><p><strong>是否 Lazy 初始化：</strong>是<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>一般<br><strong>描述：</strong>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。这种方式同样利用了 <code>classloader</code> 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 <code>Singleton</code> 类被装载了，那么 instance 就会被实例化（没有达到<code>lazy loading</code>效果），而这种方式是<code>Singleton</code>类被装载了，<code>instance</code>不一定被初始化。因为<code>SingletonHolder</code>类没有被主动使用，只有通过显式调用<code>getInstance</code>方法时，才会显式装载<code>SingletonHolder</code>类，从而实例化<code>instance</code>。想象一下，如果实例化<code>instance</code>很消耗资源，所以想让它延迟加载，另外一方面，又不希望在<code>Singleton</code>类加载时就实例化，因为不能确保<code>Singleton</code>类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化<code>instance</code>显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><strong>JDK 版本：</strong>JDK1.5 起<br><strong>是否 Lazy 初始化：</strong>否<br><strong>是否多线程安全：</strong>是<br><strong>实现难度：</strong>易<br><strong>描述：</strong>这种实现方式还没有被广泛采用，但这是实现单例模式的<strong>最佳方法</strong>。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是<strong>《Effective Java》</strong>作者<code>Josh Bloch</code>提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于<code>JDK1.5</code>之后才加入<code>enum</code>特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br><strong>缺点：</strong>不能通过<code>reflection attack</code>来调用私有构造方法。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton.INSTANCE.whateverMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之简介</title>
      <link href="/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><a id="more"></a><p>3大类型23种 </p><p><img data-src="1.PNG" alt="img"></p><h2 id="创建型模式（Creational-Patterns）"><a href="#创建型模式（Creational-Patterns）" class="headerlink" title="创建型模式（Creational Patterns）"></a>创建型模式（Creational Patterns）</h2><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。5种：<br>工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</p><h2 id="结构型模式（Structural-Patterns）"><a href="#结构型模式（Structural-Patterns）" class="headerlink" title="结构型模式（Structural Patterns）"></a>结构型模式（Structural Patterns）</h2><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。8种：<br>适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）  </p><h2 id="行为型模式（Behavioral-Patterns）"><a href="#行为型模式（Behavioral-Patterns）" class="headerlink" title="行为型模式（Behavioral Patterns）"></a>行为型模式（Behavioral Patterns）</h2><p>这些设计模式特别关注对象之间的通信。12种：<br>责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）  </p><h2 id="J2EE-设计模式"><a href="#J2EE-设计模式" class="headerlink" title="J2EE 设计模式"></a>J2EE 设计模式</h2><p>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。8种：<br>MVC 模式（MVC Pattern）<br>业务代表模式（Business Delegate Pattern）<br>组合实体模式（Composite Entity Pattern）<br>数据访问对象模式（Data Access Object Pattern）<br>前端控制器模式（Front Controller Pattern）<br>拦截过滤器模式（Intercepting Filter Pattern）<br>服务定位器模式（Service Locator Pattern）<br>传输对象模式（Transfer Object Pattern）  </p><h1 id="设计模式之间的关系"><a href="#设计模式之间的关系" class="headerlink" title="设计模式之间的关系"></a>设计模式之间的关系</h1><p><img data-src="the-relationship-between-design-patterns.jpg" alt="img"></p><h1 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h1><h2 id="单一职责原则（Single-Responsibility-Principle）"><a href="#单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（Single Responsibility Principle）"></a>单一职责原则（Single Responsibility Principle）</h2><p>类的职责要单一，不能将太多的职责放在一个类中。</p><h2 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h2><p>对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效<br>果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和<br>抽象类，后面的具体设计中我们会提到这点。</p><h2 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a>里氏代换原则（Liskov Substitution Principle）</h2><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一<br>定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响<br>时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则<br>的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以<br>里氏代换原则是对实现抽象化的具体步骤的规范。</p><h2 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h2><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><h2 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h2><p>使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可<br>见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低<br>耦合。</p><h2 id="迪米特法则（Demeter-Principle）"><a href="#迪米特法则（Demeter-Principle）" class="headerlink" title="迪米特法则（Demeter Principle）"></a>迪米特法则（Demeter Principle）</h2><p>又称知识最少原则<br>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h2 id="合成复用原则（Composite-Reuse-Principle）"><a href="#合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（Composite Reuse Principle）"></a>合成复用原则（Composite Reuse Principle）</h2><p>尽量使用合成 or 聚合的方式，而不是使用继承 。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的代码块</title>
      <link href="/2020/04/18/Java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
      <url>/2020/04/18/Java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>普通代码块：在方法或语句中出现的{}，就被称为代码块</p><p>静态代码块：静态代码块有且仅加载一次，也就是在这个类被加载至内存的时候</p><p>普通代码块和一般语句执行顺序由他们在代码中出现的次序决定，先出现先执行</p><a id="more"></a><h2 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 代码块</span><br><span class="line"> * 普通代码块：在方法或语句中出现的&#123;&#125;，就被称为代码块</span><br><span class="line"> * 普通代码块和一般语句执行顺序由他们在代码中出现的次序决定，先出现先执行</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: 2020-04-06-9:51</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CodeBlock &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            int x &#x3D; 11;</span><br><span class="line">            System.out.println(&quot;普通代码块中的变量X&#x3D;&quot; + x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            int y &#x3D; 13;</span><br><span class="line">            System.out.println(&quot;普通代码块中的变量y&#x3D;&quot; + y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int x &#x3D; 12;</span><br><span class="line">        System.out.println(&quot;主方法中的变量x&#x3D;&quot; + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述方法，我们一下就能看出它的输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">普通代码块中的变量X&#x3D;11</span><br><span class="line">普通代码块中的变量y&#x3D;13</span><br><span class="line">主方法中的变量x&#x3D;12</span><br></pre></td></tr></table></figure><h2 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h2><p>而对于下面的代码，我们调用了类的初始化，同时在类里也写了两个代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 代码块</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: 2020-04-06-9:51</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CodeBlock02 &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;第二构造块33333&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  CodeBlock02() &#123;</span><br><span class="line">        System.out.println(&quot;构造方法2222&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;第一构造块33333&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new CodeBlock02();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        new CodeBlock02();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第二构造块33333</span><br><span class="line">第一构造块33333</span><br><span class="line">构造方法2222</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">第二构造块33333</span><br><span class="line">第一构造块33333</span><br><span class="line">构造方法2222</span><br></pre></td></tr></table></figure><p>这里需要谈的就是，类加载机制了，因为我们都知道，当我们实例化一个类的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new CodeBlock02();</span><br></pre></td></tr></table></figure><p>启动调用的就是这个类的构造方法，但是比构造方法更上一级的是跟本构造方法在同一个类的代码块，因此</p><blockquote><p>代码块的优先级比构造方法高</p><p>构造代码块在每次创建对象的时候都会被调用，并且构造代码块的执行次序优先于构造方法</p></blockquote><h2 id="代码三"><a href="#代码三" class="headerlink" title="代码三"></a>代码三</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 代码块</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: 2020-04-06-9:51</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 随从类</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Code &#123;</span><br><span class="line">    public Code() &#123;</span><br><span class="line">        System.out.println(&quot;Code的构造方法1111&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Code的构造代码块22222&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Code的静态代码块33333&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CodeBlock03 &#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;CodeBlock03的构造代码块22222&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;CodeBlock03的静态代码块33333&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CodeBlock03() &#123;</span><br><span class="line">        System.out.println(&quot;CodeBlock03的构造方法33333&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;我是主类&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        new Code();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        new Code();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        new CodeBlock03();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CodeBlock03的静态代码块33333</span><br><span class="line">我是主类&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Code的静态代码块33333</span><br><span class="line">Code的构造代码块22222</span><br><span class="line">Code的构造方法1111</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Code的构造代码块22222</span><br><span class="line">Code的构造方法1111</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">CodeBlock03的构造代码块22222</span><br><span class="line">CodeBlock03的构造方法33333</span><br></pre></td></tr></table></figure><p>从上面的结果可以看出，但这个类被加载到内存的时候，首先需要执行的是静态方法，也就是static方法在类被实例化之前，就已经完成了，和以后的实例化都没有关系了，因此我们能够看到，被第一个输出，同时静态代码块有且仅加载一次，但我们需要运行main方法的时候，就需要等CodeBlock03加载好，因此能够看到下面的输出了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CodeBlock03的静态代码块33333</span><br></pre></td></tr></table></figure><p>同时但我们实例化 Code类的时候，这个类也会首先被加载到内存中，然后也是首先运行静态代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Code的静态代码块33333</span><br><span class="line">Code的构造代码块22222</span><br><span class="line">Code的构造方法1111</span><br></pre></td></tr></table></figure><p>再次实例化的时候，因此该类已经在内存中，所以不再运行静态代码块了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Code的构造代码块22222</span><br><span class="line">Code的构造方法1111</span><br></pre></td></tr></table></figure><p>最后在实例化CodeBlock03，因为CodeBlock03也已经被加载内存中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CodeBlock03的构造代码块22222</span><br><span class="line">CodeBlock03的构造方法33333</span><br></pre></td></tr></table></figure><h2 id="代码四"><a href="#代码四" class="headerlink" title="代码四"></a>代码四</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 代码块</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: 2020-04-06-9:51</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Father &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;我是父亲代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Father() &#123;</span><br><span class="line">        System.out.println(&quot;我是父亲构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;我是父亲静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Son extends Father&#123;</span><br><span class="line">    public Son() &#123;</span><br><span class="line">        System.out.println(&quot;我是儿子构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;我是儿子代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;我是儿子静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CodeBlock04 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;我是主类&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        new Son();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        new Son();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        new Father();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">我是主类&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">我是父亲静态代码块</span><br><span class="line">我是儿子静态代码块</span><br><span class="line">我是父亲代码块</span><br><span class="line">我是父亲构造</span><br><span class="line">我是儿子代码块</span><br><span class="line">我是儿子构造</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">我是父亲代码块</span><br><span class="line">我是父亲构造</span><br><span class="line">我是儿子代码块</span><br><span class="line">我是儿子构造</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">我是父亲代码块</span><br><span class="line">我是父亲构造</span><br></pre></td></tr></table></figure><blockquote><p>任何一个类被加载，必须加载这个类的静态代码块</p><p>同时如果存在父子关系的时候，调用子类的构造方法，同时子类的构造方法，在最顶部会调用super()也就是父类的构造方法，一般这个是被省略的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Son() &#123;</span><br><span class="line">     super();</span><br><span class="line">     System.out.println(&quot;我是儿子构造&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>所以在子类初始化之前，还需要调用父类构造，所以父类需要加载进内存，也就是从父到子，静态执行，并且只加载一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是父亲静态代码块</span><br><span class="line">我是儿子静态代码块</span><br></pre></td></tr></table></figure><p>然后父类在进行实例化，在调用构造方法之前，需要调用本类的代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是父亲代码块</span><br><span class="line">我是父亲构造</span><br></pre></td></tr></table></figure><p>最后父类初始化成功后，在调用子类的</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是儿子代码块</span><br><span class="line">我是儿子构造</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>在执行第二次的 new Son()的时候，因为该类已经被装载在内存中了，因此静态代码块不需要执行，我们只需要从父到子执行即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;我是父亲代码块</span><br><span class="line">&gt;我是父亲构造</span><br><span class="line">&gt;我是儿子代码块</span><br><span class="line">&gt;我是儿子构造</span><br></pre></td></tr></table></figure><p>同理在执行new Father()的时候也是一样的，只需要执行Father的实例化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;我是父亲代码块</span><br><span class="line">&gt;我是父亲构造</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>equals与==的区别</title>
      <link href="/2020/04/03/equals%E4%B8%8E%E5%8F%8C%E7%AD%89%E4%BA%8E%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/04/03/equals%E4%B8%8E%E5%8F%8C%E7%AD%89%E4%BA%8E%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="等等与equals的区别"><a href="#等等与equals的区别" class="headerlink" title="等等与equals的区别"></a>等等与equals的区别</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道， == 是比较内存地址，equals是比较值</p><p>但是这种非常错误的一种观点</p><a id="more"></a><ul><li>==：比较基本数据类型的时候，比较的是值，引用数据类型比较的是地址（new的对象，==比较永远是false）</li><li>equals：属于Object类的方法，如果我们没有重写过equals方法，那么它就是 ==，但是字符串里面的equals被重写过了，比较的是值</li></ul><h2 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * equals和等等的区别</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: 2020-04-03-8:50</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class EqualsDemo &#123;</span><br><span class="line"></span><br><span class="line">    static class Person &#123;</span><br><span class="line">        private String name;</span><br><span class="line"></span><br><span class="line">        public Person(String name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">        String s2 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 &#x3D;&#x3D; s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">        Set&lt;String&gt; set1 &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        set1.add(s1);</span><br><span class="line">        set1.add(s2);</span><br><span class="line">        System.out.println(set1.size());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">        String s3 &#x3D; &quot;cbd&quot;;</span><br><span class="line">        String s4 &#x3D; &quot;cbd&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(s3 &#x3D;&#x3D; s4);</span><br><span class="line">        System.out.println(s3.equals(s4));</span><br><span class="line">        Set&lt;String&gt; set3 &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        set3.add(s3);</span><br><span class="line">        set3.add(s3);</span><br><span class="line">        System.out.println(set3.size());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">        Person person1 &#x3D; new Person(&quot;abc&quot;);</span><br><span class="line">        Person person2 &#x3D; new Person(&quot;abc&quot;);</span><br><span class="line">        System.out.println(person1 &#x3D;&#x3D; person2);</span><br><span class="line">        System.out.println(person1.equals(person2));</span><br><span class="line">        Set&lt;Person&gt; set2 &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        set2.add(person1);</span><br><span class="line">        set2.add(person2);</span><br><span class="line">        System.out.println(set2.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">false（&#x3D;&#x3D;：如果是new出来的对象，比较的时候永远是false）</span><br><span class="line">true：（字符串中的equals被重写过，比较的是值）</span><br><span class="line">1：（HashSet底层是HashMap，HashMap内部是调用equals 和 HashCode，但是String内部的HashCode和equals也被复写）</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">true（我们通过这种方式创建的会放在一个字符串常量池中，相同的字符串，会指向常量池中同一个对象，因此他们的地址是一样的）</span><br><span class="line">true（字符串中的equals被重写过，比较的是值）</span><br><span class="line">1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">false（&#x3D;&#x3D;：如果是new出来的对象，比较的时候永远是false）</span><br><span class="line">false（Person中的equals没有被重写，相当于等等）</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String str1 &#x3D; &quot;abc&quot;;</span><br><span class="line">String str2 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">String str3 &#x3D; &quot;abc&quot;;</span><br><span class="line">String str4 &#x3D;  &quot;xxx&quot;;</span><br><span class="line">String str5 &#x3D; &quot;abc&quot; + &quot;xxx&quot;;</span><br><span class="line">String str6 &#x3D; s3 + s4;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;str1 &#x3D;&#x3D; str2：&quot; + (str1 &#x3D;&#x3D; str2));</span><br><span class="line">System.out.println(&quot;str1.equals(str2)：&quot; + (str1.equals(str2)));</span><br><span class="line">System.out.println(&quot;str1 &#x3D;&#x3D; str5：&quot; + (str1 &#x3D;&#x3D; str5));</span><br><span class="line">System.out.println(&quot;str1 &#x3D;&#x3D; str6：&quot; + (str1 &#x3D;&#x3D; str6));</span><br><span class="line">System.out.println(&quot;str5 &#x3D;&#x3D; str6：&quot; + (str5 &#x3D;&#x3D; str6));</span><br><span class="line">System.out.println(&quot;str5.equals(str6)：&quot; + (str5.equals(str6)));</span><br><span class="line">System.out.println(&quot;str1 &#x3D;&#x3D; str6.intern()：&quot; + (str1 &#x3D;&#x3D; str6.intern()));</span><br><span class="line">System.out.println(&quot;str1 &#x3D;&#x3D; str2.intern()：&quot; + (str1 &#x3D;&#x3D; str2.intern()));</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str1 &#x3D;&#x3D; str2：false</span><br><span class="line">str1.equals(str2)：true</span><br><span class="line">str1 &#x3D;&#x3D; str5：false</span><br><span class="line">str1 &#x3D;&#x3D; str6：false</span><br><span class="line">str5 &#x3D;&#x3D; str6：false</span><br><span class="line">str5.equals(str6)：false</span><br><span class="line">str1 &#x3D;&#x3D; str6.intern()：false</span><br><span class="line">str1 &#x3D;&#x3D; str2.intern()：true</span><br></pre></td></tr></table></figure><p>下面解释关于 intern方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一句话，intern方法就是从常量池中获取对象</span><br><span class="line">返回字符串对象的规范表示形式</span><br><span class="line">字符串池最初为空，由类字符串私下维护</span><br><span class="line">调用intern方法时，如果池中已包含由equals(Object)方法确定的与此String对象相等的字符串，则返回池中的字符串</span><br><span class="line">否者，此字符串添加到池中，并返回对此字符串对象的引用</span><br><span class="line">因此，对于任意两个字符串s和t，s.intern() &#x3D;&#x3D; t.intern() 在且仅当 s.equals(t) 为 true时候,所有文字字符串和字符串值常量表达式都会被插入</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的锁之AQS原理（浅析）</title>
      <link href="/2020/03/24/Java%E7%9A%84%E9%94%81%E4%B9%8BAQS%E5%8E%9F%E7%90%86%EF%BC%88%E6%B5%85%E6%9E%90%EF%BC%89/"/>
      <url>/2020/03/24/Java%E7%9A%84%E9%94%81%E4%B9%8BAQS%E5%8E%9F%E7%90%86%EF%BC%88%E6%B5%85%E6%9E%90%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Java的锁之AQS原理（浅析）"><a href="#Java的锁之AQS原理（浅析）" class="headerlink" title="Java的锁之AQS原理（浅析）"></a>Java的锁之AQS原理（浅析）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AQS的全称为（<code>AbstractQueuedSynchronizer</code>），这个类在<code>java.util.concurrent.locks</code>包下面 ，它提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，<code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code>等并发类均是基于<strong>AQS</strong>来实现的，具体用法是通过继承AQS实现其模板方法，然后将子类作为同步组件的内部类。</p><a id="more"></a><p><img data-src="1.PNG" alt="1"></p><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p>在阅读源码前，首先阐述<strong>AQS</strong>的基本思想及其相关概念。</p><p>AQS基本框架如下图所示：</p><p><img data-src="10431632-7d2aa48b9b217bbe.webp" alt="img"></p><p>AQS维护了一个volatile语义(支持多线程下的可见性)的共享资源变量state和一个FIFO线程等待队列(多线程竞争state被阻塞时会进入此队列)。</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>首先说一下共享资源变量state，它是int数据类型的，其访问方式有3种：</p><ul><li>getState()</li><li>setState(int newState)</li><li>compareAndSetState(int expect, int update)</li></ul><p>上述3种方式均是原子操作，其中<code>compareAndSetState()</code>的实现依赖于<code>Unsafe</code>类的<code>compareAndSwapInt()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具有内存读可见性语义</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具有内存写可见性语义</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具有内存读/写可见性语义</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>资源的共享方式分为2种：</p><ul><li>独占式(Exclusive)</li></ul><p>只有单个线程能够成功获取资源并执行，如<code>ReentrantLock</code>。</p><ul><li>共享式(Shared)</li></ul><p>多个线程可成功获取资源并执行，如<code>Semaphore</code>/<code>CountDownLatch</code>等。</p><p>AQS将大部分的同步逻辑均已经实现好，继承的自定义同步器只需要实现<code>state</code>的获取(<code>acquire</code>)和释放(<code>release</code>)的逻辑代码就可以，主要包括下面方法：</p><ul><li><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li><li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li></ul><p><strong>AQS</strong>需要子类复写的方法均没有声明为abstract，目的是避免子类需要强制性覆写多个方法，因为一般自定义同步器要么是独占方法，要么是共享方法，只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。</p><p>当然，<strong>AQS</strong>也支持子类同时实现独占和共享两种模式，如<code>ReentrantReadWriteLock</code>。</p><h3 id="CLH队列-FIFO"><a href="#CLH队列-FIFO" class="headerlink" title="CLH队列(FIFO)"></a>CLH队列(FIFO)</h3><p><strong>AQS</strong>是通过内部类<code>Node</code>来实现<strong>FIFO</strong>队列的，源代码解析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表明节点在共享模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 表明节点在独占模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表征等待线程已取消的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 表征需要唤醒后续线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 表征线程正在等待触发条件(condition)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 表征下一个acquireShared应无条件传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   SIGNAL: 当前节点释放state或者取消后，将通知后续节点竞争state。</span></span><br><span class="line"><span class="comment">     *   CANCELLED: 线程因timeout和interrupt而放弃竞争state，当前节点将与state彻底拜拜</span></span><br><span class="line"><span class="comment">     *   CONDITION: 表征当前节点处于条件队列中，它将不能用作同步队列节点，直到其waitStatus被重置为0</span></span><br><span class="line"><span class="comment">     *   PROPAGATE: 表征下一个acquireShared应无条件传播</span></span><br><span class="line"><span class="comment">     *   0: None of the above</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 持有的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">// 链接下一个等待条件触发的节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回节点是否处于Shared状态下</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回前继节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Shared模式下的Node构造函数</span></span><br><span class="line">    Node() &#123;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于addWaiter</span></span><br><span class="line">    Node(Thread thread, Node mode) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于Condition</span></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>waitStatus</code>非负的时候，表征不可用，正数代表处于等待状态，所以<code>waitStatus</code>只需要检查其正负符号即可，不用太多关注特定值。</p><h2 id="获取资源-独占模式"><a href="#获取资源-独占模式" class="headerlink" title="获取资源(独占模式)"></a>获取资源(独占模式)</h2><h3 id="acquire-int"><a href="#acquire-int" class="headerlink" title="acquire(int)"></a>acquire(int)</h3><p>首先讲解独占模式(Exclusive)下的获取/释放资源过程，其入口方法为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire(arg)为线程获取资源的方法函数，在AQS中定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，该方法是空方法，且由protected修饰，说明该方法需要由子类即自定义同步器来实现。</p><p>acquire()方法至少执行一次tryAcquire(arg)，若返回true，则acquire直接返回，否则进入acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法。</p><p>acquireQueued方法分为3个步骤：</p><ol><li>addWriter()将当前线程加入到等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中获取资源，直到获取到资源返回，若整个等待过程被中断过，则返回True，否则返回False。</li><li>如果线程在等待过程中被中断过，则先标记上，待获取到资源后再进行自我中断selfInterrupt()，将中断响应掉。</li></ol><p>下面具体看看过程中涉及到的各函数：</p><h3 id="tryAcquire-int"><a href="#tryAcquire-int" class="headerlink" title="tryAcquire(int)"></a>tryAcquire(int)</h3><p>tryAcquire尝试以独占的模式获取资源，如果获取成功则返回True，否则直接返回False，默认实现是抛出UnsupportedOperationException，具体实现由自定义扩展了AQS的同步器来完成。</p><h3 id="addWaiter-Node"><a href="#addWaiter-Node" class="headerlink" title="addWaiter(Node)"></a>addWaiter(Node)</h3><p>addWaiter为当前线程以指定模式创建节点，并将其添加到等待队列的尾部，其源码为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span>(<span class="params">Node mode</span>)</span> &#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 尝试将节点快速插入等待队列，若失败则执行常规插入(enq方法)</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 常规插入</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看enq(node)方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，常规插入与快速插入相比，有2点不同：</p><ol><li>常规插入是自旋过程(for(;;))，能够保证节点插入成功；</li><li>比快速插入多包含了1种情况，即当前等待队列为空时，需要初始化队列，即将待插入节点设置为头结点，同时为尾节点(因为只有一个嘛)。</li></ol><p>常规插入与快速插入均依赖于CAS，其实现依赖于unsafe类，具体代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> boolean compareAndSetHead(Node update) &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, headOffset, <span class="literal">null</span>, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> boolean compareAndSetTail(Node <span class="keyword">expect</span>, Node update) &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, <span class="keyword">expect</span>, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unsafe中的cas操作均是native方法，由计算机CPU的cmpxchg指令来保证其原子性。</p><p>接着看acquireQueued()方法：</p><h3 id="acquireQueued-Node-int"><a href="#acquireQueued-Node-int" class="headerlink" title="acquireQueued(Node, int)"></a>acquireQueued(Node, int)</h3><p>相关说明已在代码中注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标识是否获取资源失败</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标识当前线程是否被中断过</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋操作</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前继节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前继节点为头结点，说明排队马上排到自己了，可以尝试获取资源，若获取资源成功，则执行下述操作</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 将当前节点设置为头结点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 说明前继节点已经释放掉资源了，将其next置空，以方便虚拟机回收掉该前继节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="comment">// 标识获取资源成功</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 返回中断标记</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若前继节点不是头结点，或者获取资源失败，</span></span><br><span class="line">            <span class="comment">// 则需要通过shouldParkAfterFailedAcquire函数</span></span><br><span class="line">            <span class="comment">// 判断是否需要阻塞该节点持有的线程</span></span><br><span class="line">            <span class="comment">// 若shouldParkAfterFailedAcquire函数返回true，</span></span><br><span class="line">            <span class="comment">// 则继续执行parkAndCheckInterrupt()函数，</span></span><br><span class="line">            <span class="comment">// 将该线程阻塞并检查是否可以被中断，若返回true，则将interrupted标志置于true</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最终获取资源失败，则当前节点放弃获取资源</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体看一下shouldParkAfterFailedAcquire函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shouldParkAfterFailedAcquire是通过前继节点的waitStatus值来判断是否阻塞当前节点的线程的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取前继节点的waitStatus值ws</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果ws的值为Node.SIGNAL(-1)，则直接返回true</span></span><br><span class="line">    <span class="comment">// 说明前继节点完成资源的释放或者中断后，会通知当前节点的，回家等通知就好了，不用自旋频繁地来打听消息</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果前继节点的ws值大于0,即为1,说明前继节点处于放弃状态(Cancelled)</span></span><br><span class="line">    <span class="comment">// 那就继续往前遍历，直到当前节点的前继节点的ws值为0或负数</span></span><br><span class="line">    <span class="comment">// 此处代码很关键，节点往前移动就是通过这里来实现的，直到节点的前继节点满足</span></span><br><span class="line">    <span class="comment">// if (p == head &amp;&amp; tryAcquire(arg))条件，acquireQueued方法才能够跳出自旋过程</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将前继节点的ws值设置为Node.SIGNAL，以保证下次自旋时，shouldParkAfterFailedAcquire直接返回true</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parkAndCheckInterrupt()函数则简单很多，主要调用LockSupport类的park()方法阻塞当前线程，并返回线程是否被中断过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，独占模式下，线程获取资源acquire的代码就跟完了，总结一下过程：</p><ol><li>首先线程通过tryAcquire(arg)尝试获取共享资源，若获取成功则直接返回，若不成功，则将该线程以独占模式添加到等待队列尾部，tryAcquire(arg)由继承AQS的自定义同步器来具体实现；</li><li>当前线程加入等待队列后，会通过acquireQueued方法基于CAS自旋不断尝试获取资源，直至获取到资源；</li><li>若在自旋过程中，线程被中断过，acquireQueued方法会标记此次中断，并返回true。</li><li>若acquireQueued方法获取到资源后，返回true，则执行线程自我中断操作selfInterrupt()。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放资源-独占模式"><a href="#释放资源-独占模式" class="headerlink" title="释放资源(独占模式)"></a>释放资源(独占模式)</h2><p>讲完获取资源，对应的讲一下AQS的释放资源过程，其入口函数为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 获取到等待队列的头结点h</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 若头结点不为空且其ws值非0，则唤醒h的后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑并不复杂，通过tryRelease(arg)来释放资源，和tryAcquire类似，<strong>tryRelease也是有继承AQS的自定义同步器来具体实现</strong>。</p><h3 id="tryRelease-int"><a href="#tryRelease-int" class="headerlink" title="tryRelease(int)"></a>tryRelease(int)</h3><p>该方法尝试释放指定量的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unparkSuccessor-Node"><a href="#unparkSuccessor-Node" class="headerlink" title="unparkSuccessor(Node)"></a>unparkSuccessor(Node)</h3><p>该方法主要用于唤醒等待队列中的下一个阻塞线程。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span>(<span class="params">Node node</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前节点的ws值</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 将当前节点的ws值置0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 若后继节点为null或者其ws值大于0(放弃状态)，则从等待队列的尾节点从后往前搜索，</span></span><br><span class="line">    <span class="comment">// 搜索到等待队列中最靠前的ws值非正且非null的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果后继节点非null，则唤醒该后继节点持有的线程</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后继节点的阻塞线程被唤醒后，就进入到acquireQueued()的if (p == head &amp;&amp; tryAcquire(arg))的判断中，此时被唤醒的线程将尝试获取资源。</p><p>当然，如果被唤醒的线程所在节点的前继节点不是头结点，经过shouldParkAfterFailedAcquire的调整，也会移动到等待队列的前面，直到其前继节点为头结点。</p><p>讲解完独占模式下资源的acquire/release过程，下面开始讲解共享模式下，线程如何完成资源的获取和共享。</p><h2 id="获取资源-共享模式"><a href="#获取资源-共享模式" class="headerlink" title="获取资源(共享模式)"></a>获取资源(共享模式)</h2><p>理解了独占模式下，资源的获取和释放过程，则共享模式下也就so easy了，首先看一下方法入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行tryAcquireShared方法获取资源，若获取成功则直接返回，若失败，则进入等待队列，执行自旋获取资源，具体由doAcquireShared方法来实现。</p><h3 id="tryAcquireShared-int"><a href="#tryAcquireShared-int" class="headerlink" title="tryAcquireShared(int)"></a>tryAcquireShared(int)</h3><p>同样的，tryAcquireShared(int)由继承AQS的自定义同步器来具体实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其返回值为负值代表失败；0代表获取成功，但无剩余资源；正值代表获取成功且有剩余资源，其他线程可去获取。</p><h3 id="doAcquireShared-int"><a href="#doAcquireShared-int" class="headerlink" title="doAcquireShared(int)"></a>doAcquireShared(int)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将线程以共享模式添加到等待队列的尾部</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="comment">// 初始化失败标志</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化线程中断标志</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前继节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 若前继节点为头结点，则执行tryAcquireShared获取资源</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 若获取资源成功，且有剩余资源，将自己设为头结点并唤醒后续的阻塞线程</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="comment">// 如果中断标志位为真，则线程执行自我了断</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    <span class="comment">// 表征获取资源成功</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// houldParkAfterFailedAcquire(p, node)根据前继节点判断是否阻塞当前节点的线程</span></span><br><span class="line">            <span class="comment">// parkAndCheckInterrupt()阻塞当前线程并检查线程是否被中断过，若被中断过，将interrupted置为true</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 放弃获取资源</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，doAcquireShared与独占模式下的acquireQueued大同小异，主要有2点不同：</p><ol><li>doAcquireShared将线程的自我中断操作放在了方法体内部；</li><li>当线程获取到资源后，doAcquireShared会将当前线程所在的节点设为头结点，若资源有剩余则唤醒后续节点，比acquireQueued多了个唤醒后续节点的操作。</li></ol><p>上述方法体现了共享的本质，即当前线程吃饱了后，若资源有剩余，会招呼后面排队的来一起吃，好东西要大家一起分享嘛，哈哈。</p><p>下面具体看一下setHeadAndPropagate(Node, int)函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span>(<span class="params">Node node, <span class="keyword">int</span> propagate</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录原来的头结点，下面过程会用到</span></span><br><span class="line">    Node h = head; </span><br><span class="line">    <span class="comment">// 设置新的头结点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果资源还有剩余，则唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，实际执行唤醒后继节点的方法是doReleaseShared()，继续追踪：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 自旋操作</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取等待队列的头结点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>; </span><br><span class="line">                <span class="comment">// 唤醒后继节点的线程</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放资源-共享模式"><a href="#释放资源-共享模式" class="headerlink" title="释放资源(共享模式)"></a>释放资源(共享模式)</h2><p>首先进入到方法入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒后继节点的线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，tryReleaseShared(int)由继承AQS的自定义同步器来具体实现。</p><p>doReleaseShared()上节讲解setHeadAndPropagate已说明过，不再赘述。</p><p>至此，共享模式下的资源获取/释放就讲解完了，下面以一个具体场景来概括一下：</p><p>整个获取/释放资源的过程是通过传播完成的，如最开始有10个资源，线程A、B、C分别需要5、4、3个资源。</p><ul><li>A线程获取到5个资源，其发现资源还剩余5个，则唤醒B线程；</li><li>B线程获取到4个资源，其发现资源还剩余1个，唤醒C线程；</li><li>C线程尝试取3个资源，但发现只有1个资源，继续阻塞；</li><li>A线程释放1个资源，其发现资源还剩余2个，故唤醒C线程；</li><li>C线程尝试取3个资源，但发现只有2个资源，继续阻塞；</li><li>B线程释放2个资源，其发现资源还剩余4个，唤醒C线程；</li><li>C线程获取3个资源，其发现资源还剩1个，继续唤醒后续等待的D线程；</li><li>……</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了AQS在独占和共享两种模式下，如何进行资源的获取和释放(tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared)，需要注意的是，在acquire()和acquireShared()方法中，线程在阻塞过程中均是忽略中断的。</p><p>AQS也可以通过acquireInterruptibly()/acquireSharedInterruptibly()来支持线程在等待过程中响应中断。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java的锁 </tag>
            
            <tag> AQS </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL实现分布式锁</title>
      <link href="/2020/03/23/MySQL%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2020/03/23/MySQL%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分布式锁还可以基于数据库（MySQL）进行实现，一般分为3类：基于表记录、乐观锁和悲观锁。</p><h1 id="基于表记录"><a href="#基于表记录" class="headerlink" title="基于表记录"></a>基于表记录</h1><p>基于表记录，可以通过UNIQUE KEY实现锁</p><p>创建这样一张表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`database_lock`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`resource`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的资源'</span>,</span><br><span class="line"><span class="string">`description`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">""</span> <span class="keyword">COMMENT</span> <span class="string">'描述'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uiq_idx_resource`</span> (<span class="string">`resource`</span>) </span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'数据库分布式锁表'</span>;</span><br></pre></td></tr></table></figure><p>如果要锁住某方法，只要执行以下sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> database_lock(<span class="keyword">resource</span>, description) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'lock'</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>在表database_lock中，resource字段做了唯一性约束，这样如果有多个请求同时提交到数据库的话，数据库可以保证只有一个操作可以成功（其它的会报错：ERROR 1062 (23000): Duplicate entry ‘1’ for key ‘uiq_idx_resource’），那么那么我们就可以认为操作成功的那个请求获得了锁。</p><p>当需要释放锁的时，可以<strong>删除这条数据</strong>：</p><p>这种实现方式非常的简单，但是需要<strong>注意</strong>以下几点：</p><p>这种锁没有失效时间，一旦释放锁的操作失败就会导致锁记录一直在数据库中，其它线程无法获得锁。这个缺陷也很好解决，比如可以做一个定时任务去定时清理。<br>这种锁的可靠性依赖于数据库。建议设置备库，避免单点，进一步提高可靠性。<br>这种锁是非阻塞的，因为插入数据失败之后会直接报错，想要获得锁就需要再次操作。如果需要阻塞式的，可以弄个for循环、while循环之类的，直至INSERT成功再返回。<br>这种锁也是非可重入的，因为同一个线程在没有释放锁之前无法再次获得锁，因为数据库中已经存在同一份记录了。想要实现可重入锁，可以在数据库中添加一些字段，比如获得锁的主机信息、线程信息等，那么在再次获得锁的时候可以先查询数据，如果当前的主机信息和线程信息等能被查到的话，可以直接把锁分配给它。</p><p>让我们总结分布式锁需要具备的几个条件：</p><p><strong>互斥（必须）：</strong>同一时刻，分布式部署的应用中，同一个方法/资源只能被一台机器上的一个线程占用。</p><p><strong>锁失效保护（必须）：</strong>出现客户端断电等异常情况，锁仍然能被其他客户端获取，防止死锁。</p><p><strong>可重入（可选）：</strong>同一个线程在没有释放锁之前，如果想再次操作，可以直接获得锁。</p><p><strong>阻塞/非阻塞（可选）：</strong>若没有获取到锁，返回获取失败</p><p><strong>高可用、高性能（可选）：</strong>获取释放锁最好是原子操作，获取释放锁的性能要好</p><p>除了互斥，其他条件都存在一些问题：</p><p>1、目前没有锁失效时间，如果解锁失败，就会导致锁记录永远留在数据库中，无法被其他线程获取，该方法就会永久不可用。</p><p>2、该锁不可重入，因为它不认识请求方是不是当前占用锁的线程。</p><p>3、该锁是非阻塞的，因为数据库插入操作失败会直接报错，线程只能再次请求获得锁。</p><p>4、当前数据库是单点，一旦宕机，锁机制就会完全崩坏。</p><p>解决方案：</p><p>1、针对锁失效问题，我们可以新增一个expire超时字段，在加锁时设置。然后另起一个线程，负责轮询删除表中超时的数据。</p><p>2、针对不可重入问题，我们可以再新增一个request_info字段，记录当前获取锁的线程的机器和线程信息，当相同的线程再次访问时，就可以识别放行了。</p><p>3、针对非阻塞，还是和redis实现一样，写一个while死循环，失败了不断重试，直到获取锁成功为止。</p><p>4、针对单点问题，通用方案就是配置主从数据库。</p><h1 id="数据库乐观锁实现"><a href="#数据库乐观锁实现" class="headerlink" title="数据库乐观锁实现"></a>数据库乐观锁实现</h1><p>乐观锁，系统认为数据的更新在大多数情况下是<strong>不会产生冲突</strong>的，只在数据库更新操作提交的时候才对数据作冲突检测。如果检测的结果出现了与预期数据不一致的情况，则返回失败信息。</p><p>乐观锁大多数是<strong>基于数据版本(version)</strong>的记录机制实现的。数据版本，即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表添加一个 “version”字段来实现读取出数据时，将此版本号一同读出，之后更新时，对此版本号加1。在更新过程中，会对版本号进行比较，如果是一致的，没有发生改变，则会成功执行本次操作；如果版本号不一致，则会更新失败。</p><p>为了更好的理解数据库乐观锁在实际项目中的使用，这里就列举一个典型的电商库存的例子。一个电商平台都会存在商品的库存，当用户进行购买的时候就会对库存进行操作（库存减1代表已经卖出了一件）。我们将这个库存模型用下面的一张表optimistic_lock来表述，参考如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`optimistic_lock`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`resource`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的资源'</span>,</span><br><span class="line"><span class="string">`version`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'版本信息'</span>,</span><br><span class="line"><span class="string">`created_at`</span> datetime <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line"><span class="string">`updated_at`</span> datetime <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line"><span class="string">`deleted_at`</span> datetime <span class="keyword">COMMENT</span> <span class="string">'删除时间'</span>, </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uiq_idx_resource`</span> (<span class="string">`resource`</span>) </span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COMMENT</span>=<span class="string">'数据库分布式锁表'</span>;</span><br></pre></td></tr></table></figure><p>其中：</p><p>id表示主键；</p><p>resource表示具体操作的资源，在这里也就是特指库存；</p><p>version表示版本号。</p><p>在使用乐观锁之前要确保表中有相应的数据，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> optimistic_lock(<span class="keyword">resource</span>, <span class="keyword">version</span>, created_at, updated_at) <span class="keyword">VALUES</span>(<span class="number">20</span>, <span class="number">1</span>, <span class="keyword">CURTIME</span>(), <span class="keyword">CURTIME</span>());</span><br></pre></td></tr></table></figure><p>如果只是一个线程进行操作，数据库本身就能保证操作的正确性。主要步骤如下：</p><p>STEP1 - 获取资源：<code>SELECT resource FROM optimistic_lock WHERE id = 1</code><br>STEP2 - 执行业务逻辑<br>STEP3 - 更新资源：<code>UPDATE optimistic_lock SET resource = resource -1 WHERE id = 1</code></p><p>然而在并发的情况下就会产生一些意想不到的问题：比如两个线程同时购买一件商品，在数据库层面实际操作应该是库存（resource）减2，但是由于是高并发的情况，第一个线程执行之后（执行了<strong>STEP1</strong>、<strong>STEP2</strong>但是还没有完成<strong>STEP3</strong>），第二个线程在购买相同的商品（执行<strong>STEP1</strong>），此时查询出的库存并没有完成减1的动作，那么最终会导致2个线程购买的商品却出现库存只减1的情况。</p><p>在引入了<code>version</code>字段之后，那么具体的操作就会演变成下面的内容：</p><p>STEP1 - 获取资源： <code>SELECT resource, version FROM optimistic_lock WHERE id = 1</code><br>STEP2 - 执行业务逻辑<br>STEP3 - 更新资源：<code>UPDATE optimistic_lock SET resource = resource -1, version = version + 1 WHERE id = 1 AND version = oldVersion</code></p><p>其实，借助更新时间戳（updated_at）也可以实现乐观锁，和采用<code>version</code>字段的方式相似：更新操作执行前线获取记录当前的更新时间，在提交更新时，检测当前更新时间是否与更新开始时获取的更新时间戳相等。</p><p>乐观锁的优点比较明显，由于在检测数据冲突时并不依赖数据库本身的锁机制，不会影响请求的性能，当产生并发且并发量较小的时候只有少部分请求会失败。缺点是需要对表的设计增加额外的字段，增加了数据库的冗余，另外，当应用<strong>并发量</strong>高的时候，<code>version</code>值在频繁变化，则会导致大量请求失败，影响系统的可用性。我们通过上述sql语句还可以看到，数据库锁都是作用于同一行数据记录上，这就导致一个明显的缺点，在一些特殊场景，如大促、秒杀等活动开展的时候，大量的请求同时请求同一条记录的行锁，会对数据库产生很大的写压力。所以综合数据库乐观锁的优缺点，乐观锁比较适合并发量不高，并且写操作不频繁的场景。</p><h1 id="数据库悲观锁"><a href="#数据库悲观锁" class="headerlink" title="数据库悲观锁"></a>数据库悲观锁</h1><p>除了可以通过增删操作数据库表中的记录以外，我们还可以借助数据库中自带的锁来实现分布式锁。在查询语句后面增加<code>FOR UPDATE</code>，数据库会在查询过程中给数据库表增加<strong>悲观锁</strong>，也称<strong>排他锁</strong>。当某条记录被加上悲观锁之后，其它线程也就无法再改行上增加悲观锁。</p><p>悲观锁，与乐观锁相反，总是假设最坏的情况，<strong>它认为数据的更新在大多数情况下是会产生冲突的</strong>。</p><p>在使用悲观锁的同时，我们需要注意一下锁的级别。<strong>MySQL InnoDB</strong>引起在加锁的时候，只有明确地指定主键(或索引)的才会执行<strong>行锁</strong> (只锁住被选取的数据)，否则MySQL 将会执行<strong>表锁</strong>(将整个数据表单给锁住)。</p><p>在使用悲观锁时，我们必须关闭<strong>MySQL</strong>数据库的自动提交属性（参考下面的示例），因为<strong>MySQL</strong>默认使用<strong>autocommit</strong>模式，也就是说，当你执行一个更新操作后，<strong>MySQL</strong>会立刻将结果进行提交。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET AUTOCOMMIT = 0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>上面的示例中演示了指定主键并且能查询到数据的过程（触发行锁），如果查不到数据那么也就无从“锁”起了。</p><p>如果未指定主键（或者索引）且能查询到数据，那么就会触发表锁，比如<strong>STEP1</strong>改为执行（这里的<code>version</code>只是当做一个普通的字段来使用，与上面的乐观锁无关）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> database_lock <span class="keyword">WHERE</span> description=<span class="string">'lock'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>或者主键不明确也会触发表锁，又比如<strong>STEP1</strong>改为执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> database_lock <span class="keyword">WHERE</span> <span class="keyword">id</span>&gt;<span class="number">0</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>虽然我们可以显示显式使用<strong>行级锁</strong>（指定可查询的主键或索引），但是<strong>MySQL</strong>会对查询进行优化，即便在条件中使用了索引字段，但是否真的使用索引来检索数据是由<strong>MySQL</strong>通过判断不同执行计划的代价来决定的，如果<strong>MySQL</strong>认为全表扫描效率更高，比如对一些很小的表，它有可能不会使用索引，在这种情况下<strong>InnoDB</strong>将使用<strong>表锁</strong>，而不是<strong>行锁</strong>。</p><p><strong>在悲观锁中</strong>，每一次行数据的访问都是独占的，只有当正在访问该行数据的请求事务提交以后，其他请求才能依次访问该数据，否则将阻塞等待锁的获取。悲观锁可以严格保证数据访问的安全。但是缺点也明显，即每次请求都会额外产生加锁的开销且未获取到锁的请求将会阻塞等待锁的获取，在高并发环境下，容易造成大量请求阻塞，影响系统可用性。另外，悲观锁使用不当还可能产生<strong>死锁</strong>的情况。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 分布式锁 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis实现分布式锁</title>
      <link href="/2020/03/20/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2020/03/20/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h1><p>包括：单机Redis的分布式锁、Redission可重入锁、Redission红锁</p><p>其中，Redission红锁可以解决分布式redis单点宕机故障转移存在的遗留问题</p><a id="more"></a><h2 id="单机redis的分布式锁"><a href="#单机redis的分布式锁" class="headerlink" title="单机redis的分布式锁"></a>单机redis的分布式锁</h2><p>关于代码的详细解释见代码注释。</p><p>单机redis详细参考：<a href="https://juejin.im/post/5b737b9b518825613d3894f4" target="_blank" rel="noopener">https://juejin.im/post/5b737b9b518825613d3894f4</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取分布式锁(加锁代码)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis分布式锁：</span></span><br><span class="line"><span class="comment">     * （1）如果一个key被设置value以后再使用setNX就不会成功set数据</span></span><br><span class="line"><span class="comment">     * （2）设置超时时间是防止获取锁的clientA断电了而无法释放锁，那么clientA所有的锁都无法释放</span></span><br><span class="line"><span class="comment">     * （3）一个set命令解决上面的问题，保持redis两个命令的原子性，否则多线程情况下会出setNX执行成功以后，超时时间设置失败，锁无法释放的问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁(解锁代码)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lua脚本将比较 keys与value是否相等</span></span><br><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else               return 0 end"</span>;</span><br><span class="line">        </span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), C                                                   ollections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁参考：<a href="https://crazyfzw.github.io/2019/04/15/distributed-locks-with-redis/" target="_blank" rel="noopener">https://crazyfzw.github.io/2019/04/15/distributed-locks-with-redis/</a><br>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还实现了可重入锁（Reentrant Lock）、公平锁（Fair Lock、联锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）等，还提供了许多分布式服务。Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><p>Redisson 支持单点模式、主从模式、哨兵模式、集群模式，这里以单点模式为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构造redisson实现分布式锁必要的Config</span></span><br><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:5379"</span>).setPassword(<span class="string">"123456"</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2.构造RedissonClient</span></span><br><span class="line">RedissonClient redissonClient = Redisson.create(config);</span><br><span class="line"><span class="comment">// 3.获取锁对象实例（无法保证是按线程的顺序获取到）</span></span><br><span class="line">RLock rLock = redissonClient.getLock(lockKey);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4.尝试获取锁</span></span><br><span class="line"><span class="comment">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span><br><span class="line"><span class="comment">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">boolean</span> res = rLock.tryLock((<span class="keyword">long</span>)waitTimeout, (<span class="keyword">long</span>)leaseTime, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="comment">//成功获得锁，在这里处理业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"aquire lock fail"</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//无论如何, 最后都要解锁</span></span><br><span class="line">    rLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取锁的代码的核心流程：tryLock -&gt; tryAcquire -&gt; <code>org.redisson.RedissonLock#tryLockInnerAsync</code></p><p><img data-src="20200112170104275.png" alt="img"></p><p>释放锁的过程：<code>org.redisson.RedissonLock#unlockInnerAsync</code></p><p><img data-src="20200112170300708.png" alt="img"></p><p>需要特别注意的是，RedissonLock 同样没有解决单节点挂掉的时候，存在丢失锁的风险的问题。而现实情况是有一些场景无法容忍的，所以 Redisson 提供了实现了redlock算法的 RedissonRedLock。</p><h2 id="Redission红锁"><a href="#Redission红锁" class="headerlink" title="Redission红锁"></a>Redission红锁</h2><p>在我们的例子里面我们把N设成5，这是一个比较合理的设置，所以我们需要在5台机器上面或者5台虚拟机上面运行这些实例，这样保证他们不会同时都宕掉。为了取到锁，客户端应该执行以下操作:</p><p>获取当前Unix时间，以毫秒为单位。</p><p>依次尝试从5个实例，使用相同的key和具有唯一性的value（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个尝试从某个Reids实例获取锁的最大等待时间（超过这个时间，则立马询问下一个实例），这个超时时间应该小于锁的失效时间。</p><p>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁消耗的时间。当且仅当从大多数（N/2+1，这里是3个节点）的Redis节点都取到锁，并且使用的总耗时小于锁失效时间时，锁才算获取成功。</p><p>如果取到了锁，key的真正有效时间 = 有效时间（获取锁时设置的key的自动超时时间） - 获取锁的总耗时（询问各个Redis实例的总耗时之和）（步骤3计算的结果）。</p><p>如果因为某些原因，最终获取锁失败（即没有在至少 “N/2+1 ”个Redis实例取到锁或者“获取锁的总耗时”超过了“有效时间”），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，这样可以防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</p><p>Redission使用RedLock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Config config1 = <span class="keyword">new</span> Config();</span><br><span class="line">config1.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5378"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">RedissonClient redissonClient1 = Redisson.create(config1);</span><br><span class="line"></span><br><span class="line">Config config2 = <span class="keyword">new</span> Config();</span><br><span class="line">config2.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5379"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">RedissonClient redissonClient2 = Redisson.create(config2);</span><br><span class="line"></span><br><span class="line">Config config3 = <span class="keyword">new</span> Config();</span><br><span class="line">config3.useSingleServer().setAddress(<span class="string">"redis://172.0.0.1:5380"</span>).setPassword(<span class="string">"a123456"</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">RedissonClient redissonClient3 = Redisson.create(config3);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取多个 RLock 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RLock lock1 = redissonClient1.getLock(lockKey);</span><br><span class="line">RLock lock2 = redissonClient2.getLock(lockKey);</span><br><span class="line">RLock lock3 = redissonClient3.getLock(lockKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据多个 RLock 对象构建 RedissonRedLock （最核心的差别就在这里）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RedissonRedLock redLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4.尝试获取锁</span></span><br><span class="line"><span class="comment">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span><br><span class="line"><span class="comment">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">boolean</span> res = redLock.tryLock((<span class="keyword">long</span>)waitTimeout, (<span class="keyword">long</span>)leaseTime, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="comment">//成功获得锁，在这里处理业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"aquire lock fail"</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//无论如何, 最后都要解锁</span></span><br><span class="line">    redLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁核心源码：<br>RedLock加锁类似于paxos这种分布式一致性算法，当有超过半数的Redis节点加锁成功以后才认为加锁成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> newLeaseTime = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        newLeaseTime = unit.toMillis(waitTime)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> remainTime = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (waitTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        remainTime = unit.toMillis(waitTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> lockWaitTime = calcLockWaitTime(remainTime);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 允许加锁失败节点个数限制（N-(N/2+1)）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> failedLocksLimit = failedLocksLimit();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 遍历所有节点通过EVAL命令执行lua加锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;RLock&gt; acquiredLocks = <span class="keyword">new</span> ArrayList&lt;&gt;(locks.size());</span><br><span class="line">    <span class="keyword">for</span> (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) &#123;</span><br><span class="line">        RLock lock = iterator.next();</span><br><span class="line">        <span class="keyword">boolean</span> lockAcquired;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  3.对节点尝试加锁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (waitTime == -<span class="number">1</span> &amp;&amp; leaseTime == -<span class="number">1</span>) &#123;</span><br><span class="line">                lockAcquired = lock.tryLock();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> awaitTime = Math.min(lockWaitTime, remainTime);</span><br><span class="line">                lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RedisResponseTimeoutException e) &#123;</span><br><span class="line">            <span class="comment">// 如果抛出这类异常，为了防止加锁成功，但是响应失败，需要解锁所有节点</span></span><br><span class="line">            unlockInner(Arrays.asList(lock));</span><br><span class="line">            lockAcquired = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 抛出异常表示获取锁失败</span></span><br><span class="line">            lockAcquired = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (lockAcquired) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *4. 如果获取到锁则添加到已获取锁集合中</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            acquiredLocks.add(lock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 5. 计算已经申请锁失败的节点是否已经到达 允许加锁失败节点个数限制 （N-(N/2+1)）</span></span><br><span class="line"><span class="comment">             * 如果已经到达， 就认定最终申请锁失败，则没有必要继续从后面的节点申请了</span></span><br><span class="line"><span class="comment">             * 因为 Redlock 算法要求至少N/2+1 个节点都加锁成功，才算最终的锁申请成功</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (locks.size() - acquiredLocks.size() == failedLocksLimit()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (failedLocksLimit == <span class="number">0</span>) &#123;</span><br><span class="line">                unlockInner(acquiredLocks);</span><br><span class="line">                <span class="keyword">if</span> (waitTime == -<span class="number">1</span> &amp;&amp; leaseTime == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                failedLocksLimit = failedLocksLimit();</span><br><span class="line">                acquiredLocks.clear();</span><br><span class="line">                <span class="comment">// reset iterator</span></span><br><span class="line">                <span class="keyword">while</span> (iterator.hasPrevious()) &#123;</span><br><span class="line">                    iterator.previous();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                failedLocksLimit--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 6.计算 目前从各个节点获取锁已经消耗的总时间，如果已经等于最大等待时间，则认定最终申请锁失败，返回false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (remainTime != -<span class="number">1</span>) &#123;</span><br><span class="line">            remainTime -= System.currentTimeMillis() - time;</span><br><span class="line">            time = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                unlockInner(acquiredLocks);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;(acquiredLocks.size());</span><br><span class="line">        <span class="keyword">for</span> (RLock rLock : acquiredLocks) &#123;</span><br><span class="line">            RFuture&lt;Boolean&gt; future = ((RedissonLock) rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (RFuture&lt;Boolean&gt; rFuture : futures) &#123;</span><br><span class="line">            rFuture.syncUninterruptibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 7.如果逻辑正常执行完则认为最终申请锁成功，返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 分布式锁 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper实现分布式锁</title>
      <link href="/2020/03/18/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2020/03/18/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="集群环境下保证ID不重复"><a href="#集群环境下保证ID不重复" class="headerlink" title="集群环境下保证ID不重复"></a>集群环境下保证ID不重复</h2><p>原来的Synchronized + Lock只能锁单机，也就是只能在一个JVM环境下</p><a id="more"></a><p><img data-src="image-20200403221837957.png" alt="image"></p><p>而在分布式+集群的环境下，变成了N对N的关系，在并发的环境下，如果使用UUID或者自增ID，就可能出现ID重复的问题，因此在集群下的环境下，对JVM进行加锁，这就是分布式锁。</p><p><img data-src="image-20200403222011539.png" alt="image"></p><p>在小厂的解决方案：也就是QPS &lt; 2000的公司，有以下三种方案</p><ul><li>mysql数据库的乐观锁实现</li><li>redis：redission</li><li>zookeeper：（服务治理 和 服务注册）</li></ul><h2 id="ZooKeeper实现分布式锁"><a href="#ZooKeeper实现分布式锁" class="headerlink" title="ZooKeeper实现分布式锁"></a>ZooKeeper实现分布式锁</h2><p>因为Zookeeper在创建节点的时候，需要保证节点的唯一性，也就是实现原理就是，每次一个线程获取到了锁，那就在Zookeeper上创建一个临时节点，但用完锁之后，在把这个节点删除掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create &#x2F;node v0410  # 创建一个持久节点</span><br><span class="line">crate -e &#x2F;node v0410 # 创建一个临时节点</span><br></pre></td></tr></table></figure><p>对于单进程的并发场景，我们可以使用synchronized关键字和Reentrantlock等</p><p>对于 分布式场景，我们可以使用分布式锁。</p><h3 id="创建锁"><a href="#创建锁" class="headerlink" title="创建锁"></a>创建锁</h3><p>多个JVM服务器之间，同时在zookeeper上创建相同一个临时节点，因为临时节点路径是保证唯一，只要谁能创建节点成功，谁就能获取到锁。</p><p>没有创建成功节点，只能注册个监听器监听这个锁并进行等待，当释放锁的时候，采用事件通知给其它客户端重新获取锁的资源。</p><p>这时候客户端使用事件监听，如果该临时节点被删除的话，重新进入获取锁的步骤。</p><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>Zookeeper使用直接关闭临时节点session会话连接，因为临时节点生命周期与session会话绑定在一块，如果session会话连接关闭，该临时节点也会被删除，这时候客户端使用事件监听，如果该临时节点被删除的话，重新进入到获取锁的步骤。</p><h2 id="单机环境下的锁"><a href="#单机环境下的锁" class="headerlink" title="单机环境下的锁"></a>单机环境下的锁</h2><p>假设我们现在有一个订单ID生成的工具类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: 2020-03-19</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class OrderNumberCreateUtil &#123;</span><br><span class="line">    private static int num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public String getOrderNumber() &#123;</span><br><span class="line">        return &quot;\t 生成订单号：&quot; + (++num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后有一个OrderService服务类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 订单业务逻辑</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: 2020-03-19</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class OrderService &#123;</span><br><span class="line">    private OrderNumberCreateUtil orderNumberCreateUtil &#x3D; new OrderNumberCreateUtil();</span><br><span class="line"></span><br><span class="line">    public String getOrderNumber() &#123;</span><br><span class="line">        return orderNumberCreateUtil.getOrderNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们客户端有50个线程进行访问获取订单号的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 客户端</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: 2020-03-19</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OrderService orderService &#x3D; new OrderService();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 50; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                String str &#x3D; orderService.getOrderNumber();</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们能够发现。订单号1出现了两次，这就是我们在并发访问的时候，会出现问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">生成订单号：1</span><br><span class="line">生成订单号：3</span><br><span class="line">生成订单号：2</span><br><span class="line">生成订单号：4</span><br><span class="line">生成订单号：5</span><br><span class="line">生成订单号：1</span><br><span class="line">生成订单号：6</span><br><span class="line">生成订单号：7</span><br><span class="line">生成订单号：8</span><br><span class="line">生成订单号：9</span><br><span class="line">生成订单号：10</span><br><span class="line">生成订单号：11</span><br><span class="line">生成订单号：12</span><br><span class="line">生成订单号：13</span><br><span class="line">生成订单号：14</span><br><span class="line">生成订单号：15</span><br><span class="line">生成订单号：16</span><br><span class="line">生成订单号：17</span><br><span class="line">生成订单号：18</span><br><span class="line">生成订单号：20</span><br><span class="line">生成订单号：21</span><br><span class="line">生成订单号：19</span><br><span class="line">生成订单号：22</span><br><span class="line">生成订单号：23</span><br><span class="line">生成订单号：24</span><br><span class="line">生成订单号：25</span><br><span class="line">生成订单号：26</span><br><span class="line">生成订单号：27</span><br><span class="line">生成订单号：28</span><br><span class="line">生成订单号：30</span><br><span class="line">生成订单号：31</span><br><span class="line">生成订单号：29</span><br><span class="line">生成订单号：32</span><br><span class="line">生成订单号：33</span><br><span class="line">生成订单号：34</span><br><span class="line">生成订单号：35</span><br><span class="line">生成订单号：36</span><br><span class="line">生成订单号：37</span><br><span class="line">生成订单号：38</span><br><span class="line">生成订单号：40</span><br><span class="line">生成订单号：39</span><br><span class="line">生成订单号：41</span><br><span class="line">生成订单号：42</span><br><span class="line">生成订单号：43</span><br><span class="line">生成订单号：44</span><br><span class="line">生成订单号：49</span><br><span class="line">生成订单号：48</span><br><span class="line">生成订单号：47</span><br><span class="line">生成订单号：46</span><br><span class="line">生成订单号：45</span><br></pre></td></tr></table></figure><p>解决方案是，在Service下，加锁解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String getOrderNumber() &#123;</span><br><span class="line">    Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        return orderNumberCreateUtil.getOrderNumber();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分布式环境下的锁"><a href="#分布式环境下的锁" class="headerlink" title="分布式环境下的锁"></a>分布式环境下的锁</h2><h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>在模板模式（Template Pattern）设计模式中，用一个抽象类公开定义了执行它的方法的方式、模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行</p><p>意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构，即可重定义该算法的某些特定步骤：</p><p>主要解决：一些方法通用，却在每个子类都重新写了这一方法</p><p>何时使用：在一些通用的方法</p><p>如何解决：将这些通用算法抽象出来</p><p>关键代码：在抽象父类中实现通用方法，其它步骤下放到子类中实现</p><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><ul><li>西游记里面菩萨定义好了81难，不管是女儿国，或者蜘蛛精，只需要有81劫难，这就是一个顶层的逻辑骨架</li><li>spring中对Hibernate的支持，将一些定好的方法封装起来，比如开启事务，获取Session，关闭Session，程序要不需要重复写那些已经规范好的代码，直接丢一个实体就可以保存。</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>封装不变部分，扩展可变部分</li><li>提取公共代码，便于维护</li><li>行为由父类控制，子类实现</li><li>缺点是：每一个不同的实现，都需要一个子类来实现，导致类的个数增加，使得系统变庞大</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>有很多子类共有的方法，且逻辑相同</li><li>重要的、复杂的方法，可以考虑模板方法</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>例如，我们首先定义一个zkLock的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * ZkLock</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: 2020-03-19</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface ZkLock &#123;</span><br><span class="line"></span><br><span class="line">    public void zkLock();</span><br><span class="line"></span><br><span class="line">    public void zkUnlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在抽象类中继承该接口，同时实现zkLock 和 zkUnLock的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * ZkLock抽象类</span><br><span class="line"> * 这就是模板设计模式</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: 2020-03-19</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract class ZkAbstractTemplateLock implements ZkLock&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void zkLock() &#123;</span><br><span class="line">        &#x2F;&#x2F; 尝试获取锁</span><br><span class="line">        if(tryLock()) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 占用锁成功&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 等待锁</span><br><span class="line">            waitZkLock();</span><br><span class="line">            &#x2F;&#x2F; 重新调用获取锁的方法</span><br><span class="line">            zkLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义两个抽象方法，一个是尝试锁，一个是等待锁</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public abstract boolean tryLock();</span><br><span class="line"></span><br><span class="line">    public abstract void waitZkLock();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void zkUnlock() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们在抽象类里，又定义了两个抽象方法，zkWaitLock()  和 tryLock</p><p>最后我们是具体的实现方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 分布式锁</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: 2020-03-19</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ZkDistributedLock extends ZkAbstractTemplateLock&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断节点是否存在，如果存在则返回false，否者返回true</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void waitZkLock() throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F; 等待锁的时候，需要加监控，查询这个lock是否释放</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 解除监听</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后我们通过ZkDistributedLock进行加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 订单业务逻辑</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: 2020-03-19</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class OrderService &#123;</span><br><span class="line">    private OrderNumberCreateUtil orderNumberCreateUtil &#x3D; new OrderNumberCreateUtil();</span><br><span class="line"></span><br><span class="line">    public void getOrderNumber() &#123;</span><br><span class="line">        ZkLock zkLock &#x3D; new ZkDistributedLock();</span><br><span class="line">        zkLock.zkLock();</span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            zkLock.zkUnlock();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(orderNumberCreateUtil.getOrderNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在使用多个线程进行操作，而且是在线程里面实例化对象，来进行创建，最终保证每个对象再获取订单的时候，都是唯一的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 客户端</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @date: 2020-03-19</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 50; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                new OrderService().getOrderNumber();</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
            <tag> 分布式锁 </tag>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务及其解决方案</title>
      <link href="/2020/03/17/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2020/03/17/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式事务及其解决方案"><a href="#分布式事务及其解决方案" class="headerlink" title="分布式事务及其解决方案"></a>分布式事务及其解决方案</h1><h2 id="分布式事务出现的场景"><a href="#分布式事务出现的场景" class="headerlink" title="分布式事务出现的场景"></a>分布式事务出现的场景</h2><p>当北京的数据库向上海的数据库转账时，怎么保证转账的事务性？这就出现了分布式事务的问题。</p><p>下面来讨论一下分布式事务的解决方案，主要包括：两阶段提交，TCC和tx-lcn框架。</p><a id="more"></a><p><img data-src="20200110123431170.png" alt="img"></p><h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p>下面就是两阶段提交的过程：</p><p><img data-src="20200110123739795.png" alt="img"></p><h3 id="第一阶段："><a href="#第一阶段：" class="headerlink" title="第一阶段："></a>第一阶段：</h3><p>事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.</p><h3 id="第二阶段："><a href="#第二阶段：" class="headerlink" title="第二阶段："></a>第二阶段：</h3><p>事务协调器要求每个数据库提交数据，或者回滚数据。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h4 id="单点问题"><a href="#单点问题" class="headerlink" title="单点问题"></a>单点问题</h4><p>事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</p><h4 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h4><p>在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。</p><h4 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h4><p>两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</p><h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><p>tcc就是将提交分为了3步：</p><p><img data-src="20200110123954542.png" alt="img"></p><p>对于TCC的解释:</p><h3 id="Try阶段"><a href="#Try阶段" class="headerlink" title="Try阶段"></a>Try阶段</h3><p>尝试执行,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）</p><h3 id="Confirm阶段"><a href="#Confirm阶段" class="headerlink" title="Confirm阶段"></a>Confirm阶段</h3><p>确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。</p><h3 id="Cancel阶段"><a href="#Cancel阶段" class="headerlink" title="Cancel阶段"></a>Cancel阶段</h3><p>取消执行，释放Try阶段预留的业务资源<br>Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。</p><p>对于TCC来说适合一些:</p><p>强隔离性，严格一致性要求的活动业务。<br>执行时间较短的业务</p><h2 id="tx-lcn框架"><a href="#tx-lcn框架" class="headerlink" title="tx-lcn框架"></a>tx-lcn框架</h2><p>至于tx-lcn的使用,参考官方文档 :<a href="http://www.txlcn.org/zh-cn/docs/demo/env.html" target="_blank" rel="noopener">http://www.txlcn.org/zh-cn/docs/demo/env.html</a></p><h3 id="事务控制的原理："><a href="#事务控制的原理：" class="headerlink" title="事务控制的原理："></a>事务控制的原理：</h3><p>TX-LCN由两大模块组成, TxClient、TxManager，TxClient作为模块的依赖框架，提供TX-LCN的标准支持，TxManager作为分布式事务的控制方。事务发起方或者参与反都由TxClient端来控制。</p><p><img data-src="20200110124507414.png" alt="img"></p><h3 id="模式一：lcn"><a href="#模式一：lcn" class="headerlink" title="模式一：lcn"></a>模式一：lcn</h3><p>LCN模式是通过代理Connection的方式实现对本地事务的操作，然后在由TxManager统一协调控制事务。当本地事务提交回滚或者关闭连接时将会执行假操作，该代理的连接将由LCN连接池管理。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>该模式对代码的嵌入性为低。<br>该模式仅限于本地存在连接对象且可通过连接对象控制事务的模块。<br>该模式下的事务提交与回滚是由本地事务方控制，对于数据一致性上有较高的保障。<br>该模式缺陷在于代理的连接需要随事务发起方一共释放连接，增加了连接占用的时间。</p><h3 id="模式二：tcc"><a href="#模式二：tcc" class="headerlink" title="模式二：tcc"></a>模式二：tcc</h3><p>TCC事务机制相对于传统事务机制（X/Open XA Two-Phase-Commit），其特征在于它不依赖资源管理器(RM)对XA的支持，而是通过对（由业务系统提供的）业务逻辑的调度来实现分布式事务。主要由三步操作，Try: 尝试执行业务、 Confirm:确认执行业务、 Cancel: 取消执行业务。</p><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>该模式对代码的嵌入性高，要求每个业务需要写三种步骤的操作。<br>该模式对有无本地事务控制都可以支持使用面广。<br>数据一致性控制几乎完全由开发者控制，对业务开发难度要求高。</p><h3 id="模式三-txc"><a href="#模式三-txc" class="headerlink" title="模式三:txc"></a>模式三:txc</h3><p>TXC模式命名来源于淘宝，实现原理是在执行SQL之前，先查询SQL的影响数据，然后保存执行的SQL快走信息和创建锁。当需要回滚的时候就采用这些记录数据回滚数据库，目前锁实现依赖redis分布式锁控制。</p><h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><p>该模式同样对代码的嵌入性低。<br>该模式仅限于对支持SQL方式的模块支持。<br>该模式由于每次执行SQL之前需要先查询影响数据，因此相比LCN模式消耗资源与时间要多。<br>该模式不会占用数据库的连接资源。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL搜索引擎</title>
      <link href="/2020/03/15/MySQL%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
      <url>/2020/03/15/MySQL%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql默认搜索引擎"><a href="#Mysql默认搜索引擎" class="headerlink" title="Mysql默认搜索引擎"></a>Mysql默认搜索引擎</h2><p>Mysql5.5以后默认使用InnoDB为搜索引擎</p><p>MyISAM是表锁，不支持事务和主外键</p><a id="more"></a><p><img data-src="image-20200404084731063.png" alt="image"></p><p>InnoDB默认可以创建16个索引</p><ul><li>InnoDB支持事务，MyIsam不支持事务，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放到begin 和 commit之间，组成一个事务；</li><li>InnoDB支持外键，而MyIsam不支持，对一个包含外键的InnoDB表转成MyIsam表会失败</li><li>InnoDB是聚集索引，数据文件和索引绑定在一块，必须要有主键，通过主键索引效率很高，但是辅助索引需要两次查询，先查询到主键，然后在通过主键查询到数据。因此主键不应该过大。主键过大的时候，其它索引也会很大。而MyIsam是非聚集索引，数据和文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。</li><li>InnoDB不支持全文检索，而MyIsam支持全文检索，查询效率上MyIsam要高</li></ul><h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p><img data-src="image-20200404085422944.png" alt="image"></p><p>Mysql是存储在硬盘上，因此Redis比Mysql快</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>Mysql官方对索引的定位为：索引是帮助Mysql高效获取数据的数据结构，可以得到索引的本质就是，索引是数据结构。</p><p>可以简单的理解为：排好序的快速查找B+树数据结构，B+树中的B代表平衡(balance) 而不是 二叉（binary）</p><h2 id="检索原理"><a href="#检索原理" class="headerlink" title="检索原理"></a>检索原理</h2><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据上实现高级查找算法，这种数据结构，就是索引。下图就是一种可能的索引方式示例：</p><p><img data-src="image-20200404090022629.png" alt="image"></p><p>为了加快Col2的查找，可以维护一个左边所示的二叉树，每个节点分别包含索引键值和一个指向对应数据记录的物理地址的指针，这样就可以运用二叉树在一定的复杂度内获取相应数据，从而快速的检索出符合条件的记录。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B树：Balance Tree，多路平衡查找树</p><p>B+树：加强版多路平衡查找树</p><p>tip：没有B-树，B-树就是B树，中间不是减号而是横线</p><h2 id="Mysql搜索引擎的发展之路"><a href="#Mysql搜索引擎的发展之路" class="headerlink" title="Mysql搜索引擎的发展之路"></a>Mysql搜索引擎的发展之路</h2><p>Mysql InnoDB的搜索引擎 的 底层也不是一来就是 B+树的，而是经过了不断的迭代过程</p><ul><li>全部遍历</li><li>Hash</li><li>二叉树</li><li>平衡二叉树（AVL）</li><li>B树</li><li>B+树</li></ul><h3 id="全部遍历"><a href="#全部遍历" class="headerlink" title="全部遍历"></a>全部遍历</h3><p>相当于全表查询，把每条数据都查找一遍</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>加速查找速度的数据结构，常见的有两类</p><ul><li>哈希，例如HashMap，查询、插入、修改、删除的平均时间复杂度都是O(1)</li><li>树：例如平衡二叉搜索树，查询、插入、修改、删除的平均事件复杂度都是O(log<sub>2</sub> (n))</li></ul><p>可以看到，不管是读请求，还是写请求，哈希类型的索引，都要比树型的索引更快一些，为什么不用Hash做索引呢，而要设计成树型结构呢？</p><p>假设SQL语句为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where age &#x3D; 15</span><br></pre></td></tr></table></figure><p>我们能够通过Hash就可以很好的用Hash进行解决</p><p>但是随着SQL的复杂化，对于以下范围查找，Hash就搞不定了，也就是说Hash就只能解决查1的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where age &gt; 15 and age &lt; 20</span><br></pre></td></tr></table></figure><p>想想范围/排序等其它SQL条件：</p><p>哈希型的索引，时间复杂度会退化O(n) 而树型的“有序” 特性，依然能够保持 O(log<sub>2</sub>(n) )</p><p>InnoDB：并不支持Hash索引</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树的特点</p><ul><li>一个节点只能有两个子节点，也就是一个节点的度不能超过2</li><li>左子节点小于本节点，右子节点大于等于本节点，比我大的向右，比我小的向做</li></ul><p><img data-src="image-20200404093846645.png" alt="image"></p><p>对该二叉树的节点查找发现：</p><p>深度为1的节点查找次数为：1</p><p>深度为2的节点查找次数为：2</p><p>深度为N的节点查找次数为：N</p><p>结论：因此其平均查找长度为：(1+2+2+3+3+3) / 6 = 2.3次</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>如果ID是持续递增的话，会出现什么样的结构？</li></ul><p><img data-src="image-20200404094336765.png" alt="image"></p><p>这样树型结构，又会退化到 O(n) 的时间复杂度</p><h3 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h3><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img data-src="image-20200404094719626.png" alt="image"></p><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>可以看出平衡二叉树的缺点就是</p><ul><li>维护平衡过程的成本代价很高，因为每次删除一个节点或者增加一个节点的话，需要一次或多次的左旋和右旋去维护平衡状态</li><li>查询的效率不稳定，还要看运气的成分在里面</li><li>如果节点很多的话，那么这个AVL树的高度还是会很高的，查询效率会很低。</li></ul><p>从算法的数学逻辑来讲，二叉树的查找速度和比较次数都是最小的，那为什么我们选择BTree?因为AVL还有一个问题，那就是 磁盘IO的问题</p><ul><li>磁盘IO的次数，就是由树高来决定的，也即磁盘的IO次数最坏的情况下就等于树的高度。</li></ul><p>因为节点存储的数据太少，没有很好的利用操作系统和磁盘数据交换的特性，也没有利用好磁盘IO的预读能力。因为操作系统和磁盘之间一次数据交换是以页为单位的，一页 = 4K，即每次IO操作系统会将4K数据加载镜像内存。但是在二叉树每个节点的结构只保存一个关键字 和 数据区，两个子节点的引用，并不能填满4K的内容，辛辛苦苦的做了一次IO操作，却只加载了一个关键字，在树的高度很高，恰好要搜索的关键字位于叶子节点或支节点的时候，取一个关键字要做很多次的IO。因此平衡二叉树不太适合MySQL的查询结构。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>我们需要解决的就是树的高度问题，导致磁盘IO过多</p><p>那么就需要将树进行压缩，也就是将原来的瘦高 -&gt; 矮胖，通过降低树的高度达到减少IO的次数</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树，又被称为 2-3树，也就是B树上的节点，可能是2，也可能是3</p><h4 id="结构图："><a href="#结构图：" class="headerlink" title="结构图："></a>结构图：</h4><p><img data-src="image-20200404100139814.png" alt="image"></p><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><p>数据库索引是存储在磁盘上的，如果数据很大，必然导致索引的大小也会很大，超过几个G（好比新华字典字数多必然导致目录厚）</p><p>当我们利用索引查询时，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：</p><p>逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p><p>InnoDB的 page_size</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#39;Innodb_page_size&#39;;</span><br></pre></td></tr></table></figure><p><img data-src="image-20200404151334993.png" alt="image"></p><p>系统从磁盘读取数据到内存时是以磁盘块（block）为单位的，位于同一磁盘块中的数据会被一次性读取出来，而不是需要什么取什么</p><p>InnoDB存储引擎中有页(Page)的概念，页是其磁盘管理的最小单位。</p><p>系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中每条数据都有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高效率。</p><p>一句话说：就是多个块填充到一页大小</p><h4 id="检索原理-1"><a href="#检索原理-1" class="headerlink" title="检索原理"></a>检索原理</h4><p>B树比平衡二叉树减少了一次IO操作</p><p><img data-src="image-20200404152149658.png" alt="image"></p><p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。</p><p>模拟查找关键字29的过程</p><ul><li>根据根节点找到磁盘块1，读入内存【磁盘IO操作1次】</li><li>比较关键字29在区间(17, 35)，找到磁盘块1的指针P2。</li><li>根据P2指针找到磁盘块3，读入内存。【磁盘IO操作第2次】</li><li>比较关键字29在区间(26, 30)，找到磁盘块3的指针P2。</li><li>根据P2指针找到磁盘块8，读入内存。【磁盘IO操作3次】</li><li>在磁盘块8中的关键字列表，找到关键字29</li></ul><p>分析上述过程，发现需要3次IO操作，和3次内存查找操作，由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘IO操作是影响整个BTree查找效率的决定性因素。BTree相对于AVLTree缩减了节点个数，使每次磁盘IO取到内存的数据都发挥了作用，从而提高了查找效率。</p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>B+树把所有数据放在叶子节点，形成了链表，我们查找数据更方便</p><p>好查，好排序，好划定范围</p><h4 id="B-树结构图"><a href="#B-树结构图" class="headerlink" title="B+树结构图"></a>B+树结构图</h4><p><img data-src="image-20200404155456211.png" alt="image"></p><p>把两种数据结构集成在一块了：树 + 链表</p><p>图中可以看出所有的data信息都移动叶子节点中，而且子节点和子节点之间会有指针指向，这个也是B+树的核心点，这样可以大大提升范围查找效率，也方便遍历整个树。</p><ul><li>非叶子节点不在存储数据，数据只存储在同一层的叶子节点上</li><li>叶子之间，增加链表，获取所有节点，不再需要中序遍历</li><li>这也说明了，B+树的检索性能比B树强</li></ul><h4 id="检索原理-2"><a href="#检索原理-2" class="headerlink" title="检索原理"></a>检索原理</h4><p>由于B+树的非叶子只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，那就变成如下结构</p><p><img data-src="image-20200404161422032.png" alt="image"></p><p>B树结构图中可以看出每个节点不仅包含数据的key值，还有data值，而每一页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储数量很大时同样会导致B树的深度较大，增大查询时的磁盘IO次数进而影响查询效率。</p><h2 id="Mysql为什么是B-树"><a href="#Mysql为什么是B-树" class="headerlink" title="Mysql为什么是B+树"></a>Mysql为什么是B+树</h2><p>B+树中，所有数据记录节点都是按照键值大小顺序存放在同一层叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+树的高度。</p><ul><li>InnoDB存储引擎的最小存储单元是页，页可以用于存放数据，也可以用于存放键值+指针，在B+树中叶子节点存放数据，而非叶子节点存放键值+指针</li><li>索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，首先找到根页进而去数据页查找到需要的数据</li></ul><p>B+树算法：通过集成B树的特征，B+树相比B树，新增叶子节点与非叶子节点关系，叶子节点包含了键值和数据，非叶子节点只是包含键值和子节点引用，不包含数据。</p><p>通过非叶子节点查询叶子节点获取相应的数据，所有相邻的叶子节点包含非叶子节点使用链表进行结合，叶子节点是顺序并且相邻节点有顺序引用关系。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>从B树到B+树，B+树在B树的基础上的一种优化使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+树实现的索引结构</p><p>B树和B+树的不同之处</p><ul><li>非叶子节点只存储键值信息</li><li>所有叶子节点之间都有一个链指针</li><li>数据记录都存放在叶子节点中</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL读写分离及主从时延</title>
      <link href="/2020/03/12/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8F%8A%E4%B8%BB%E4%BB%8E%E6%97%B6%E5%BB%B6/"/>
      <url>/2020/03/12/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8F%8A%E4%B8%BB%E4%BB%8E%E6%97%B6%E5%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL读写分离及主从时延"><a href="#MySQL读写分离及主从时延" class="headerlink" title="MySQL读写分离及主从时延"></a>MySQL读写分离及主从时延</h1><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li>如何实现mysql的读写分离？</li><li>MySQL主从复制原理的是啥？</li><li>如何解决mysql主从同步的延时问题？</li></ul><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>高并发这个阶段，肯定是需要做读写分离的，大部分的互联网公司，一些网站，或者是app，都是读多写少。所以针对这个情况，就是写一个主库，但是主库挂多个从库，然后从多个从库来读，就可以支撑更高的读并发压力了。</p><h2 id="如何实现mysql的读写分离？"><a href="#如何实现mysql的读写分离？" class="headerlink" title="如何实现mysql的读写分离？"></a>如何实现mysql的读写分离？</h2><p>其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。一般情况下，主库可以挂4-5个从库</p><p><img data-src="01_%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E8%A6%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%EF%BC%9F.png" alt="img_为什么MySQL要读写分离？"></p><h2 id="MySQL主从复制原理的是啥？"><a href="#MySQL主从复制原理的是啥？" class="headerlink" title="MySQL主从复制原理的是啥？"></a>MySQL主从复制原理的是啥？</h2><p>MySQL里有一个概念，叫binlog日志，就是每个增删改类的操作，会改变数据的操作，除了更新数据以外，对这个增删改操作还会写入一个日志文件，记录这个操作的日志。</p><p>主库将变更写binlog日志，然后从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中。接着从库中有一个SQL线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再次执行一遍SQL，这样就可以保证自己跟主库的数据是一样的。</p><p>这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行SQL的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p><p>而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。</p><p>所以mysql实际上在这一块有两个机制，一个是半同步复制，用来解决主库数据丢失问题；一个是并行复制，用来解决主从同步延时问题。</p><p>这个所谓半同步复制，semi-sync复制，指的就是主库写入binlog日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了。</p><p>所谓并行复制，指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。</p><ul><li>主从复制的原理</li><li>主从延迟问题产生的原因</li><li>主从复制的数据丢失问题，以及半同步复制的原理</li><li>并行复制的原理，多库并发重放relay日志，缓解主从延迟问题</li></ul><p><img data-src="02_MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.png" alt="img_MySQL主从复制原理"></p><h2 id="MySQL主从同步延时问题（重点）"><a href="#MySQL主从同步延时问题（重点）" class="headerlink" title="MySQL主从同步延时问题（重点）"></a>MySQL主从同步延时问题（重点）</h2><p>线上确实处理过因为主从同步延时问题，导致的线上的bug，小型的生产事故</p><p> show status，Seconds_Behind_Master，你可以看到从库复制主库的数据落后了几ms</p><p> 其实这块东西我们经常会碰到，就比如说用了mysql主从架构之后，可能会发现，刚写入库的数据结果没查到，结果就完蛋了。。。。</p><p> 所以实际上你要考虑好应该在什么场景下来用这个mysql主从同步，建议是一般在读远远多于写，而且读的时候一般对数据时效性要求没那么高的时候，用mysql主从同步</p><p> 所以这个时候，我们可以考虑的一个事情就是，你可以用mysql的并行复制，但是问题是那是库级别的并行，所以有时候作用不是很大</p><p> 所以这个时候。。通常来说，我们会对于那种写了之后立马就要保证可以查到的场景，采用强制读主库的方式，这样就可以保证你肯定的可以读到数据了吧。其实用一些数据库中间件是没问题的。</p><p> 一般来说，如果主从延迟较为严重</p><ul><li><p>分库，将一个主库拆分为4个主库，每个主库的写并发就500/s，此时主从延迟可以忽略不计</p></li><li><p>打开mysql支持的并行复制，多个库并行复制，如果说某个库的写入并发就是特别高，单库写并发达到了2000/s，并行复制还是没意义。28法则，很多时候比如说，就是少数的几个订单表，写入了2000/s，其他几十个表10/s。</p></li><li><p>重写代码，写代码的同学，要慎重，当时我们其实短期是让那个同学重写了一下代码，插入数据之后，直接就更新，不要查询</p></li><li><p>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询设置直连主库。不推荐这种方法，你这么搞导致读写分离的意义就丧失了</p><p><img data-src="03_MySQL%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E5%AF%BC%E8%87%B4%E7%9A%84%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="img_MySQL主从延迟导致的生产环境的问题"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java两种动态代理JDK动态代理和CGLIB动态代理</title>
      <link href="/2020/03/09/Java%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2020/03/09/Java%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Java两种动态代理JDK动态代理和CGLIB动态代理"><a href="#Java两种动态代理JDK动态代理和CGLIB动态代理" class="headerlink" title="Java两种动态代理JDK动态代理和CGLIB动态代理"></a>Java两种动态代理JDK动态代理和CGLIB动态代理</h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是23种设计模式的一种，他是指一个对象A通过持有另一个对象B，可以具有B同样的行为的模式。</p><a id="more"></a><p>为了对外开放协议，B往往实现了一个接口，A也会去实现接口。但是B是“真正”实现类，A则比较“虚”，他借用了B的方法去实现接口的方法。A虽然是“伪军”，但它可以增强B，在调用B的方法前后都做些其他的事情。Spring AOP就是使用了动态代理完成了代码的动态“织入”。</p><p>使用代理好处还不止这些，一个工程如果依赖另一个工程给的接口，但是另一个工程的接口不稳定，经常变更协议，就可以使用一个代理，接口变更时，只需要修改代理，不需要一一修改业务代码。从这个意义上说，所有调外界的接口，我们都可以这么做，不让外界的代码对我们的代码有侵入，这叫防御式编程。代理其他的应用可能还有很多。</p><p>上述例子中，类A写死持有B，就是B的静态代理。如果A代理的对象是不确定的，就是动态代理。动态代理目前有两种常见的实现，jdk动态代理和cglib动态代理。</p><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>jdk动态代理是jre提供给我们的类库，可以直接使用，不依赖第三方。先看下jdk动态代理的使用代码，再理解原理。首先有个“明星”接口类，有唱、跳两个功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Star</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sing</span><span class="params">(String name)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">dance</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后有明星实现类，“刘德华”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiuDeHua</span> <span class="keyword">implements</span> <span class="title">Star</span></span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sing</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"给我一杯忘情水"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"唱完"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dance</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开心的马骝"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"跳完"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明星演出前需要有人收钱，由于要准备演出，自己不做这个工作，一般交给一个经纪人。便于理解，它的名字以Proxy结尾，但他不是代理类，原因是它没有实现我们的明星接口，无法对外服务，它仅仅是一个wrapper。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package proxy;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"> </span><br><span class="line">public class StarProxy implements InvocationHandler</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 目标类，也就是被代理对象</span><br><span class="line">    private Object target;</span><br><span class="line">    </span><br><span class="line">    public void setTarget(Object target)</span><br><span class="line">    &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里可以做增强</span><br><span class="line">        System.out.println(&quot;收钱&quot;);</span><br><span class="line">        </span><br><span class="line">        Object result &#x3D; method.invoke(target, args);</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 生成代理类</span><br><span class="line">    public Object CreatProxyedObj()</span><br><span class="line">    &#123;</span><br><span class="line">        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);</span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中，方法CreatProxyedObj返回的对象才是我们的代理类，它需要三个参数，前两个参数的意思是在同一个classloader下通过接口创建出一个对象，该对象需要一个属性，也就是第三个参数，它是一InvocationHandler。需要注意的是这个CreatProxyedObj方法不一定非得在我们的StarProxy类中，往往放在一个工厂类中。上述代理的代码使用过程一般如下：</p><ul><li><p>new一个目标对象</p></li><li><p>new一个InvocationHandler，将目标对象set进去</p></li><li><p>通过CreatProxyedObj创建代理对象，强转为目标对象的接口类型即可使用，实际上生成的代理对象实现了目标接口。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Star ldh &#x3D; new LiuDeHua();</span><br><span class="line"></span><br><span class="line">StarProxy proxy &#x3D; new StarProxy();</span><br><span class="line"></span><br><span class="line">proxy.setTarget(ldh); </span><br><span class="line"></span><br><span class="line">Object obj &#x3D; proxy.CreatProxyedObj();</span><br><span class="line"></span><br><span class="line">Star star &#x3D; (Star)obj;</span><br></pre></td></tr></table></figure><p>Proxy（jdk类库提供）根据B的接口生成一个实现类，我们称为C，它就是动态代理类（该类型是 $Proxy+数字 的“新的类型”）。生成过程是：由于拿到了接口，便可以获知接口的所有信息（主要是方法的定义），也就能声明一个新的类型去实现该接口的所有方法，这些方法显然都是“虚”的，它调用另一个对象的方法。当然这个被调用的对象不能是对象B，如果是对象B，我们就没法增强了，等于饶了一圈又回来了。</p><p>所以它调用的是B的包装类，这个包装类需要我们来实现，但是jdk给出了约束，它必须实现InvocationHandler，上述例子中就是StarProxy， 这个接口里面有个方法，它是所有Target的所有方法的调用入口（invoke），调用之前我们可以加自己的代码增强。</p><p>看下我们的实现，我们在InvocationHandler里调用了对象B（target）的方法，调用之前增强了B的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里增强</span></span><br><span class="line">    System.out.println(<span class="string">"收钱"</span>);</span><br><span class="line"></span><br><span class="line">    Object result = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以这么认为C代理了InvocationHandler，InvocationHandler代理了我们的类B，两级代理。</p><p>整个JDK动态代理的秘密也就这些，简单一句话，动态代理就是要生成一个包装类对象，由于代理的对象是动态的，所以叫动态代理。由于我们需要增强，这个增强是需要留给开发人员开发代码的，因此代理类不能直接包含被代理对象，而是一个InvocationHandler，该InvocationHandler包含被代理对象，并负责分发请求给被代理对象，分发前后均可以做增强。从原理可以看出，JDK动态代理是“对象”的代理。</p><p>下面看下动态代理类到底如何调用的InvocationHandler的，为什么InvocationHandler的一个invoke方法能为分发target的所有方法。C中的部分代码示例如下，通过反编译生成后的代码查看，摘自链接地址。Proxy创造的C是自己（Proxy）的子类，且实现了B的接口，一般都是这么修饰的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">XXX</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">XXX</span></span></span><br></pre></td></tr></table></figure><p>一个方法代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">SayHello</span><span class="params">(String paramString)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> (String)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m4, <span class="keyword">new</span> Object[] &#123; paramString &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，C中的方法全部通过调用h实现，其中h就是InvocationHandler，是我们在生成C时传递的第三个参数。这里还有个关键就是SayHello方法（业务方法）跟调用invoke方法时传递的参数m4一定要是一一对应的，但是这些对我们来说都是透明的，由Proxy在newProxyInstance时保证的。留心看到C在invoke时把自己this传递了过去，InvocationHandler的invoke的第一个方法也就是我们的动态代理实例类，业务上有需要就可以使用它。（所以千万不要在invoke方法里把请求分发给第一个参数，否则很明显就死循环了）C类中有B中所有方法的成员变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static Method m1;</span><br><span class="line">private static Method m3;</span><br><span class="line">private static Method m4;</span><br><span class="line">private static Method m2;</span><br><span class="line">private static Method m0;</span><br></pre></td></tr></table></figure><p>这些变量在static静态代码块初始化，这些变量是在调用invocationhander时必要的入参，也让我们依稀看到Proxy在生成C时留下的痕迹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      m1 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</span><br><span class="line">      m3 &#x3D; Class.forName(&quot;jiankunking.Subject&quot;).getMethod(&quot;SayGoodBye&quot;, new Class[0]);</span><br><span class="line">      m4 &#x3D; Class.forName(&quot;jiankunking.Subject&quot;).getMethod(&quot;SayHello&quot;, new Class[] &#123; Class.forName(&quot;java.lang.String&quot;) &#125;);</span><br><span class="line">      m2 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">      m0 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从以上分析来看，要想彻底理解一个东西，再多的理论不如看源码，底层的原理非常重要。</p><p>jdk动态代理类图如下</p><p><img data-src="image-20200429101023902.png" alt="image"></p><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>我们了解到，“代理”的目的是构造一个和被代理的对象有同样行为的对象，一个对象的行为是在类中定义的，对象只是类的实例。所以构造代理，不一定非得通过持有、包装对象这一种方式。</p><p>通过“继承”可以继承父类所有的公开方法，然后可以重写这些方法，在重写时对这些方法增强，这就是cglib的思想。根据里氏代换原则（LSP），父类需要出现的地方，子类可以出现，所以cglib实现的代理也是可以被正常使用的。</p><p>先看下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 根据一个类型产生代理类，此方法不要求一定放在MethodInterceptor中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">CreatProxyedObj</span><span class="params">(Class&lt;?&gt; clazz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        </span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        </span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method arg1, Object[] arg2, MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这里增强</span></span><br><span class="line">        System.out.println(<span class="string">"收钱"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arg3.invokeSuper(arg0, arg2);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，它和jdk动态代理有所不同，对外表现上看CreatProxyedObj，它只需要一个类型clazz就可以产生一个代理对象， 所以说是“类的代理”，且创造的对象通过打印类型发现也是一个新的类型。不同于jdk动态代理，jdk动态代理要求对象必须实现接口（三个参数的第二个参数），cglib对此没有要求。</p><p>cglib的原理是这样，它生成一个继承B的类型C（代理类），这个代理类持有一个MethodInterceptor，我们setCallback时传入的。 C重写所有B中的方法（方法名一致），然后在C中，构建名叫“CGLIB”+“$父类方法名$”的方法（下面叫cglib方法，所有非private的方法都会被构建），方法体里只有一句话super.方法名()，可以简单的认为保持了对父类方法的一个引用，方便调用。</p><p>这样的话，C中就有了重写方法、cglib方法、父类方法（不可见），还有一个统一的拦截方法（增强方法intercept）。其中重写方法和cglib方法肯定是有映射关系的。</p><p>C的重写方法是外界调用的入口（LSP原则），它调用MethodInterceptor的intercept方法，调用时会传递四个参数，第一个参数传递的是this，代表代理类本身，第二个参数标示拦截的方法，第三个参数是入参，第四个参数是cglib方法，intercept方法完成增强后，我们调用cglib方法间接调用父类方法完成整个方法链的调用。</p><p>这里有个疑问就是intercept的四个参数，为什么我们使用的是arg3而不是arg1?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object intercept(Object arg0, Method arg1, Object[] arg2, MethodProxy arg3) throws Throwable</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(&quot;收钱&quot;);</span><br><span class="line">    </span><br><span class="line">    return arg3.invokeSuper(arg0, arg2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 因为如果我们通过反射 arg1.invoke(arg0, …)这种方式是无法调用到父类的方法的，子类有方法重写，隐藏了父类的方法，父类的方法已经不可见，如果硬调arg1.invoke(arg0, …)很明显会死循环。</p><p>所以调用的是cglib开头的方法，但是，我们使用arg3也不是简单的invoke，而是用的invokeSuper方法，这是因为cglib采用了fastclass机制，不仅巧妙的避开了调不到父类方法的问题，还加速了方法的调用。</p><p>fastclass基本原理是，给每个方法编号，通过编号找到方法执行避免了通过反射调用。</p><p>对比JDK动态代理，cglib依然需要一个第三者分发请求，只不过jdk动态代理分发给了目标对象，cglib最终分发给了自己，通过给method编号完成调用。cglib是继承的极致发挥，本身还是很简单的，只是fastclass需要另行理解。</p><h2 id="JDK动态代理和CGLIB的区别"><a href="#JDK动态代理和CGLIB的区别" class="headerlink" title="JDK动态代理和CGLIB的区别"></a>JDK动态代理和CGLIB的区别</h2><p>DK动态代理只能对实现了接口的类生成代理，而不能针对类。</p><p>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法实现增强，但是因为采用的是继承，所以该类或方法最好不要声明成final， 对于final类或方法，是无法继承的</p><p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在jdk6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类</p><p>在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率，只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理，总之，每一次jdk版本升级，jdk代理效率都得到提升，而CGLIB代理消息确有点跟不上步伐Spring如何选择用</p><p>JDK还是CGLIB？</p><ul><li>当Bean实现接口时，Spring就会用JDK的动态代理。</li><li>当Bean没有实现接口时，Spring使用CGlib是实现。</li></ul><p>为什么继承只能使用CGLib，因为JDK代理生成的代理类，默认会继承一个类，由于java是单继承，所以当原始类继承一个类的时候，只能使用CGLib动态代理</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP。</li><li>如果目标对象实现了接口，可以强制使用CGLIB实现AOP。</li><li>如果目标对象没有实现了接口，必须采用CGLIB库，Spring会自动在JDK动态代理和CGLIB之间转换</li></ul><p>JDK代理是不需要第三方库支持，只需要JDK环境就可以进行代理，使用条件:</p><ul><li><p>实现InvocationHandler </p></li><li><p>使用Proxy.newProxyInstance产生代理对象</p></li><li><p>被代理的对象必须要实现接口</p></li></ul><p>CGLib必须依赖于CGLib的类库，但是它需要类来实现任何接口代理的是指定的类生成一个子类，</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 代理模式 </tag>
            
            <tag> 动态代理 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VivadoHLS之优化案例分析</title>
      <link href="/2020/01/09/VivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
      <url>/2020/01/09/VivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><h2 id="优化吞吐率的相关directive"><a href="#优化吞吐率的相关directive" class="headerlink" title="优化吞吐率的相关directive"></a>优化吞吐率的相关directive</h2><p>1、首先是pipeline，pipeline可以作用于函数，也可以作用于循环，当作用于循环的时候有个option是rewind，可以进一步的改善吞吐率</p><p>2、对于数组，可以使用Array_Partition，把数组分割成不同的部分，而这种分割的方式可以是block、cyclic、complete</p><p>3、对于loop，还可以采用UNROLL这种方式，这时候会有option、factor，他其实是控制循环的被复制成并行的几份，、去执行</p><p>4、DataFlow可以作用于函数，也可以作用于循环，实际是一种并发操作的方式，从这里可以看出，改善吞吐率其实是通过提高并行度来实现的</p><a id="more"></a><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C1.PNG" alt="1"></p><h2 id="PipeLine作用于函数或者循环的不同"><a href="#PipeLine作用于函数或者循环的不同" class="headerlink" title="PipeLine作用于函数或者循环的不同"></a>PipeLine作用于函数或者循环的不同</h2><p>当pipeline作用于函数的时候，从<code>I / O</code>角度来看是连续的，当pipeline作用于循环的时候可以看到，本次循环和下次循环之间是有一个空挡的，从<code>I / O</code>角度来看有一个Bubble（无操作时间）</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C2.PNG" alt="2"></p><h2 id="对Latency进行优化"><a href="#对Latency进行优化" class="headerlink" title="对Latency进行优化"></a>对Latency进行优化</h2><p>对于Latency有一个directive就叫做Latency，他可以作用于function也可以作用于loop，此外还有一个loop_merge，就是把顺序的Loop合并在一起，还有一个Loop_Flatten其实是把嵌套的循环打平</p><p>这里需要说明，当使用Latency这个directive的时候，如果是针对循环，它指的是一次循环的Latency，如果我们期望得到的是完成整个循环所需要的Latency，先要做一个region的设置，针对region去设置Latency</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C3.PNG" alt="3"></p><h2 id="对Area进行优化"><a href="#对Area进行优化" class="headerlink" title="对Area进行优化"></a>对Area进行优化</h2><p>1、Data types和bit widths并不是directive，但是同样可以优化资源（面积）</p><p>Inline</p><p>Allocation</p><p>针对array可以采用Array_Map和Array_rESHAPE</p><p>还有针对函数的Function_Instantiate</p><p> <img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C4.PNG" alt="4"></p><h2 id="案例分析：Cordic算法"><a href="#案例分析：Cordic算法" class="headerlink" title="案例分析：Cordic算法"></a>案例分析：Cordic算法</h2><p>Cordic算法本质上是通过一系列微旋转来计算超越函数，比如说正余弦，在这个过程中，这些微旋转变成了一些移位的操作，可以通过这些方式来计算三角函数，如果这里x0设置为1/An，y0设置位0，那么最后就可以得到正余弦的结果，这里要求z0的取值范围是-99 ~ +99，我们再进一步把它缩小为-Π/2 ~ +Π/2</p><p>对于-Π ~ Π的区间，要先做预处理，把它映射到-Π/2 ~ Π/2，得到结果之后在做后处理，得到真正的函数值</p><p>所以需要三个函数，预处理 -&gt; 中间的计算单元 -&gt; 最后的后处理</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C5.PNG" alt="5"></p><p>接下来通过Vivado HLS将其转化为相应的RTL代码，并提高吞吐率</p><p>先看一下函数代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ap_fixed.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ap_int.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WA 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FA 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WS 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FA 14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ap_fixed&lt;WA, WA-FA&gt; <span class="keyword">di_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> ap_fixed&lt;WA, WA-FA&gt; <span class="keyword">di_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> ap_fixed&lt;WA, WA-FA&gt; <span class="keyword">di_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">do_t</span> Kn = <span class="number">0.607252935</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">di_t</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cir_cordic</span><span class="params">(<span class="keyword">di_t</span> alpha, <span class="keyword">do_t</span> &amp;mysin, <span class="keyword">do_t</span> &amp;cos_out)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cir_codic.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_cir_codic</span><span class="params">(<span class="keyword">di_t</span> full_alpha, <span class="keyword">di_t</span> &amp;alpha, <span class="keyword">flag_t</span> &amp;flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(full_alpha &gt; PI/<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        alpha = PI - full_alpha;</span><br><span class="line">        flag = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(full_alpha &lt; -PI/<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        alpha = -PI - full_alpha;</span><br><span class="line">        flag = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        alpha = full_alpha;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cir_cordic_calculate</span><span class="params">(<span class="keyword">di_t</span> alpha, <span class="keyword">flag_t</span> flag, <span class="keyword">do_t</span> &amp;mysin, <span class="keyword">do_t</span> &amp;mycos, <span class="keyword">flag_t</span> flag_delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">do_t</span> xi[N];</span><br><span class="line">    <span class="keyword">do_t</span> yi[N];</span><br><span class="line">    <span class="keyword">di_t</span> zi[N];</span><br><span class="line">    <span class="keyword">flag_t</span> flag_delay_a[N];</span><br><span class="line">    </span><br><span class="line">    xi[<span class="number">0</span>] = Kn;</span><br><span class="line">    yi[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    zi[<span class="number">0</span>] = alpha;</span><br><span class="line">    flag_delay_a[<span class="number">0</span>] = flag;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">di_t</span> myarctan[<span class="number">16</span>] = &#123;</span><br><span class="line">        #included <span class="string">"myarctan.h"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    loop:</span><br><span class="line">    <span class="keyword">for</span>(m = <span class="number">0</span>; m &lt; N; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(zi[m] &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            xi[m+<span class="number">1</span>] = xi[m] - (yi[m] &gt;&gt; m);</span><br><span class="line">            yi[m+<span class="number">1</span>] = yi[m] + (xi[m] &gt;&gt; m);</span><br><span class="line">            zi[m+<span class="number">1</span>] = zi[m] - myarctan[m];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            xi[m+<span class="number">1</span>] = xi[m] + (yi[m] &gt;&gt; m);</span><br><span class="line">            yi[m+<span class="number">1</span>] = yi[m] - (xi[m] &gt;&gt; m);</span><br><span class="line">            zi[m+<span class="number">1</span>] = zi[m] + myarctan[m];</span><br><span class="line">        &#125;</span><br><span class="line">        flag_delay_a[m+<span class="number">1</span>] = flag_delay_a[m];</span><br><span class="line">    &#125;</span><br><span class="line">    mysin = yi[N<span class="number">-1</span>];</span><br><span class="line">    mycos = xi[N<span class="number">-1</span>];</span><br><span class="line">    flag_delay = flag_delay_a[N<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_cir_cordic</span><span class="params">(<span class="keyword">do_t</span> mysin, <span class="keyword">do_t</span> mycos, <span class="keyword">flag_t</span> flag_delay, <span class="keyword">do_t</span> &amp;sin_out, <span class="keyword">do_t</span> &amp;cos_out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="keyword">int</span>(flag_delay))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> : sin_out = mysin; cos_out = -mycos; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span> : sin_out = mysin; cos_out = -mycos; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span> : sin_out = mysin; cos_out = mycos; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cir_cordic</span><span class="params">(<span class="keyword">di_t</span> full_alpha, <span class="keyword">do_t</span> &amp;sin_out, <span class="keyword">do_t</span> &amp;cos_out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">di_t</span> alpha;</span><br><span class="line">    <span class="keyword">flag_t</span> flag;</span><br><span class="line">    <span class="keyword">do_t</span> mysin;</span><br><span class="line">    <span class="keyword">do_t</span> mycos;</span><br><span class="line">    flag_ flag_delay;</span><br><span class="line">    </span><br><span class="line">    pre_cir_codic(full_alpha, alpha, flag);</span><br><span class="line">    cir_codic_calculate(alpha, flag, mysin, mycos, flag_delay);</span><br><span class="line">    post_cir_codic(mysin, mycos, flag_delay, sin_out, cos_out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cir_codic.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ReafFileVec.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">629</span>;</span><br><span class="line">    <span class="keyword">char</span> *fd_alpha = <span class="string">"myalpha.dat"</span>;</span><br><span class="line">    <span class="keyword">char</span> *fd_sin = <span class="string">"mysin.dat"</span>;</span><br><span class="line">    <span class="keyword">char</span> *fd_cos = <span class="string">"mycos_dat"</span>;</span><br><span class="line">    <span class="keyword">di_t</span> alpha[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">do_t</span> sin_Ref[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">do_t</span> cos_Ref[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">do_t</span> sin_Res[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">do_t</span> cos_Res[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ErrCntSin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ErrCntCos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> precision = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">-10</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    ReadFileVec &lt;N, <span class="keyword">di_t</span>, <span class="keyword">float</span>&gt; (fd_alpha, alpha);</span><br><span class="line">    ReadFileVec &lt;N, <span class="keyword">do_t</span>, <span class="keyword">float</span>&gt; (fd_sin, sinRef);</span><br><span class="line">    ReadFileVec &lt;N, <span class="keyword">do_t</span>, <span class="keyword">float</span>&gt; (fd_cos, cosRef);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cir_codic(alpha[i], sinres[i], cosres[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'-'</span>) &lt;&lt; setw(<span class="number">90</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; <span class="string">"Alpha"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; <span class="string">"sin"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; <span class="string">"sinRef"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; <span class="string">"cos"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; <span class="string">"cosRef"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'-'</span>) &lt;&lt; setw(<span class="number">90</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; alpha[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; sinres[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; sinRef[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; cosres[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; cosRef[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="keyword">float</span>(sinres[i]-sinRef[i])) &gt; precision)</span><br><span class="line">        &#123;</span><br><span class="line">            ErrCntSin++;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; <span class="string">"(sin failed)"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="keyword">float</span>(cosres[i]-cosRef[i])) &gt; precision)</span><br><span class="line">        &#123;</span><br><span class="line">            ErrCntCos++;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">18</span>) &lt;&lt; right &lt;&lt; <span class="string">"(cos failed)"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'-'</span>) &lt;&lt; setw(<span class="number">90</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ErrCntSin + ErrCntCos &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ErrCntSin &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ErrCntCos &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; <span class="string">"There are "</span> &lt;&lt; ErrCntCos &lt;&lt; <span class="string">" cos results failed"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test failed for precision: "</span> &lt;&lt; presicion &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'-'</span>) &lt;&lt; setw(<span class="number">90</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test Passed for precision: "</span> &lt;&lt; precision &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'-'</span>) &lt;&lt; setw(<span class="number">90</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建Vivado HLS的工程，然后进行系统仿真，出现下面的信息说明仿真结果通过了</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C6.PNG" alt="6"></p><p>然后再做C的综合，出现下面的结果说明C综合通过</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C7.PNG" alt="7"></p><p>综合结束后会有相应的综合报告，可以看到Latency等信息，可以看到Latency和Interval都是比较大的</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C8.PNG" alt="8"></p><p>然后我们就可以做C和RTL的Co-Simulation，做完Co-Simulation之后就可以打开波形查看器，去看最终的结果</p><p>设置sin_out和cos_out，</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C9.PNG" alt="9"></p><p>设置输出是一个定点数，有符号数，小数部分是14位</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C10.PNG" alt="10"></p><p>同时把它设置为模拟波形的方式来显示</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C11.PNG" alt="11"></p><p>现在就可以看到整个曲线的样子</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C12.PNG" alt="12"></p><p>针对Latency进行优化</p><p>创建一个solution命名为s_pipeline，针对for循环去做pipeline</p><p>对for循环添加directive，UNROLL和PIPELINE，然后再进行综合，综合后的结果可以看到，Latency变成了6，Interval变成了7，有了显著的变化，但是我们期望Interval是1，所以我们进一步优化</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C13.PNG" alt="13"></p><p>创建solution，s_pipeline_fun，作用于主函数本身进行pipeline，然后进行综合，这时候综合报告显示，Latency变成了5，Interval变成了1</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C14.PNG" alt="14"></p><p>然后将三次综合结合结果进行对比，可以看到Latency和Interval的变化</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C15.PNG" alt="15"></p><p>在资源方面的变化也可以做一个对比</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%5C16.PNG" alt="16"></p>]]></content>
      
      
      <categories>
          
          <category> Vivado HLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vivado HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vivado HLS之函数层面的优化</title>
      <link href="/2020/01/08/VivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96/"/>
      <url>/2020/01/08/VivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="函数的代码风格"><a href="#函数的代码风格" class="headerlink" title="函数的代码风格"></a>函数的代码风格</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>从函数的角度来看代码风格主要是说函数的参数，针对参数我们要看的是数据类型，C++里定义的数据类型是以8为边界的，比如说char或者int等等，但实际在硬件我们可能会遇到任意精度的数据类型，所以如果算法中牵涉到的数据类型是任意精度，我们一定要将其定义为任意精度</p><p>看例子</p><a id="more"></a><p>这是一个很简单的例子，目的是实现<code>x * y</code>，而且在这里x和y都是12比特的整型，如果我们用传统的C++来定义就会将其定义为int类型，但是如果我们用Vivado HLS支持的任意精度的数据类型，我们就可以将其定义为ap_int&lt;12&gt;，这两种方法我们进行对比可以看到，如果用任意精度的数据类型，只用了1个DSP48，但是如果定义为int类型就要用到3个DSP48（一个int是4字节，32位）</p><p>所以这就体现了数据类型对于使用资源的影响</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C1.PNG" alt="1"></p><h2 id="Inline"><a href="#Inline" class="headerlink" title="Inline"></a>Inline</h2><p>对函数的Inline其实是去除了函数的层次化</p><p>这个可以通过INLINE directive去实现</p><p>对函数进行inline带来的好处是可以改善资源，这是因为Inline就不再需要调用函数的相关逻辑</p><p>对一些小的函数，Vivado HLS会自动进行inline的处理，可以改善相应的QOR（quality of results），如果我们不希望函数inline，可以通过设置函数中的<code>-off</code>选项去实现</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C2.PNG" alt="2"></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在这个例子中有一个顶层函数dct，其中调用了<code>read_data()</code>和<code>write_data()</code>函数，以及<code>dct_2d()</code>这三个函数，在默认情形下可以看到Vivado HLS自动对<code>read_data()</code>和<code>write_data()</code>执行了inline，所以在综合报告中我们只看到了一个instance，也就是dct_2d()这个函数，如果我们阻止inline，在directive窗口中选择相应的函数，并切换到Inline，同时将off选中，就变成了如下所示，这时候再进行综合，在相应的综合报告中就可以看到有3个相应的instance，相应的Latency和资源的对比也可以看到，显然，把inline关掉的话，Latency会增大，相应的资源也会变多</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C3.PNG" alt="3"></p><h2 id="Allocation"><a href="#Allocation" class="headerlink" title="Allocation"></a>Allocation</h2><p>再看一下Allocation，Allocation其实是定义了函数和相应的RTL model之间的关系</p><p>看下例</p><p>在这个函数中，在<code>loop_sequential()</code>函数下面调用了两次<code>Accumulator()</code>函数，如果我们通过Allocation设置其中的limit=2，目的是告诉HLS，<code>Accumulator()</code>函数对应的RTL实体会被实例化了两次，这个就是这里limit=2的含义，再看一下结果就可以看到有两个实体</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C4.PNG" alt="4"></p><h3 id="Allocation的影响"><a href="#Allocation的影响" class="headerlink" title="Allocation的影响"></a>Allocation的影响</h3><p>默认是default的情形，这时候for循环的Latency是8，tripcount是4，</p><p>再看Allocation：Limit=1，和Allocation：Limit=2的情形，对比一下可以看到，当Allocation=2时，Latency是最小的，但是资源用的也是最多的，FF用到了48，所以对比一下可以得出结论，Allocation是得出了Latency和Area之间的折中。</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C5.PNG" alt="5"></p><h2 id="DataFlow"><a href="#DataFlow" class="headerlink" title="DataFlow"></a>DataFlow</h2><p>DataFlow在之前讲到for循环优化的时候就提到过，这里可以把它运用于函数，比如函数1执行完的结果给函数2，… …，这样顺序执行，知道最后函数N，然后输出，我们把这个称为顺序处理的模式，通过Dataflow可以把这种顺序处理的模式变成并行处理，并行处理的时候就可以用到channel，这个channel就可以是ping-pong RAM，也可以是FIFO</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C6.PNG" alt="6"></p><p>关于dataflow可以作为顺序执行的一些任务，可以作用于顺序执行的一些任务，这些任务可以是函数，循环，或者两者都有，DataFlow是把顺序的处理机制变成了并行的处理机制，在前边图中的channel就表明了，当前任务并不需要等到后一个任务处理完毕再执行，他们是可以并行执行的，所以DataFlow允许任务之间有交叠，所谓的这种交叠其实就是并行处理，这种机制提高了数据吞吐率，从而降低了Latency</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C7.PNG" alt="7"></p><h3 id="对DataFlow的理解"><a href="#对DataFlow的理解" class="headerlink" title="对DataFlow的理解"></a>对DataFlow的理解</h3><p>看下面这个图，在这个图中显示了三个函数，Func1、Func2、Func3，其中，Func1需要3个时钟周期，Func2需要2个时钟周期，Func3需要3个时钟周期，也就是总共的Latency是8，如果我们用DataFlow，Latency就降低到了5</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C8.PNG" alt="8"></p><p>再看一个例子，dct()函数中调用了三个函数，分别是read_data()、dct_2d()、write_data()，他们是满足顺序处理机制的，从而可以通过DataFlow实现并行的处理，在相应的分析窗口中我们就可以看到Module Hierarchy窗口中有一个标记，那么就说明了使用了DataFlow，我们可以看到相应的Schedule Viewer视图和DataFlow视图</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C9.PNG" alt="9"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，我们可以看到使用任意精度的数据类型能够帮助我们降低资源的使用</p><p>函数的Inline使用可以提高QoR（quality of results）</p><p>Allocation的使用可以帮助我们折中Latency和资源（Area）</p><p>DataFlow对于提高吞吐量是一种强有力的优化方式</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E5%87%BD%E6%95%B0%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96%5C10.PNG" alt="10"></p>]]></content>
      
      
      <categories>
          
          <category> Vivado HLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vivado HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VivadoHLS之数组优化</title>
      <link href="/2020/01/07/VivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96/"/>
      <url>/2020/01/07/VivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="数组优化-数组分割"><a href="#数组优化-数组分割" class="headerlink" title="数组优化 - 数组分割"></a>数组优化 - 数组分割</h1><p>对于数组，我们可以通过resource这个directive明确的告知vivado HLS当前的这个数组是采用什么样的Memory来实现，比如是通过分布式的还是通过block RAM，是采用单端口还是采用双端口，如果没有使用resource，Vivado HLS会自行决定采用单端口还是双端口，取决于哪种方式可以有效的降低Initiation interval以及Latency。</p><a id="more"></a><p>数组最终会以memory（RAM、ROM、FIFO）的形式出现，如果数组是作为顶层函数的形参，那么他最终就会以相应的memory的接口来呈现，包括相应的读写地址，以及数据，当然还有读写使能，如果数组是在读写的内部，那么最终就会映射为block RAM，LUTRAM，Ultra RAM，或者是寄存器取决于在设计中采用的优化策略和优化方法</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C1.PNG" alt="1"></p><h2 id="看例子"><a href="#看例子" class="headerlink" title="看例子"></a>看例子</h2><p>在例子中，如果我们要同时获取mem[]数组相邻的三个元素，把他们相加，输出的值给到另外一个元素，在默认的情况下我们会看到Resource/Control的过程，可以看到这时候mem被映射为双端口：p0、p1，但是结果sum就是单端口，每次只能写入一个数据，但是我们可以很明确的将mem指定为双端口，这时候要把循环展开，这个指令就是通过resource的directive实现的，这时候我们看到整个的读写过程，很明显因为sum变成了双端口，所以可以同时写入两个数据，更要说明的是因为这里的循环时展开的，所以也就使得相应的加法操作变成了并行，由此我们可以看到Latency从默认情形下的13变成了3，Interval由14变成了4，优化结果很明显。</p><p>由此可以看到，数组往往是设计过程中的瓶颈</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C2.PNG" alt="2"></p><h2 id="三种方法（Three-Forms-of-Partition）"><a href="#三种方法（Three-Forms-of-Partition）" class="headerlink" title="三种方法（Three Forms of Partition）"></a>三种方法（Three Forms of Partition）</h2><p>Vivado HLS提供了三种对数组进行分割的方法，分别是block、cyclic、register，仍然以上面的例子为例，mem数组长度为6的一个数组</p><h3 id="1、block"><a href="#1、block" class="headerlink" title="1、block"></a>1、block</h3><p>如果我们采用Block的方式、Factor为3，就意味着数组分成三份，是一种等分成三份的方式，所以0号、1号作为一组，2号、3号作为一组，4号、5号作为一组，在相应的directive窗口中可以看到，<code>block factor=3 dim=1</code>，dim也就是dimension，因为这里的数组是个一维数组</p><h3 id="2、cyclic"><a href="#2、cyclic" class="headerlink" title="2、cyclic"></a>2、cyclic</h3><p>我们还可以采用第二种partition的方式，就是Cyclic，Factor=3，这时候我们要注意分割方式有所不同，依然要分成3份，但是0、1、2属于不同的memory，3、4、5属于不同的memory，从而0、3构成第一个memory，1、4构成第二个memory，2、5构成第三个memory，同样这时在directive窗口中就会看到<code>cyclic factor=3 dim=1</code>，</p><h3 id="3、register"><a href="#3、register" class="headerlink" title="3、register"></a>3、register</h3><p>如果采用Register的方式，这时候0 - 5这六个元素就变成了0 - 5对应的六个register，就是一种完全并行的方式，在directive窗口中就可以看到<code>complete dim=1</code>，</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C3.PNG" alt="3"></p><p>我们看一下这三种分割方式对于前边的例子会有怎样的影响，很显然，对于上面的例子来说，采用block、cyclic他们的并行增强了，基本上效果是一致的，采用complete是一种完全并行的方式，因为他全部采用了register，</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C4.PNG" alt="4"></p><p>但是并非是越多的block效果越好，事实上block的个数取决于真实的数据流，从前面的例子中可以看到，我们在获得一次和的过程中，需要有三个输入，三个输入可以分解成两个block，一个block是一个双端口，因为每个block、每个memory作为双端口可以提供两个数据，如果是两个block也就是两个memory，至少可以提供4个数据，完全满足这种数据流，所以我们并没有必要去把它分解成三个block，因此我们这里做一个对比，当block=2，和block=3的时候，其实情形是一样的，最终的性能Latency和Interval是一样的，同样的，如果我们选择Cyclic的方式，cyclic=2和cyclic=3也是一样的，从资源角度看，尽管有一些变化，但是可以忽略不计</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C5.PNG" alt="5"></p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>对于多维数组，dimension该如何设置，例如有如下一个三维数组，Vivado HLS的认定规则是：10是第一维，6是第二维，4是第三维。</p><p>当我们选择dim=3进行partition的时候，这时候就变成了如下中间这种形式，当选择dim=1的时候，就变成了如下右边这种形式，需要说明的是，当dim=1时，是把<code>My_array_0[6][4]</code>作为一个整体来看的</p><h3 id="看一个例子"><a href="#看一个例子" class="headerlink" title="看一个例子"></a>看一个例子</h3><p>在下面这个例子中，这是数组的加法，对数组元素进行相加，所以要求a和b是一个相同维度的数组，这里的a是一个4x5也就是4行5列的数组，对这个数组a做约束，首先通过resource把它设置为单端口，第二把它做分割，对他的第一维分割，并且分解成四块，第一维就是4x5的4对应的维度，同理，数组b和数组sum也是同样的方式，同时还要注意相应的循环要展开，所以如果<code>block factor=4, dim=1</code>，九八数组a分解成了如下四个block，可以看到每一行对应一个block，如果把<code>block factor=2, dim=1</code>，就会分解成如下两个block，这时候第0行、第1行作为block 0，第2行、第3行作为block 1，这个方式跟一维数组的方式是类似的，只是在做block分割的时候是把其中的每一行作为一个整体来看待的</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C6.PNG" alt="6"></p><p>从仿真结果也可以进一步来验证这种<code>block factor=4, dim=1</code>，和block factor=2, dim=1的时候所获得的元素是什么样子的，所以跟我们前边分割的方式是完全一致的，</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C7.PNG" alt="7"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、Vivado HLS提供了三种数组分割的方式：block，cyclic、complete</p><p>2、数组分割可以提高吞吐率</p><h1 id="数组优化-数组映射和重组"><a href="#数组优化-数组映射和重组" class="headerlink" title="数组优化  - 数组映射和重组"></a>数组优化  - 数组映射和重组</h1><p>Optimization Methods of Array: Map and Reshape</p><h2 id="映射（Map）"><a href="#映射（Map）" class="headerlink" title="映射（Map）"></a>映射（Map）</h2><p>在C代码中如果有多个比较小的数组，可以通过Map合并成一个大的数组，从而减少block RAM的消耗，从而降低对资源的用量</p><p>当设备支持时，每一个数组都能够映射到block RAM或者UltraRAM中</p><p>Vivado HLS对于ARRAY_MAP提供了两种方式，一种是横向（水平），一种是纵向（竖直）</p><ul><li>横向映射（Horizontal mapping）</li></ul><p>得到一个包含更多元素的单个数组（Get a single array with more elements）</p><ul><li>纵向映射（Vertical mapping）</li></ul><p>获得一个具有更大位宽的单个数组（Get a single array with larger bit-width）</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C8.PNG" alt="8"></p><h3 id="横向（水平）映射"><a href="#横向（水平）映射" class="headerlink" title="横向（水平）映射"></a>横向（水平）映射</h3><p>假如有两个一维数组<code>A[N]</code>和<code>B[M]</code>，长度分别为N和M</p><p>如果我们选择水平方向的map，最终合并之后的数组长度变成了N+M，两个数组时前后拼接在一起变成了一个更大的数组，最终的数组形式如紫色图所示，这里可以看到数组从0变化到M+N-1，同时需要注意，数组的宽度，也就是存储元素的位宽可以是不一样的</p><p>在Vivado HLS中通过相应的ARRAY_MAP就可以选择，mode参数选择横向还是纵向，合并后的数组可以起一个名字，在instancwe上取，对于这个数组<code>A[N]</code>和<code>B[M]</code>，合并之后的数组的维度就变成了N+M</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C9.PNG" alt="9"></p><p>对于横向映射的数组允许有Offset，也就是地址偏移，可以看到下面这个例子他们不是无缝对接，而是中间有一些空挡，从仿真结果也可以进行验证，当offset=0时，也就是无缝对接的时候，他们是0、1、2、3，但是当offset=2时，可以看到地址的变化，2、3、4、5，因为offset=2，起始地址变成了2</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C10.PNG" alt="10"></p><p>这里还要强调一下，这种方式虽然减少了相应的资源的使用，但是对吞吐率并没有改善，因为memory个数减少了意味着读出的端口的个数也减少了</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C11.PNG" alt="11"></p><h3 id="纵向（竖直）映射"><a href="#纵向（竖直）映射" class="headerlink" title="纵向（竖直）映射"></a>纵向（竖直）映射</h3><p>还是以两个一维数组<code>A[N]</code>和<code>B[M]</code>，长度分别为N和M为例</p><p>对于纵向的合并，是把相应的元素对应的位置做位拼接，所以最终的数组长度仍然是原始数组中最长的那个数组的长度，但是宽度宽度发生了变化，是因为做了位拼接，所以最终的数组就变成了如下图3，假设N&gt;M，这里数组的长度就变成了N，但他的宽度就变成了A和B宽度之和</p><p>纵向映射的方式也是在directive中设置数组的模式（mode）也可以去指定合并后数组的名字（instance）</p><p>这里主要就是强调对于纵向映射的数组，合并后的长度就是N和M的最大值</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C12.PNG" alt="12"></p><h3 id="数组分割配合横向映射"><a href="#数组分割配合横向映射" class="headerlink" title="数组分割配合横向映射"></a>数组分割配合横向映射</h3><p>之间提到的数组分割中的array_partition，是把数组分割成多个模块</p><p>其实array_partition是可以跟横向映射一块使用的，例如，先通过partition把数组分解成两个模块，然后再通过横向的array_map把相应的分割的部分再进行合并，这样做的好处是在减少使用资源的同时也可以获得较好的吞吐率，</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C13.PNG" alt="13"></p><h2 id="重组（Reshape）-ARRAY-RESHSPE"><a href="#重组（Reshape）-ARRAY-RESHSPE" class="headerlink" title="重组（Reshape）-  ARRAY_RESHSPE"></a>重组（Reshape）-  ARRAY_RESHSPE</h2><p>重组是将ARRAY_PARTITION和纵向的ARRAY_MAP结合在一起的，这样可以降低资源的用量，同时对于数据的并行读取也会有好处，因为ARRAY_PARTITION的目的就是并行的获取数据，提高数据的并行性</p><p>相应的，因为ARRAY_PARTITION有3种模式，所以ARRAY_RESHAPE也会有类似的3种方式</p><p>这里我们以一维数组为例</p><h3 id="1、block-1"><a href="#1、block-1" class="headerlink" title="1、block"></a>1、block</h3><p>可以看到，这种情况下是将数组一分为二，然后纵向拼接相应的位置上的元素，拼接在一起，所以最终的长度是原先的1/2，宽度变成了原先的2倍</p><h3 id="2、cyclic-1"><a href="#2、cyclic-1" class="headerlink" title="2、cyclic"></a>2、cyclic</h3><p>再看cyclic，这时候是把数组交织的分成两部分，最终reshape之后的数组，长度是原来的1/2，宽度变成原来宽度的2倍</p><h3 id="3、complete"><a href="#3、complete" class="headerlink" title="3、complete"></a>3、complete</h3><p>他是同时获得了n个register，同时将n个register合并，合成一个宽度是原来n倍的寄存器，不同于Array_Partition和横向的映射组合，Array_Reshape是针对同一个数组的</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C14.PNG" alt="14"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在这个例子中，代码的</p><p>第一部分是一个for循环，在这个for循环中，将数组pa赋值给了数组A，然后对数组A执行相应的操作，操作内容是对偶数元素加5，对奇数元素减5，</p><p>第二部分是把数组pb赋值给了数组B，然后对B进行操作是把B的前一半元素加5，后一半元素减5</p><p>第三部分是对处理后的值，A和B分别乘以2，再回写到原来的pa和pb中</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C15.PNG" alt="15"></p><p>对这个例子分别进行array_map的横向映射，array_map的纵向映射，以及reshape，采用的是cyclic和block两种方式</p><p>从结果可以看到，对于Latency，只有reshape也就是s_r1这个solution会有改善，从资源来看，array_map的横向映射和array_map的纵向映射都是把block RAM的个数减小到1，所以对比下来看，array_map对于资源的用量是可以减小的，但是对于数据吞吐率是没有改善的，而Array_Reshape可以通过本身包含的partition来提高吞吐率，在一定程度上获得了资源（面积Area）和吞吐率的折中。</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C16.PNG" alt="16"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Vivado HLS提供了两种map的方式，包括横向和纵向，他们都能帮助我们减少资源的用量，主要是memory资源</p><p>但是Array_map对于数据吞吐率并没有改善</p><p>Array_Reshape是将纵向的Array_Map和Array_Partition结合在一起，所以他可以获得资源和数据吞吐率的一个比较好的折中</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C18.PNG" alt="18"></p><h1 id="数据优化-其他方法"><a href="#数据优化-其他方法" class="headerlink" title="数据优化 - 其他方法"></a>数据优化 - 其他方法</h1><h2 id="如何定义一个ROM？"><a href="#如何定义一个ROM？" class="headerlink" title="如何定义一个ROM？"></a>如何定义一个ROM？</h2><h3 id="1、const-initial-value"><a href="#1、const-initial-value" class="headerlink" title="1、const + initial value"></a>1、const + initial value</h3><p>最简单的方式就是用关键字const + initial value，这种方式简单易行，不足之处就是如果我们定义的ROM比较大，也就是初始值很多的情况下，在代码里写这些初始值是一个很繁琐的过程，容易出错。</p><p>同时从代码的管理角度而言也是很不方便的。</p><p> 相应的我们可以在综合后的报告里看到资源的占用量</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C17.PNG" alt="17"></p><h3 id="2、头文件的方式"><a href="#2、头文件的方式" class="headerlink" title="2、头文件的方式"></a>2、头文件的方式</h3><p>采用头文件的方式，将相应的初始值放到头文件中，这样既简单同时对代码的维护和工程的管理都很方便，注意在代码中蓝色方框标记的部分有一个<code>.h</code>的头文件，在写法上<code>#include &quot;des_1_coef.h&quot;</code>要单独占一行。</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C19.PNG" alt="19"></p><p>对于<code>.h</code>文件中的内容，一个例子，这里需要用逗号，而在最后一行是数值再加上一个空格，是没有标点符号的，相应的在综合之后就可以看到资源用量，这里给的例子是整个的ROM的长度，很小，所以是用查找表来实现的，可以看到有相应的LUT、Words、Bits</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C20.PNG" alt="20"></p><h3 id="3、Vivado-HLS推导出相应的ROM"><a href="#3、Vivado-HLS推导出相应的ROM" class="headerlink" title="3、Vivado HLS推导出相应的ROM"></a>3、Vivado HLS推导出相应的ROM</h3><p>如果ROM里头的存储值是通过数学公式计算得到的，那么Vivado HLS也可以帮助去推导出相应的ROM</p><p>在这个例子中有一个函数<code>init_sin_table()</code>，这里边其实是通过sin值函数去计算相应的数值，然后在下边的函数中会调用<code>init_sin_table()</code>，这时候在综合后的报告里就能看到Vivado HLS会帮助我们推导出一个相应的ROM</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C21.PNG" alt="21"></p><p>对于ROM可以改变它的输出的Latency，在默认情形下用的输出Latency是2，可以通过增加Latency改善这条路径上的时序，在相应的directive窗口可以看到Latency(optional)，默认是2，现在改为3，</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C22.PNG" alt="22"></p><p>要想知道是否生效，可以查看生成的RTL代码进行验证，当Latency=2时可以看到地址有一级Latency，输出有一级Latency，当Latency=3时，地址有一级Latency，输出有一级Latency，最终的输出还有一级Latency，总共是3级。</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C23.PNG" alt="23"></p><h3 id="4、数组的初始化"><a href="#4、数组的初始化" class="headerlink" title="4、数组的初始化"></a>4、数组的初始化</h3><p>对于数组，如果是映射为memory，需要在前面加关键字static，这个关键字不仅能保证Vivado HLS把数组作为memory实现，还可以保证最终实现的结果跟RTL的结果行为上是一致的，所谓的行为上是一致的，体现在当数组有初始值的时候，如果没有加static关键字，一旦在对RAM或者ROM（也就是memory）进行操作的时候将会对memory进行一个初始化的过程，初始化需要的时间跟memory有很大的关系，比如在这个例子中memory是一个长度为8的memory，那么他至少需要8个时钟周期进行初始化，相应的如果memory是1024的长度，那么就需要1024个时钟周期进行初始化，如果前面加了static关键字，那么初始化的值就一定会被写进return文件里头，不会再有相应的初始化的过程</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C24.PNG" alt="24"></p><p>所以这里我们可以看到，static所起的作用</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C25.PNG" alt="25"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>在我们使用数组的时候，如果确定是我们RTL代码里的memory，我们一定要加关键字static</p><p>同样的，如果我们是要做一个ROM，就要加关键字const，可以采用头文件的方式也可以采用在代码中直接赋值的方式</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%5C26.PNG" alt="26"></p>]]></content>
      
      
      <categories>
          
          <category> Vivado HLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vivado HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vivado HLS之for循环优化</title>
      <link href="/2020/01/05/VivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96/"/>
      <url>/2020/01/05/VivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="for循环优化-基本衡量指标"><a href="#for循环优化-基本衡量指标" class="headerlink" title="for循环优化 - 基本衡量指标"></a>for循环优化 - 基本衡量指标</h1><h2 id="看一个例子"><a href="#看一个例子" class="headerlink" title="看一个例子"></a>看一个例子</h2><p>在头文件里定义了一个变量<code>N = 3</code></p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C1.PNG" alt="1"></p><p>N是循环边界，for循环执行的是乘加操作</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C2.PNG" alt="2"></p><p>以上程序可以用以下这样一个状态来表示，一共有四个状态，分别是<code>C0、C1、C2、C3</code>，</p><a id="more"></a><p>在这四个状态中，</p><p>C0是读取数据b和c</p><p>C1是获取数组xin[]的0号地址xin[0]</p><p>C2是从0号地址读取相应的数据</p><p>C3完成相应的计算</p><h2 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h2><p>假定每个状态都消耗一个时钟周期，for循环要执行三次，所以<strong>Loop Trip Count = 3</strong>，也就是代表<strong>循环一共执行了多少次</strong></p><p>对一个for循环而言，有<code>C1、C2、C3</code>三个状态，占用了三个时钟周期，所以它的<strong>Loop Iteration Latency = 3</strong></p><p><strong>本次for循环和下一次for循环的间隔</strong>也是三，所以也是<strong>Loop Iteration Interval（Loop II）= 3</strong>，这个<strong>Loop II</strong>表明了两次相邻的输入之间的间隔，也是以时钟周期的个数表示的，从而我们就可以确定整个for循环的<strong>Loop Latency = 9</strong>，</p><p>整个函数的<strong>Function Latency = 10</strong></p><p>以及<strong>Function Initial Interval（II）= 11</strong></p><p>这些参数是衡量我们设计性能很重要的指标，在综合报告中也能看到这些指标。</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C3.PNG" alt="3"></p><p>这是综合后的报告，相应的Latency、Interation Latency，还有函数的Latency以及相应的Interval</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C4.PNG" alt="4"></p><p>从 CoSimulation的波形来看，当ap_start为高的时候作为起始点，当ap_done为高的时候作为终止点，这样就确定了整个函数的Latency</p><p>这样就确定了整个函数的Function Latency = 10，相应的可以确定Function Initial Interval = 11</p><p>我们在描述for循环的时候很明确的知道for循环执行到什么时候退出，但是对硬件电路而言，需要去判断，判断变量i到底是否超出了循环边界，相应的循环体要不要被终止，这样就需要消耗一个额外的时钟周期，所以并不是i一达到循环边界就结束，会有一个判断的操作</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C5.PNG" alt="5"></p><h2 id="pipeline优化for循环"><a href="#pipeline优化for循环" class="headerlink" title="pipeline优化for循环"></a>pipeline优化for循环</h2><p>对for循环最常见的优化就是做流水线，流水线设置是在directive中设置为pipeline，相应的设置完成以后就可以在Directive窗口中被设置好了</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C6.PNG" alt="6"></p><p>为什么设置pipeline会改善Latency和Interval呢？</p><p>在没有采用pipeline的时候整个操作是按时间的先后顺序来执行的，一旦有了pipeline，就变成了并行的流水线操作</p><p>这里设置pipeline以后，Iteration Latency = 3没有变，每次循环还是要消耗3个时钟周期，但是II就变成1了（Loop II = 1），不用等到上一个for循环执行完了再去读下一个，而是当在读数据的时候，下一次for循环就可以开始获取相应的地址，也可以看到Loop Latency = 3</p><p>这也就是通过pipeline可以把Latency和Interval降下来的原因</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C7.PNG" alt="7"></p><h2 id="在波形图中查看相应的指标"><a href="#在波形图中查看相应的指标" class="headerlink" title="在波形图中查看相应的指标"></a>在波形图中查看相应的指标</h2><p>在波形图中可以查看相应的指标，比如Function Latency和Function Initial Interval</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C8.PNG" alt="8"></p><h2 id="unrolling优化for循环"><a href="#unrolling优化for循环" class="headerlink" title="unrolling优化for循环"></a>unrolling优化for循环</h2><p>对于for循环也可以进行展开优化，在默认的情况下for循环是被折叠的，所谓折叠可以理解为每一次循环都是采用同一套电路，只是这个电路被分时复用了，如果展开就意味着这个for循环被复制了，可能被复制了n次，也可能被复制了n/2ci，可控。</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C9.PNG" alt="9"></p><p>比如下图中<strong>trip count  = 3</strong>，完全展开，相应的资源扩大了三倍，乘法器从一个变成了3个</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C10.PNG" alt="10"></p><h2 id="部分循环展开（Partial-Loop-Unrolling）"><a href="#部分循环展开（Partial-Loop-Unrolling）" class="headerlink" title="部分循环展开（Partial Loop Unrolling）"></a>部分循环展开（Partial Loop Unrolling）</h2><p>如下程序，<strong>trip count = 6</strong>，从C语言角度出发，可以写成三个for循环，这三个for循环<code>i</code>的起始值是不一样的，但是边界都是6，相应的，每个for循环所对应的<code>i</code>也是不一样的，可以在右上角看到：</p><p>loop1：i = 0，3</p><p>loop2：i = 1，4</p><p>loop3：i = 2，5</p><p>所以从这个角度讲，for循环是被拆分成三部分，或者说是被复制了三份，被复制后0和3共用一套逻辑资源，1和4共用一套逻辑资源，2和5共用一套逻辑资源</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C11.PNG" alt="11"></p><h3 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h3><p>当使用部分循环展开时，在directive窗口进行设置，有个参数是<strong>factor</strong>，将其设置为3，意思就是将for循环复制了3份</p><p>综合后的结果可以看到DSP48消耗了三个，也就是乘法器复制了三份</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C13.PNG" alt="13"></p><h2 id="循环变量i"><a href="#循环变量i" class="headerlink" title="循环变量i"></a>循环变量<code>i</code></h2><p>还是以上面的代码为例，循环变量<code>i</code>被声明为了<code>int</code>，也可以声明为ap_int&lt;4&gt;，也就是4比特，因为它的边界是6，所以声明为int还是ap_int是不受影响的，因为Vivado HLS考虑的是<code>i</code>的最大值是多少，从而根据<code>i</code>的最大值进行相应的资源规划，尽管也会考虑到数据类型，但是变量的范围决定了它的资源量</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C14.PNG" alt="14"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一节讲了一些基本的概念，</p><p>循环和函数的Latency以及Interval，</p><p>对于for循环优化最常用的是pipeline，也就是流水</p><p>对于for循环在默认情况下是折叠的，因此我们可以对他进行循环展开</p><p>也可以进行部分展开，设置相应的factor来实现</p><p>部分展开是一种折中的方式，在并行度和资源方面选择一种折中的方案，获取最佳实践</p><p>循环变量对最终的资源消耗量并没有影响</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C15.PNG" alt="15"></p><h1 id="for循环优化-循环合并"><a href="#for循环优化-循环合并" class="headerlink" title="for循环优化 - 循环合并"></a>for循环优化 - 循环合并</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在下面的代码中，有两个循环，一个执行加法，一个执行减法，而且这两个for循环对应的逻辑电路是可以并行执行的，就是可以同时去并行计算<code>a + b</code>和<code>a - b</code>，期望的电路如下右图，有加法和减法，同时把输出数据给到两个运算单元，从而得到相应的结果</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C16.PNG" alt="16"></p><p>但是实际上在默认的情况下，对于加的for循环，Latency等于8，对于减的for循环，Latency也是等于8，从综合后的报告可以看到，这两个for循环是按顺序执行的，考虑到进入for循环和退出for循环需要额外的时钟周期，所以整个的Latency是18个时钟周期</p><p>这显然不符合我们预期的结果</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C17.PNG" alt="17"></p><h2 id="如何-循环合并"><a href="#如何-循环合并" class="headerlink" title="如何 循环合并"></a>如何 循环合并</h2><h3 id="对于循环边界相同的两个常数"><a href="#对于循环边界相同的两个常数" class="headerlink" title="对于循环边界相同的两个常数"></a>对于循环边界相同的两个常数</h3><p>所以在Vivado HLS中就提供了循环合并，在进行循环合并时，有一个新的概念叫region（区域），就是绿色虚线框对应的部分，所谓region就是loop region花括号之间对应的代码段，region作用的loop_merge，循环合并的作用域也就是loo_region下的for循环部分，在相应的directive窗口下就可以看到是生效的</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C18.PNG" alt="18"></p><p>合并之后整个loop就变成了一个，从综合的报告中也可以看到Latency变成了8，整个函数的Latency就变成了9</p><p>，这就是循环合并带给我们的最直接的好处</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C19.PNG" alt="19"></p><p>通过前面的比较可以看到，循环的合并从一定程度上降低Latency，这是因为在默认的状态下，for循环会创建额外的状态机，而状态机会创建额外的时钟周期，以及额外的资源，所以就会导致Latency和整个的资源用量都会有所改变，所以一旦合并，这两个方面都会降低</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C20.PNG" alt="20"></p><h3 id="对于循环边界不同的两个常数"><a href="#对于循环边界不同的两个常数" class="headerlink" title="对于循环边界不同的两个常数"></a>对于循环边界不同的两个常数</h3><p>如下代码中两个循环的循环边界是不同的，在合并之前是分开的，分别是4和2，合并之后trip count变成了4，也就是说，当两个循环的循环边界不同时，在合并时是以最大的边界作为合并后的边界</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C21.PNG" alt="21"></p><h3 id="循环边界有变量的场景（报错）"><a href="#循环边界有变量的场景（报错）" class="headerlink" title="循环边界有变量的场景（报错）"></a>循环边界有变量的场景（报错）</h3><p>如果一个循环的边界是常数，另一个循环的边界是变量的场景</p><p>在这个例子中，第一个循环的循环边界是常数，第二个循环的循环边界是变量，是函数的传入的一个参数</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C22.PNG" alt="22"></p><p>从综合后的报告可以看出，给出的trip count是一个范围，0 ~ 15，这是因为这里的变量K是一个ap_uint&lt;4&gt;的数据类型，四位无符号整数表示的最大范围就是0 ~ 15，所以这里的trip count就是0 ~ 15</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C23.PNG" alt="23"></p><p>如果在这两个for循环上应用loop merge，就会报错</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C24.PNG" alt="24"></p><p>所以当for循环的边界一个是常数，一个是变量的情形下，他们是不能合并的</p><h3 id="循环边界都是变量的场景（报错）"><a href="#循环边界都是变量的场景（报错）" class="headerlink" title="循环边界都是变量的场景（报错）"></a>循环边界都是变量的场景（报错）</h3><p>如下所示代码中，J和K都是变量</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C25.PNG" alt="25"></p><p>综合后的报告中可以看到trip count 是个范围，而不是固定的常数，都是0 ~ 15，</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C26.PNG" alt="26"></p><p>同样对这两个for循环应用loop_merge，报错如下：</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C27.PNG" alt="27"></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>假如上面例子中的K &lt; J</p><p>因为K &lt; J，因此可以把J拆开，拆成两部分，一部分是0 ~ K，一部分是K ~ J</p><p>这样就可以把上面的for循环合并</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C28.PNG" alt="28"></p><p>综合后，在没有采用loop_merge的情况下有三个for循环</p><p>merge之后，只有两个for循环</p><p>所以当两个边界都是for循环时，可以通过修改代码实现for循环的合并</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C29.PNG" alt="29"></p><h2 id="合并规则"><a href="#合并规则" class="headerlink" title="合并规则"></a>合并规则</h2><p>1、当for循环的循环边界是固定常数的情况下，合并之后的for循环是以其中那个大的循环边界为边界</p><p>2、当两个for循环都是变量的情况下，他们必须是相同的值，也就是说，两个边界变量所能达到的最大值和最小值得是一样的，保证他们要有相同的迭代周期</p><p>3、如果循环边界一个是变量，一个是常数，他们是没法合并的</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C30.PNG" alt="30"></p><p>在这一节中还引入了region的概念，region就是两个花括号之间的代码段，合并for循环可以帮助我们在一定程度上降低时钟周期，在Latency上有所改善，同时使一些for循环能够并行执行，但是要注意并不是所有的循环都能合并，我们需要遵循一定的规则</p><h1 id="for循环优化-数据流"><a href="#for循环优化-数据流" class="headerlink" title="for循环优化 - 数据流"></a>for循环优化 - 数据流</h1><h2 id="看一个例子-1"><a href="#看一个例子-1" class="headerlink" title="看一个例子"></a>看一个例子</h2><p>在下面的例子中有三个for循环，分别是Task A，Task B，Task C来做标记，同时for循环所用到的一些变量，也就是一些数组，看他的数据流是怎么样的</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C31.PNG" alt="31"></p><p>首先进来的是数组A，通过循环Task A，生成变量x，x通过Task B，生成变量y，y通过Task C，生成变量C，通过这个例子可以看到，Task B依赖于Task A，因为Task B用到的变量x是通过Task A传过来的，同样Task C生成的C变量是取决于变量y的，所以可以看到A、B、C三个Task中间是有依赖关系的，结合前面for循环优化的两种方法，pipeline和loop merge，来进行优化</p><p>很显然pipeline是没问题的，但是merge是不可以的，因为他们之间存在依赖关系</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C32.PNG" alt="32"></p><h2 id="Dataflow（数据流）优化方式"><a href="#Dataflow（数据流）优化方式" class="headerlink" title="Dataflow（数据流）优化方式"></a>Dataflow（数据流）优化方式</h2><p>三个循环，在循环之间可以通过channel，channel可以是Ping-pong RAM，可以是FIFO，也可以是Register</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C33.PNG" alt="33"></p><p>在没有使用Dataflow时，三个循环的执行顺序就是如下A、B、C，使用Dataflow之后就变成右边的顺序，特点是，循环之间都是并行的关系，同时循环之间是有交叠的，从下图就可以看到，在执行loopA的时候并不需要执行完loopB就可以执行了，只要loopA有输出，就可以用loopA的输出去执行loopB，同时多个任务之间有交叠，这种交叠可以帮助我们降低Latency，而提高数据吞吐率</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C34.PNG" alt="34"></p><h2 id="运用Dataflow之后带来的性能上的好处"><a href="#运用Dataflow之后带来的性能上的好处" class="headerlink" title="运用Dataflow之后带来的性能上的好处"></a>运用Dataflow之后带来的性能上的好处</h2><p>可以看到Latency有明显的降低</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C35.PNG" alt="35"></p><p>再看utilization，也有很大的改善</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C36.PNG" alt="36"></p><p>此外，对于dataflow在使用的时候，每个for循环之间的channel时pingpong ram还是Register可以通过config_dataflow去配置</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C37.PNG" alt="37"></p><p>默认情况下，channel是ping-pong RAM</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C38.PNG" alt="38"></p><h2 id="Dataflow优化限制"><a href="#Dataflow优化限制" class="headerlink" title="Dataflow优化限制"></a>Dataflow优化限制</h2><p>并不是所有的for循环都可以使用dataflow，出现下面这些情况的，在使用的时候就要做一些优化或者改善，重点讲前两个</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C39.PNG" alt="39"></p><h3 id="Single-producer-consumer-Model"><a href="#Single-producer-consumer-Model" class="headerlink" title="Single-producer-consumer Model"></a>Single-producer-consumer Model</h3><p>在下面这个例子中，loop2和loop3，din通过Loop1会生成temp1，然后temp1通过Loop2会生成dout1，同时temp也会到Loop3生成dout2，所以可以看到temp1是被Loop1和Loop2这两个循环都使用到</p><p>这个例子可以使用pipeline，Loop2和Loop3也可以使用merge合并，因为他们两个都是使用temp1执行的</p><p>但是这个例子，不能使用dataflow，因为这个模型导致temp1在Loop2和Loop3两个循环中都使用， 所以要进行修改代码，使得可以使用dataflow</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C40.PNG" alt="40"></p><p> 首先编写循环loop_copy，在loop_copy中执行的操作很简单，就是把temp1赋给了temp2和temp3，temp2只是流向loop2，temp3只是流向loop3，接着又分别生成dout1和dout2，然后对其进行综合发现，此时的Latency和Interval都有所改善，utilization也有相应的改善，这个是旨在说明，变量只能在一个for循环中被使用</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C41.PNG" alt="41"></p><h3 id="Bypassing-Tasks-Model"><a href="#Bypassing-Tasks-Model" class="headerlink" title="Bypassing Tasks Model"></a>Bypassing Tasks Model</h3><p>这个例子是在Loop2中temp1会生成temp3，数据流如右图所示是din通过Loop1生成temp1，temp1通过Loop2生成temp3，但是Loop1中还有一个变量temp2会直接到Loop3，而没有经过Loop2，因此相对于Loop2而言他是Bypassing</p><p>这时候，pipeline是可以使用的，</p><p>但是如果使用merge，因为temp1在Loop2中会使用，temp2和temp3在Loop3会使用，temp3的数据来自于Loop2和Loop1，所以也是不能使用merge的</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C42.PNG" alt="42"></p><p>但是我们可以进行优化</p><p>我们在Loop2中对temp2进行额外的复制，数据流是din通过Loop1生成temp1和temp2，然后temp1和temp2通过Loop2分别生成temp3和temp4，注意，temp4只是temp2的复制，这样temp2就在Loop2中有所体现，然后再通过Loop3生成dout，这时候就可以使用Dataflow，可以看到综合后的结果相应的Latency、Interval和Utilization都有所体现。</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C43.PNG" alt="43"></p><h3 id="配置Dataflow的内存通道（Configuring-Dataflow-Memory-Channels）"><a href="#配置Dataflow的内存通道（Configuring-Dataflow-Memory-Channels）" class="headerlink" title="配置Dataflow的内存通道（Configuring Dataflow Memory Channels）"></a>配置Dataflow的内存通道（Configuring Dataflow Memory Channels）</h3><p>这里说的Memery也就是channel，可以使用ping-pong也可以使用FIFO</p><p>1、如果参数是个scalar、pointer或者reference，Vivado HLS会把它作为FIFO</p><p>2、如果参数是个数组，结果可能是ping-pong RAM也可能是FIFO</p><ul><li>如果Vivado HLS能够判断出数据流是按顺序，也就是体现出FIFO的特征，那么这时候就会配置成FIFO，相应的depth深度为1</li><li>如果无法检查出数据的特征，也就是说数据的顺序是随机的，这时候就会把channel变成ping-pong RAM</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Configuring Dataflow Memory Channels</span><br><span class="line">Vivado HLS implements channels between the tasks as either ping-pong or FIFO buffers, depending on the access patterns of the producer and the consumer of the data.</span><br><span class="line"><span class="bullet"> - </span>For scalar, pointer, and reference parameters as well as the function return, Vivado HLS implements the channel as a FIFO.</span><br><span class="line"><span class="bullet"> - </span>If the parameter (producer or consumer) is an array, Vivado HLS implements the channel as a ping-pong buffer or a FIFO as follows.</span><br><span class="line"><span class="code">• If Vivado HLS determines the data is accessed in sequential order, Vivado HLS implements the memory channel as a FIFO channel of depth 1.</span></span><br><span class="line"><span class="code">• If Vivado HLS is unable to determine that the data is accessed in sequential order or determines the data is accessed in an arbitrary manner, Vivado HLS implements the memory channel as a ping-pong buffer. that is, as two block RAMs each defined by the maximum size of the consumer or producer array.</span></span><br><span class="line">配置数据流内存通道</span><br><span class="line">Vivado HLS根据数据生产者和消费者的访问方式，将任务之间的通道实现为ping-pong或FIFO缓冲区。</span><br><span class="line">  -对于scalar，指针和引用参数以及函数返回值，Vivado HLS将通道实现为FIFO。</span><br><span class="line">  -如果参数（生产者或消费者）是数组，则Vivado HLS将该通道实现为ping-pong缓冲区或FIFO，如下所示。</span><br><span class="line"><span class="code">• 如果Vivado HLS确定按顺序访问数据，则Vivado HLS将存储通道实现为深度为1的FIFO通道。</span></span><br><span class="line"><span class="code">• 如果Vivado HLS无法确定按顺序访问数据或确定以随机方式访问数据，则Vivado HLS将存储通道实现为ping-pong缓冲区。（也就是说，作为两个Block RAM，每个Block RAM由使用者或生产者阵列的最大大小定义。）</span></span><br></pre></td></tr></table></figure><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C44.PNG" alt="44"></p><h3 id="显式指定默认通道（To-explicitly-specify-the-default-channel）"><a href="#显式指定默认通道（To-explicitly-specify-the-default-channel）" class="headerlink" title="显式指定默认通道（To explicitly specify the default channel）"></a>显式指定默认通道（To explicitly specify the default channel）</h3><p>我们也可以通过config_dataflow很显式的告诉Vivado HLS这个Memery是FIFO还是ping-pong RAM，只是需要注意，一旦配置成FIFO，FIFO的深度如果配置的有问题，再RTL协同仿真的时候就会报错</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C45.PNG" alt="45"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>1、dataflow对for循环的改善，可以使得for循环并行的执行方式，也就是说相邻的顺序的变成了并行，体现在for循环可以重叠的执行，下一个for循环不必等到前一个for循环执行完了再执行，只要前一个for循环有输出，就可以利用当前的输出去执行下一个for循环</p><p>2、在使用dataflow的时候也有一些限制，最典型的就是上面所讲的那两个限制</p><p>3、对于for循环之间的memery也就是channel，我们可以缺省的使用默认的配置方式，也可以显式的配置为FIFO或者ping-pong RAM</p><h1 id="for循环优化-嵌套的for循环"><a href="#for循环优化-嵌套的for循环" class="headerlink" title="for循环优化 - 嵌套的for循环"></a>for循环优化 - 嵌套的for循环</h1><h2 id="嵌套for循环的分类"><a href="#嵌套for循环的分类" class="headerlink" title="嵌套for循环的分类"></a>嵌套for循环的分类</h2><p>在Vivado HLS中对嵌套的for循环有三种分类</p><h3 id="第一类是perfect-loop-nest"><a href="#第一类是perfect-loop-nest" class="headerlink" title="第一类是perfect loop nest"></a>第一类是perfect loop nest</h3><p>特征是循环边界都是常数，同时循环体只会在最内层的for循环里出现</p><h3 id="第二类是Semi-Perfect-loop-nest"><a href="#第二类是Semi-Perfect-loop-nest" class="headerlink" title="第二类是Semi-Perfect loop nest"></a>第二类是Semi-Perfect loop nest</h3><p>这种情况最外层的for循环循环边界是变量，但内层的循环边界是常数，同时循环体也只会在最内层的for循环里出现</p><h3 id="第三类是Imperfect-loop-nest"><a href="#第三类是Imperfect-loop-nest" class="headerlink" title="第三类是Imperfect loop nest"></a>第三类是Imperfect loop nest</h3><p>Imperfect loop nest其中又分成两类，</p><p>第一类是循环边界是常数，但是循环体出现在外部循环中，</p><p>第二类是尽管循环体只在内层for循环，但是最内部的for循环循环边界是个变量</p><p>对于Imperfect loop nest希望可以通过代码优化的手段把它转化成Semi-Perfect loop nest或者是Perfect loop nest</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C46.PNG" alt="46"></p><h2 id="perfect-loop的例子"><a href="#perfect-loop的例子" class="headerlink" title="perfect loop的例子"></a>perfect loop的例子</h2><p>这个例子是两个矩阵对应元素相乘，这里并不是矩阵的乘法，而是矩阵的元素对应相乘，这里M=2，N=4，是声明在头文件里的，然后做一个对比</p><p>三种情况：1、不加任何约束；2、只对内部for’循环做pipeline；3、只对外层循环做pipeline。</p><p>可以看到，只对外层for循环做pipeline的时候，Latency是最小的</p><p>而在资源消耗方面，对外层for循环做pipeline，DSP48E也就是乘法器，用到了4个，这其实是因为，当我们做流水的时候，如果是对外层for循环做流水，这个外层for循环下面的所有的for循环都会被打开，相应的资源也就会增加，所以这就是乘法器变成了4个的原因</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C47.PNG" alt="47"></p><p>如果对最内层的for循环做pipeline，就会看到控制台有一个输出信息，<code>Flattening a loop nest</code>，这时候trip count变成了8，也就是2x4，也就是把内部的for循环展开并打平，外部的for循环也是展开打平，所以count就变成了8</p><p>Loop_Flatten的要求是两个for嵌套的循环一定要是perfect loop或者是Simi-perfect loop，</p><h2 id="Imperfect-Loop的例子"><a href="#Imperfect-Loop的例子" class="headerlink" title="Imperfect Loop的例子"></a>Imperfect Loop的例子</h2><p>这个是矩阵的乘法，可以看到，在第二个for循环和第三个for循环之间有一个循环体，也就是初始化为0的操作，这两个矩阵都是3x3的矩阵</p><h3 id="如果只对最内层的for循环做pipeline（流水）"><a href="#如果只对最内层的for循环做pipeline（流水）" class="headerlink" title="如果只对最内层的for循环做pipeline（流水）"></a>如果只对最内层的for循环做pipeline（流水）</h3><p>1、如果只对最内层的for循环做流水，整个count外部的变成了9，内层的还是3，因为这个col对应的for循环和Product对应的for循环之间有循环体，是无法应用Loop Flatten的，所以这就是为什么Product对应的for循环是3，而Row和Col对应的for循环被打平</p><p>同时在分析结果中也可以看到，这个Imperfect loop是要做初始化的</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C48.PNG" alt="48"></p><h3 id="如果只是对第二层for循环做pipeline"><a href="#如果只是对第二层for循环做pipeline" class="headerlink" title="如果只是对第二层for循环做pipeline"></a>如果只是对第二层for循环做pipeline</h3><p>2、如果只是对第二层for循环做pipeline，也就是Col对应的for循环做流水，首先会在输出信息中看到有一个Unrolling loop ‘Product’，也就是说把Col对应的for循环下面的所有for循环都会打开，所以这时候for循环就变成了Rol和Col都被打平，trip count变成了9，而内部的Product循环会被展开，在这里unrolling和flatten是不一样的概念</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOOP_FLATTEN的directive作用是“允许嵌套循环塌缩为一个循环以减少延时”，原文是“Allows netsed loops to be collapsed into a single loop with inproved latency”</span><br></pre></td></tr></table></figure><p>同时在分析表（右下）中还可以看到都有一个a load，同时在相应的信息中也可以看到，会有limited memory ports，在默认情况下会把数组声明为相应的memory，在这里他是一个双端口的memory</p><p>在这里得出结论，如果我们对上层的for循环做pipeline，那么这个for循环下面的所有for循环都会被unroll也就是会被展开</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C49.PNG" alt="49"></p><h3 id="如果只对最外层的for循环做pipeline"><a href="#如果只对最外层的for循环做pipeline" class="headerlink" title="如果只对最外层的for循环做pipeline"></a>如果只对最外层的for循环做pipeline</h3><p>3、如果只对最外层的for循环做pipeline，他会把下面的for循环全部展开（Unrolling），trip count变成了3，但是DSP48变成了9</p><p>这也进一步验证了以上的结论，对上层的for循环做流水，下面的for循环全都会被展开（Unrolling）</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C50.PNG" alt="50"></p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>四种情况</p><p>1、不加任何约束</p><p>2、对最内层循环做流水</p><p>3、对中间层循环做流水</p><p>4、对最外层循环做流水</p><p>可以看到，Latency的变化，显然，对最外层的循环做流水，可以获得最好的Latency，但是资源方面用到的DSP48是最多的</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C51.PNG" alt="51"></p><h2 id="对整个函数做流水"><a href="#对整个函数做流水" class="headerlink" title="对整个函数做流水"></a>对整个函数做流水</h2><p>可以看到，整个函数中的循环都被展开了</p><p>对函数做流水，能获得最好的Latency，但是相应的，使用的资源也是最多的，DSP48变成了27个</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C52.PNG" alt="52"></p><h2 id="矩阵乘法优化"><a href="#矩阵乘法优化" class="headerlink" title="矩阵乘法优化"></a>矩阵乘法优化</h2><p>矩阵乘法的规则可以用相应的地址来表示，比如第i行第j列要算第k个乘法，那么要获得第0行第0列的数据，那么会执行什么样的操作呢？</p><p>就是a的第0行，b的第0列，相乘，然后再做相加，获得结果的第0行0列的元素</p><p>同样a的第0行，b的第1列，相乘，然后再做相加，获得结果的第0行1列的元素</p><p>那么在这个过程中可以看到，a的第0行在算结果的第0行的时候，是保持不变的，实际上我们只要读一次将他缓存起来就可以，而b需要读第0列、第1列、第2列… …，同样在算结果的第1行第0列、1列、2列的元素的时候，类似的也是，我们对a只需要读相应的第1行的元素，对b要读第0列、1列、2列的元素，都要遍历一下</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C53.PNG" alt="53"></p><p>经过上面的分析就可以对C代码进行优化，见Cache_Row，做了一个缓存的机制，也就是在计算结果的第0行的元素的时候，把a的第0行缓存下来</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C54.PNG" alt="54"> </p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>1、对循环或者函数做流水的时候，他们所在的下层的for循环都会被展开（unroll）</p><p>2、通常情况下，建议对最内部的函数做流水，这样既可以获得较好的Latency，同时资源用量也是可以接受的</p><h1 id="for循环优化-其他方法"><a href="#for循环优化-其他方法" class="headerlink" title="for循环优化 - 其他方法"></a>for循环优化 - 其他方法</h1><p>主要内容</p><ul><li><p>for循环的并行性</p></li><li><p>for循环在做流水的时候如何使用rewind option</p></li><li><p>当for循环的循环边界是变量的时候如何处理</p></li></ul><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C63.PNG" alt="63"></p><h2 id="for循环的并行性"><a href="#for循环的并行性" class="headerlink" title="for循环的并行性"></a>for循环的并行性</h2><p>这个例子中，这个函数包括两个for循环，sum_x和sum_y，这两个for循环分别用到了数组A和数组B，然后分别产生了相应的数组X和数组Y，可以看到这两个for循环是相互独立的，也就是说把他们翻译成相应的硬件电路是可以并行执行的，但是从综合后的结果来看，Vivado HLS是把他们做了顺序执行的，我们可以看到整个的Latency是18，来源于两个for循环串行相加的结果</p><p>所以，在默认的情况下，Vivado HLS是把for循环做顺序执行的，其实很容易想到，因为这两个for循环是相互独立的，循环边界都是常数且相等，因此可以用merge的方式降低Latency，但是当for循环的边界是变量的时候，是没有办法用merge的</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C55.PNG" alt="55"></p><p>但是假如把for循环封装成一个函数，然后在顶层函数中对这个函数调用两次，这样的话综合后的结果跟前边的结果是一致的，这样可以看出来，Vivado HLS是把这个函数做了分时复用，相应的节省了资源，但是从并行性的角度而言，相应的函数还是顺序执行的，</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C56.PNG" alt="56"></p><h3 id="使函数并行执行的方法"><a href="#使函数并行执行的方法" class="headerlink" title="使函数并行执行的方法"></a>使函数并行执行的方法</h3><p>那么有没有什么方式可以实现使函数并行执行呢，我们可以通过ALLOCATION这个directive可以实现让这两个函数并行执行，在这里这个AllOCATION有个limited = 2，就是说将这个函数Accumulator()复制了两份，换言之，这两个函数就实现了并行执行，这时我们可以看到Latency已经变成了10</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C57.PNG" alt="57"></p><h3 id="对上面两个结果进行比较"><a href="#对上面两个结果进行比较" class="headerlink" title="对上面两个结果进行比较"></a>对上面两个结果进行比较</h3><p>对上面两个结果进行比较，可以看到整个的Latency是降低了，这里的策略是将for循环封装成函数以后，采用了ALLOCATION的directive，同时把这个for循环做了pipeline，从仿真结果也可以看到，这个函数是并行执行的，</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C58.PNG" alt="58"></p><h2 id="使用rrewind-option"><a href="#使用rrewind-option" class="headerlink" title="使用rrewind option"></a>使用rrewind option</h2><p>看下面这个for循环，这个for循环有三个操作，读、运算、写，如果我们只是添加了pipeline的策略，这时候，在执行完了一次for’循环在执行下一次for循环时，中间会有一个时钟周期的空挡，如果我们使用rewind之后，两次for循环之间时没有空挡的，这样就降低了整个函数的Latency，因为for循环的Latency降低了，从而也会将整个函数的Latency降低，</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C59.PNG" alt="59"></p><h3 id="rewind使用举例"><a href="#rewind使用举例" class="headerlink" title="rewind使用举例"></a>rewind使用举例</h3><p>这是一个累加运算，</p><p>采用pipeline，并选中<code>enable loop rewinding (option)</code>，</p><p>这时候可以看到，在默认情况下，以及只添加pipeline，以及添加pipeline并选中rewind三种solution做了比较，</p><p>显然，采用添加pipeline并选中rewind的方式Latency时最小的，Interval也是最小的</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C60.PNG" alt="60"></p><p>从仿真结果也可以看出来，在没有rewind的情况下，for循环在执行的时候，中间会有一段空挡，添加rewind之后就没有空档了，执行是连续的执行</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C61.PNG" alt="61"></p><h3 id="函数中有多个循环的情况"><a href="#函数中有多个循环的情况" class="headerlink" title="函数中有多个循环的情况"></a>函数中有多个循环的情况</h3><p>当我们的函数中有多个循环的时候，比如下面这个例子，有sum_x和sum_y，这时候如果我们再对这两个或者其中的某一个做rewind的时候，会抛出警告如下，告诉我们因为这个函数包含了多个循环，因此没法执行rewind，因此rewind不是适用于所有的for循环，他是有条件的</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C62.PNG" alt="62"></p><h3 id="如何对for循环自动添加流水"><a href="#如何对for循环自动添加流水" class="headerlink" title="如何对for循环自动添加流水"></a>如何对for循环自动添加流水</h3><p>这个时候就要用到config_compile configuration，这个是通过pipeline loops option来设置我们期望的循环次数，换言之，当这个循环次数小于我们设定的值的时候，这个循环就会被添加流水</p><p>比如这里的参数pipeline loops设置为6，那么当循环的次数小于6的时候就会被添加流水</p><p>如果在使用config_compile之后，如果仍然希望有一些for’循环不做流水，这时候我们就可以在directive的pipeline这个选项中将disable loop pipelining选项选中，那么相应的for循环就不会被添加流水，</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C64.PNG" alt="64"></p><h3 id="添加pipeline失效的情况"><a href="#添加pipeline失效的情况" class="headerlink" title="添加pipeline失效的情况"></a>添加pipeline失效的情况</h3><p> 当我们对一个任务把它作为pipeline的时候，对于函数或者一个for循环，相应的这些函数或者for循环下边的操作都会被展开，那么如果这个for循环的循环边界是一个变量的话，就阻止了工具对相应的操作执行流水，这是因为Vivado HLS并不知道这个循环什么时候能够完成，这就是要讲的下一个问题，如何处理循环边界是变量的情形。</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C65.PNG" alt="65"></p><h3 id="如何处理循环边界是变量的情形"><a href="#如何处理循环边界是变量的情形" class="headerlink" title="如何处理循环边界是变量的情形"></a>如何处理循环边界是变量的情形</h3><p>当循环边界是变量的时候会引发一些问题，首先是Vivado HLS无法确定Loop的Latency是多少，进而也就无法确定整个函数的Latency，这时候相应的Latency会以问号作为标记，在下面的例子中，循环边界width是个变量，最后的综合报告中可以看到，Latency和Interval都是问号，这里这个width是个int型，也就是32位的一个整型</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C66.PNG" alt="66"></p><p>对于这种情况，有三种处理方式：</p><p>1、使用Tripcount的directive</p><p>2、将循环边界的数据类型声明为<code>ap_int&lt;w&gt;</code></p><p>3、使用assert这个macro</p><h4 id="使用Tripcount的directive的方式"><a href="#使用Tripcount的directive的方式" class="headerlink" title="使用Tripcount的directive的方式"></a>使用Tripcount的directive的方式</h4><p>先看一下使用Tripcount的directive的方式，在这里有一个min和一个max，是用来说明tripcount的最大值和最小值，相应的综合后的报告中就能看到，tripcount的值的范围是4 ~ 8，相应的Latency就有min和max，interval也有相应的min和max</p><p>这里需要注意的是，tripcount这个directive不会影响综合后的结果，不会对综合做任何的优化，只是用于报告的显示，以及不同solution之间的比较，</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C67.PNG" alt="67"></p><h4 id="将循环边界的数据类型声明为ap-int-lt-w-gt"><a href="#将循环边界的数据类型声明为ap-int-lt-w-gt" class="headerlink" title="将循环边界的数据类型声明为ap_int&lt;w&gt;"></a>将循环边界的数据类型声明为<code>ap_int&lt;w&gt;</code></h4><p>再看一下将循环边界声明为<code>ap_int&lt;w&gt;</code>类型的情景，因为我们在头文件里定义了TEST，所以相应的循环边界的类型就变成了ap_int&lt;5&gt;，所以综合后的报告中tripcount就变成了0 ~ 15，因为5位有符号整数所能表示的最大值就是15</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C68.PNG" alt="68"></p><p>看一下综合后的结果，从资源角度看，整个的LUT会减少，触发器也会减少</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C69.PNG" alt="69"></p><h4 id="使用assert这个macro"><a href="#使用assert这个macro" class="headerlink" title="使用assert这个macro"></a>使用assert这个macro</h4><p>头文件添加<code>#include&lt;assert.h&gt;</code>，同时在for循环上边声明<code>assert(width &lt; 5);</code>，这时候tripcount就变成了0 ~ 4，</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C70.PNG" alt="70"></p><p>综合后的报告可以看到，整个资源也会进一步减少，LUT从104变成了29，触发器由80变成了19，</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C71.PNG" alt="71"></p><p>对这三种方法进一步作比较，当采用assert这种方式的时候，Latency是最小的，同时相应的资源消耗也是最小</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C72.PNG" alt="72"></p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>1、当函数中有多个for循环的时候，即便多个for循环是相互独立的，Vivado HLS默认情况下也会让他们默认执行，而不是并行处理</p><p>2、当我们对for循环做pipeline的时候，我们可以选择rewind，帮助我们进一步改善Latency，但是并不是所有的for循环都能使用rewind</p><p>3、当循环边界是变量的时候，我们有三种处理方式，通过tripcount、通过改变循环边界的变量类型、通过采用assert三种方式，其中后两种方式是可以帮助我们改善综合后的一些结果，比如Latency以及资源。</p>]]></content>
      
      
      <categories>
          
          <category> Vivado HLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vivado HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复合数据类型在Vivado HLS中的应用</title>
      <link href="/2020/01/04/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2020/01/04/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="复合数据类型在Vivado-HLS中的应用"><a href="#复合数据类型在Vivado-HLS中的应用" class="headerlink" title="复合数据类型在Vivado HLS中的应用"></a>复合数据类型在Vivado HLS中的应用</h1><h2 id="结构体Struct"><a href="#结构体Struct" class="headerlink" title="结构体Struct"></a>结构体Struct</h2><h3 id="当结构体被用作顶层函数的参数时"><a href="#当结构体被用作顶层函数的参数时" class="headerlink" title="当结构体被用作顶层函数的参数时"></a>当结构体被用作顶层函数的参数时</h3><p>对于<code>scalar</code>，会被映射为<code>scalar</code>类型的端口</p><p>对于数组，会被映射为默认的<code>memory</code>端口</p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>在实际使用中建议结构体预先在头文件中声明</p><h3 id="data-packing"><a href="#data-packing" class="headerlink" title="data packing"></a>data packing</h3><a id="more"></a><p>对于结构体中的元素，Vivado HLS提供了相应的优化方式，叫做<code>data packing</code></p><p>这种优化方式具体有两种，一种是<code>field_level</code>，一种是<code>struct_level</code></p><ul><li><code>field_level</code></li><li><code>struct_level</code></li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C1.PNG" alt="1"></p><p>在这个例子中，首先在头文件中定义了一个结构体</p><p>结构体中有两个变量</p><p><code>A_t A</code>：类型为<code>ap_int&lt;4&gt;</code></p><p><code>B_t B[4]</code>：类型为<code>ap_uint&lt;4&gt;</code>的数组，数组元素4个</p><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C2.PNG" alt="2"></p><p>然后进行操作，对于变量<code>A</code>，执行的是加法。进行加2操作</p><p>对于变量<code>B[]</code>，对数组中的每一个元素都加2</p><p>最后返回值返回的也是一个结构体变量</p><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C3.PNG" alt="3"></p><p>用<code>cout</code>查看结构体的<code>size</code>，结果是5</p><p>因为</p><p><code>A_t A</code>：类型为<code>ap_int&lt;4&gt;</code>占1个byte</p><p><code>B_t B[4]</code>：类型为<code>ap_uint&lt;4&gt;</code>的数组，数组元素4个，占4个byte</p><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C4.PNG" alt="4"></p><h5 id="field-level"><a href="#field-level" class="headerlink" title="field_level"></a>field_level</h5><p>把每个元素都扩展成8bits</p><p>最后<code>40bits</code>，</p><p>因为五个元素，<code>5 x 8 = 40</code></p><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C5.PNG" alt="5"></p><h5 id="struct-level"><a href="#struct-level" class="headerlink" title="struct_level"></a>struct_level</h5><p>对于每一个元素的实际位宽，依然保留，但是封装后的位宽要取8比特的整数倍</p><p>这里，五个元素，<code>5x4=20</code>，取8比特的整数倍=24，最终位宽是24bits</p><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C6.PNG" alt="6"></p><p>对其进行比较</p><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C7.PNG" alt="7"></p><p>各方面基本一致</p><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C8.PNG" alt="8"></p><p>从这里也可以看到，data packing可以帮助把<code>latency</code>降低，initial interval也降低，提高了系统的吞吐率</p><p>之所以能提高，在这个函数而言是因为把for循环展开了</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%5C9.PNG" alt="9"></p>]]></content>
      
      
      <categories>
          
          <category> Vivado HLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vivado HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型的转换</title>
      <link href="/2020/01/03/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
      <url>/2020/01/03/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h1><h2 id="如何对一个变量进行初始化"><a href="#如何对一个变量进行初始化" class="headerlink" title="如何对一个变量进行初始化"></a>如何对一个变量进行初始化</h2><p>在传统的C语言中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val_i = <span class="number">-6</span>;</span><br></pre></td></tr></table></figure><p>对任意精度的数据类型</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ap_int&lt;<span class="number">6</span>&gt; a_6bit_var_c = <span class="number">-22</span>; <span class="comment">//copy initialization(Y)</span></span><br><span class="line"><span class="function">ap_int&lt;6&gt; <span class="title">a_6bit_var_d</span><span class="params">(<span class="number">-22</span>)</span></span>; <span class="comment">//direct initialization(Y)</span></span><br><span class="line">ap_int&lt;<span class="number">6</span>&gt; a_6bit_var_u&#123;<span class="number">-22</span>&#125;; <span class="comment">//uniform initialization(N), 目前的Vivado HLS不支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用任意进制的格式</span></span><br><span class="line"><span class="function">ap_int&lt;6&gt; <span class="title">a_6bit_var_r2</span><span class="params">(<span class="string">"0b101010"</span>, <span class="number">2</span>)</span></span>; <span class="comment">//二进制</span></span><br><span class="line"><span class="function">ap_int&lt;6&gt; <span class="title">a_6bit_var_r2</span><span class="params">(<span class="string">"0o52"</span>, <span class="number">8</span>)</span></span>; <span class="comment">//八进制</span></span><br><span class="line"><span class="function">ap_int&lt;6&gt; <span class="title">a_6bit_var_r2</span><span class="params">(<span class="string">"-22"</span>, <span class="number">10</span>)</span></span>; <span class="comment">//十进制</span></span><br><span class="line"><span class="function">ap_int&lt;6&gt; <span class="title">a_6bit_var_r2</span><span class="params">(<span class="string">"0x2A"</span>, <span class="number">16</span>)</span></span>; <span class="comment">//十六进制</span></span><br></pre></td></tr></table></figure><p>当然，在上边任意进制的格式中，前边<code>0b，0o，0x</code>，这种显式的声明可以去掉。</p><p>在初始化的时候尽量每一行只初始化一个变量，避免一行初始化多个变量。</p><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%5C1.PNG" alt="1"></p><h2 id="对于ap-u-fixed-lt-W-I-Q-O-gt-这种变量"><a href="#对于ap-u-fixed-lt-W-I-Q-O-gt-这种变量" class="headerlink" title="对于ap_[u]fixed&lt;W, I, Q, O&gt;这种变量"></a>对于<code>ap_[u]fixed&lt;W, I, Q, O&gt;</code>这种变量</h2><p>对于<code>ap_[u]fixed&lt;W, I, Q, O&gt;</code>这种变量，他的<code>&lt;&gt;</code>中由四个参数，分别代表</p><p><code>W</code>：代表整个的数据字长</p><p><code>I</code>：代表整数部分的数据字长，显然小数部分的字长就是：<code>W - I</code></p><p><code>Q</code>：代表<strong>量化模式</strong>，针对低位部分</p><p><code>O</code>：表示了<strong>Overflow</strong>，<strong>溢出模式</strong>，针对高位部分</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var1字长为3，整数部分的字长为2</span></span><br><span class="line"><span class="comment">//1.25用2进制表示：01.01，小数点在中间位置</span></span><br><span class="line"><span class="comment">//biaoshicheng&lt;3, 2&gt;，字长为3，整数部分的字长为2</span></span><br><span class="line"><span class="comment">//就变成了01.0，var1结果其实就是1</span></span><br><span class="line">ap_fixed&lt;<span class="number">3</span>, <span class="number">2</span>&gt; var1 = <span class="number">1.25</span>;</span><br><span class="line"><span class="comment">//var2采用了AP_RND量化模式，最终数值是1.5</span></span><br><span class="line">ap_fixed&lt;<span class="number">3</span>, <span class="number">2</span>, AP_RND&gt; var2 = <span class="number">1.25</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//19用2进制表示010011这种形式，</span></span><br><span class="line"><span class="comment">//字长为4，整数部分为4，所以是取低四位，所以是0011，所以是3</span></span><br><span class="line">ap_fixed&lt;<span class="number">4</span>, <span class="number">4</span>&gt; var3 = <span class="number">19</span>;</span><br><span class="line"><span class="comment">//var4溢出模式AP_SAT，所以值为四位有符号数所能表示的最大数值，0111，7</span></span><br><span class="line">ap_fixed&lt;<span class="number">3</span>, <span class="number">2</span>, AP_RND, AP_SAT&gt; var4 = <span class="number">19</span>;</span><br></pre></td></tr></table></figure><p>定义浮点类型的数值时，后边要有<code>f</code>，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">vf2</span><span class="params">(<span class="number">5.0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">vf3</span><span class="params">(<span class="number">5.0f</span>)</span></span>; <span class="comment">//表示单精度浮点</span></span><br></pre></td></tr></table></figure><p>Vivado HLS的数学库（<code>hls_math.h</code>）提供了对标准C的（<code>math.h</code>）和C++的（<code>cmath</code>）都提供了支持</p><ul><li>支持包括单精度、双精度以及浮点数据类型本身的支持</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hls_math.h</span><br><span class="line">math.h</span><br><span class="line">cmath</span><br></pre></td></tr></table></figure><h2 id="隐式数据类型转换"><a href="#隐式数据类型转换" class="headerlink" title="隐式数据类型转换"></a>隐式数据类型转换</h2><p>隐式的数据类型转换包括<code>promotion</code>和<code>conversion</code>两种，</p><p><code>promotion</code>：一种安全的方式，将小范围向大范围的，或者说将小类型的向大类型的数据转换</p><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%5C2.PNG" alt="2"></p><p><code>conversion</code>：可能会造成数据精度的损失</p><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%5C3.PNG" alt="3"></p><h2 id="数据类型显式的转换"><a href="#数据类型显式的转换" class="headerlink" title="数据类型显式的转换"></a>数据类型显式的转换</h2><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%5C4.PNG" alt="4"></p><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%5C5.PNG" alt="5"></p><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%5C6.PNG" alt="6"></p><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2%5C7.PNG" alt="7"></p>]]></content>
      
      
      <categories>
          
          <category> Vivado HLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vivado HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何处理任意精度的数据类型</title>
      <link href="/2020/01/02/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%BB%E6%84%8F%E7%B2%BE%E5%BA%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/01/02/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%BB%E6%84%8F%E7%B2%BE%E5%BA%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="任意精度的数据类型"><a href="#任意精度的数据类型" class="headerlink" title="任意精度的数据类型"></a>任意精度的数据类型</h1><p>传统的C语言支持的数据类型：包括字符型、整型、浮点型等等，整型分为有符号和无符号，有符号用signed标识，无符号用unsigned标识，有符号的signed可以省略。</p><a id="more"></a><p><img data-src="1.PNG" alt="1"></p><p>Vivado HLS对于两种字符型是不支持的：char16_t(C++11 only)、char32_t(C++11 only)</p><p><img data-src="2.PNG" alt="2"></p><p>从硬件的角度看数据类型：</p><p>采用传统的C语言的数据类型的限制</p><ul><li>都是以8为边界：8，16，32，64bits</li></ul><p><img data-src="4.PNG" alt="4"></p><p><img data-src="3.PNG" alt="3"></p><h1 id="采用任意精度数据类型的好处"><a href="#采用任意精度数据类型的好处" class="headerlink" title="采用任意精度数据类型的好处"></a>采用任意精度数据类型的好处</h1><p>可以看到，采用任意精度的数据类型，可以运行到更高的时钟频率、获得更好的数据吞吐率、在资源方面消耗的也最少</p><p>因此，采用任意精度的数据类型可以获得很多好处，而且通常情况下C/C++所支持的整型的数据类型的相关的运算，ap_[u]int和ap_[u]fixed也都是支持的</p><p>采用任意精度的数据类型可以以更少的资源，获得相同的精度，同时还可以运行在相同的时钟频率下</p><p><img data-src="5.PNG" alt="5"></p><p>当我们在声明一个任意精度的数据类型的时候一般会在头文件中进行声明，这在做debug的时候会非常有用，如下所示的例子，这里定义了一个头文件，在头文件中有一个宏，同时位宽是18，可以根据宏定义进行切换，数据类型到底是int还是ap_int，相应的在Vivado HLS的Outline里也可以看到，这时候有宏定义的时候，相应的数据类型会以高亮的形式显示出来</p><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%BB%E6%84%8F%E7%B2%BE%E5%BA%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%5C6.PNG" alt="6"></p><p>跟数据类型相应的是<code>sizeof()</code>，这个返回的是数据类型所占用的相应的字节，使用方法是参数传入数据类型或者传入变量名，下图中也可以看到这些数据类型所占用的位数。</p><p><img data-src="E:%5Cblog2%5Csource_posts%5C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%BB%E6%84%8F%E7%B2%BE%E5%BA%A6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%5C7.PNG" alt="7"></p>]]></content>
      
      
      <categories>
          
          <category> Vivado HLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vivado HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vivado HLS的工作原理</title>
      <link href="/2020/01/01/VivadoHLS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2020/01/01/VivadoHLS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Vivado-HLS的工作原理"><a href="#Vivado-HLS的工作原理" class="headerlink" title="Vivado HLS的工作原理"></a>Vivado HLS的工作原理</h1><h2 id="EDA领域的发展历史"><a href="#EDA领域的发展历史" class="headerlink" title="EDA领域的发展历史"></a>EDA领域的发展历史</h2><h3 id="CAD-gt-CAE-gt-EDA"><a href="#CAD-gt-CAE-gt-EDA" class="headerlink" title="CAD -&gt; CAE -&gt; EDA"></a>CAD -&gt; CAE -&gt; EDA</h3><ul><li>Computer Aided Design</li><li>Computer Aided Engineering</li><li>Electronic Design Automation<ul><li>在EDA阶段最典型的特征就是出现了HDL（硬件描述语言），例如VHDL和Verilog</li></ul></li></ul><a id="more"></a><h3 id="ESL（Electronic-System-Level）"><a href="#ESL（Electronic-System-Level）" class="headerlink" title="ESL（Electronic System  Level）"></a>ESL（Electronic System  Level）</h3><ul><li>在ESL这个阶段希望采用具有更高抽象度的方式去描述系统行为</li></ul><h4 id="两个最为显著的系统特征"><a href="#两个最为显著的系统特征" class="headerlink" title="两个最为显著的系统特征"></a>两个最为显著的系统特征</h4><p>1、使用高层次语言描述系统行为，比如C/C++，工具比如赛灵思的Vivado HLS</p><p><img data-src="1.PNG" alt="1"></p><p>2、 使用基于模型的设计工具，比如赛灵思的System Generator</p><p><img data-src="2.PNG" alt="2"></p><h2 id="采用高层次综合的好处"><a href="#采用高层次综合的好处" class="headerlink" title="采用高层次综合的好处"></a>采用高层次综合的好处</h2><h3 id="对于硬件工程师而言可以提高生产率"><a href="#对于硬件工程师而言可以提高生产率" class="headerlink" title="对于硬件工程师而言可以提高生产率"></a>对于硬件工程师而言可以提高生产率</h3><p>硬件工程师通常在EDA阶段采用VHDL或者Verilog，这种硬件语言有<strong>时序</strong>和<strong>并行性</strong>这两个最为显著的特征，时序是人为设计出来的，而且在时序设计这个阶段是比较困难且耗费人力的一个过程，并行性反映了VHDL和Verilog的一个本质，这些语言所谓的硬件描述描述的是电路，每条语句都会和相应的电路对应，而在C/C++层面，更多的是关注算法本身，可以高效的把算法用C/C++描述出来，然后把转换的过程用工具来完成，这就需要用到HLS工具。</p><h3 id="对于软件工程师而言可以提高系统的性能"><a href="#对于软件工程师而言可以提高系统的性能" class="headerlink" title="对于软件工程师而言可以提高系统的性能"></a>对于软件工程师而言可以提高系统的性能</h3><p>因为以前需要采用CPU、DSP或者GPU实现的一些算法，现在都可以采用FPGA来进行实现，一方面提高了整个系统的并行性，实际上也就是提高了系统的吞吐率，另一方面对于改善功耗也是很有意义的。</p><h3 id="在C-C-层面对算法进行开发"><a href="#在C-C-层面对算法进行开发" class="headerlink" title="在C/C++层面对算法进行开发"></a>在C/C++层面对算法进行开发</h3><h3 id="在C-C-层面对算法进行验证"><a href="#在C-C-层面对算法进行验证" class="headerlink" title="在C/C++层面对算法进行验证"></a>在C/C++层面对算法进行验证</h3><p>有了HLS高层次综合工具就可以在C/C++层面进行算法的开发和验证，可以通过一些指导综合工具进行优化指导，将C/C++描述的算法更高效的转化为HDL代码（VHDL或者Verilog代码）</p><p><img data-src="3.PNG" alt="3"></p><p>特别强调的一点是在这个过程中我们不仅是用C/C++语言进行算法的开发，同样也是使用C/C++语言进行算法的验证，所以我们在描述好一个算法后一定会有相应的测试文本（测试程序）去测试我们的描述出来的算法是否可以正常工作，是否符合我们期望的要求，其实生成的HDL代码在验证的时候也会使用到C/C++写的测试程序</p><p>从这个角度而言，Vivado HLS生成的HDL代码并不是让我们去看懂的，我们不需要去把它看懂，因为通过对生成的代码进行阅读发现，HLS自动生成的代码并不具备很高的可读性，因此如果我们需要让生成的HDL代码能够高效的运行，一个是我们可以在C/C++层面上对我们的算法做更多的优化，另一个我们可以对综合工具采用一些指导方法。</p><p>生成的HDL代码我们很难对其进行优化，效果也不好。</p><h2 id="在Vivado-HLS中进行高级综合的几个阶段"><a href="#在Vivado-HLS中进行高级综合的几个阶段" class="headerlink" title="在Vivado HLS中进行高级综合的几个阶段"></a>在Vivado HLS中进行高级综合的几个阶段</h2><p>Vivado HLS的综合过程，也就是把C/C++转化成HDL代码的过程，会有以下这几个阶段：</p><p><img data-src="4.PNG" alt="4"></p><p><strong>调度（Scheduling）</strong> -&gt; <strong>控制逻辑的提取（Control Logic Extraction）</strong></p><p>这两个阶段描述的是每个时钟周期应该做的操作，同时还要描述这个操作需要几个时钟周期来完成，以及描述有些操作是否可以并行来执行；提取控制逻辑通常会生成状态机，这个在HDL代码中也能看得到</p><p><img data-src="5.PNG" alt="5"></p><p>再接下来的过程是<strong>Binding</strong>，意思就是每个操作需要用什么样的资源去实现，完成的是映射的过程。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">foo</span><span class="params">(<span class="keyword">data_t</span> x, <span class="keyword">data_t</span> a, <span class="keyword">data_t</span> b, <span class="keyword">data_t</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">data_t</span> y;</span><br><span class="line">    y = x * a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，实现的就是<code>y = x * a + b + c</code></p><p><img data-src="6.PNG" alt="6"></p><p><strong>调度（Scheduling）</strong>的过程就是在第一个时钟周期执行<code>a*x+b</code>，第二个时钟周期执行的是前一个时钟周期的结果和<code>c</code>相加</p><p><strong>Binding</strong>的过程就是描述在这个时钟周期需要什么资源，如图所示，第一个时钟周期中需要乘法器和加法器，最终映射为DSP48，在第二个时钟周期中只需要加法器，这里的加法器通过查找表实现。</p><p>这个算法本身比较简单，所以没有涉及到<strong>控制逻辑的提取（Control Logic Extraction）</strong></p><p><img data-src="7.PNG" alt="7"></p><h3 id="控制逻辑的提取（Control-Logic-Extraction）举例"><a href="#控制逻辑的提取（Control-Logic-Extraction）举例" class="headerlink" title="控制逻辑的提取（Control Logic Extraction）举例"></a>控制逻辑的提取（Control Logic Extraction）举例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">foo</span><span class="params">(<span class="keyword">data_t</span> x[<span class="number">4</span>], <span class="keyword">data_t</span> a, <span class="keyword">data_t</span> b, <span class="keyword">data_t</span> c, <span class="keyword">data_t</span> y[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">data_t</span> xi, yi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        xi = x[i];</span><br><span class="line">        yi = xi * a + b + c;</span><br><span class="line">        y[i] = yi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟上一个例子相比，<code>x</code>变成了一维数组，因此要用<code>for</code>循环</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%5C8.PNG" alt="8"></p><p>控制逻辑会形成一个状态机，比如在<code>C0</code>状态下，会执行<code>b + c</code>的操作，因为在这个过程中<code>b + c</code>的结果是固定的，不需要每次<code>for</code>循环都变化，在<code>C1</code>状态下会产生<code>xi</code>的地址和<code>yi</code>的地址，在<code>C2</code>状态会执行<code>* +</code>操作，<code>C3</code>状态会把结果写入到<code>y</code>数组，然后进行循环，循环得过程中判断<code>i</code>是否达到边界，</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%5C9.PNG" alt="9"></p><p>Vivado HLS也会给一个<strong>控制状态</strong>（上图左下），但是这个控制状态跟状态机并不是一一对应得，但是会比较接近，他们之间有紧密得关系</p><h3 id="矩阵相加的例子"><a href="#矩阵相加的例子" class="headerlink" title="矩阵相加的例子"></a>矩阵相加的例子</h3><p>算法流程图：</p><h3 id><a href="#" class="headerlink" title></a><img data-src="10.PNG" alt="10"></h3><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MatAdd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatAdd</span> <span class="params">(<span class="keyword">dat_t</span> A[ROW][COL], <span class="keyword">dat_t</span> B[ROW][COL], <span class="keyword">dat_t</span> C[ROW][COL])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">row:</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">col:</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i][j] = A[i][j] + B[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有<code>row</code>和<code>col</code>标记，后边会介绍，尤其是在对<code>for</code>循环进行优化时，这个标记是很重要的。</p><p>有了这个代码，Vivado HLS就会生成一个控制状态过程</p><p><img data-src="11.PNG" alt="11"></p><p>其实这个状态过程是可以通过流程图转化过来的，因此有了流程图以后，基本也就知道状态过程是如何进行的，也就是从算法流程图到状态机的过程是人工可以完成的，只是有的会很复杂，在这里Vivado HLS完成了这个过程。</p><ul><li>Vivado HLS的两个过程：<strong>调度（Scheduling）</strong>/ <strong>控制逻辑的提取（Control Logic Extraction）</strong>，<strong>binding</strong></li><li>算法流程图能够帮助分析Vivado HLS生成的控制状态</li><li>控制状态在Vivado HLS内部是去控制哪个操作在哪个时钟周期执行</li><li>所以他跟HDL代码生成的有限状态机并非一一对应，但是有很紧密的关系</li></ul><p><img data-src="12.PNG" alt="12"></p><p>所以从Vivado HLS工作的原理来分析，它其实是类似于我们把我们自己的算法流程图转换为有限状态机的一个过程，他是通过有限状态机控制算法的进程，因此用Vivado HLS的思想是靠谱的。</p>]]></content>
      
      
      <categories>
          
          <category> Vivado HLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vivado HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VivadoHLS的设计流程介绍</title>
      <link href="/2020/01/01/VivadoHLS%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/01/01/VivadoHLS%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="VivadoHLS的设计流程（介绍）"><a href="#VivadoHLS的设计流程（介绍）" class="headerlink" title="VivadoHLS的设计流程（介绍）"></a>VivadoHLS的设计流程（介绍）</h1><h2 id="传统的RTL设计流程："><a href="#传统的RTL设计流程：" class="headerlink" title="传统的RTL设计流程："></a>传统的RTL设计流程：</h2><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps23.jpg" alt="img"> </p><p>如果采用传统的RTL设计流程，就需要用硬件描述语言比如VHDL、Verilog或者System Verilog描述算法以及相应的Test Bench，然后执行行为级仿真（RTL Simulation），这个过程是一个迭代的过程，以验证算法的正确性，然后再执行综合（Synthesis）和实现（Implementation），在这个阶段要实现设计的收敛（Design Closure），要从Latency、Timing和Resource三个角度进行考察，最后进行系统级的全面的测试，这也是一个迭代的过程。</p><a id="more"></a><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps24.jpg" alt="img"> </p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps25.jpg" alt="img"> </p><h2 id="高层综合（HLS）的设计流程"><a href="#高层综合（HLS）的设计流程" class="headerlink" title="高层综合（HLS）的设计流程"></a>高层综合（HLS）的设计流程</h2><p>而在高层综合（HLS）的设计流程中，我们就会站在抽象度更高的C/C++级别描述我们的算法以及Test Bench，描述我们的仿真（C Simulation），这个过程也是一个迭代的过程，然后通过高级综合工具（HLS），帮助我们完成C/C++到RTL的转换，这个过程被称为C综合（C Synthesis），在这个阶段就要考虑到设计收敛，从Latency、Timing和Resource三个角度进行考察，后续流程跟传统的RTL流程一致，也就是包括RTL综合（RTL Synthesis）、实现（Implementation），也要进行系统级的全面的测试，这个过程也是一个迭代的过程。</p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps26.jpg" alt="img"> </p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps27.jpg" alt="img"> </p><p>结合Vivado HLS，可以来看一下，我们需要用C/C++描述算法以及Test Bench，同时还要准备好相应的Constraints/Directives，这就构成了Vivado HLS的设计输入，Directives并不需要手工输入完成，Vivado HLS提供了一个图形用户界面帮助我们完成这个任务，Vivado HLS还提供了一些C Library，包括Math、Video、DSP和Linear alaebra帮助我们加速C算法的描述，Vivado HLS的输出是VHDL/Verilog，但是在工程中不会直接拿这个代码去使用，Vivado HLS会帮助我们把他封装成一个IP（Intellectual Property），这样我们就可以把IP添加到Vivado的IP Catalog中使用，可以在Vivado的IP Intergrater中使用，或者在Vivado的RTL工程中通过实例化IP的方式使用，这跟Vivado提出的以IP为核心的设计理念是一致的，此外，Vivado HLS的输出结果也可以导入到sisin（误）中，以模块化的方式使用，这也是一种很常用的方式。</p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps28.jpg" alt="img"> </p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps29.jpg" alt="img"> </p><p>这个流程进一步细化，具体流程如上图所示，先准备好source code和test bench，然后添加source code，添加test bench，C的仿真，C的综合，在C综合的需要添加Directives，然后进行C/RTL的协同仿真，最后导出RTL结果。</p><p>在这个过程中特别需要强调的一点是，C Test Bench对我们整个流程而言是非常重要的文件，这里C Test Bench是一个Self-checking mode（自我检查模式），本身包含真实的结果，用于和仿真的结果作对比，以验证仿真结果是否正确，此外，C Test Bench还用于自动生成RTL Test Bench，在协同仿真（CoSimulaion）阶段，可以在输出中看到Generating RTL test bench …的输出信息，</p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps30.jpg" alt="img"> </p><p>结合Vivado HLS的菜单，再看一下流程：</p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps31.jpg" alt="img"> </p><p>结合Vivado HLS的菜单可以看一下流程：</p><p>第一步，做C仿真</p><p>第二步，做C综合</p><p>第三步，做C/RTL协同仿真</p><p>第四步，导出RTL</p><p>完成C综合之后，可以打开C综合的报告，去查看相应的性能评估，资源利用率的评估，以及接口的信息，做C/RTL协同仿真后，还可以查看RTL的仿真波形。</p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps32.jpg" alt="img"> </p><p>每一步都会生成相应的文件夹</p><p>每一步都是根据前面所讲的顺序去执行的</p><p>C Test Bench对Vivado HLS来说是至关重要的</p><p>综合报告可以帮我们分析时序、资源利用率，综合后的性能等等</p><p>波形查看器提供了一个很直观的方式帮我们查看输入输出端口之间的时序关系</p><h2 id="Vivado-HLS中的Solutions"><a href="#Vivado-HLS中的Solutions" class="headerlink" title="Vivado HLS中的Solutions"></a>Vivado HLS中的Solutions</h2><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps33.jpg" alt="img"> </p><p>解决方案：</p><p>一个工程可以有多个不同的解决方案</p><p>每一个解决方案都有他自己的directives</p><p>这些directives是用来优化C综合的</p><p>Directive可以写在source file里，也可以写在directive file里，推荐写在directive file里</p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps34.jpg" alt="img"> </p><p>这些solution之间有什么区别呢，从前边我们就可以看到，每个solution都有自己的directive，而这些directive的目的就是去优化C的综合，所以说不同的Solution对应不同的directive，以便用来查看不同的directive对C综合的效能的影响，所以Vivado HLS为我们提供了一个很方便的创建solution的按钮，帮助我们比较不同solution之间的结果</p><h2 id="波形查看器"><a href="#波形查看器" class="headerlink" title="波形查看器"></a>波形查看器</h2><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps35.jpg" alt="img"> </p><p>波形查看器可以帮助我们很方便的查看RTL的仿真结果</p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps36.jpg" alt="img"> </p><p>使用方式：</p><p>在C/RTL Simulation中选择Vivado Simulation或者Auto</p><p>Dump Trace选择port或者all</p><p>点击OK</p><p>然后就可以点开波形查看器</p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps37.jpg" alt="img"> </p><p>在波形查看器中，预先对Block-level IO、C inputs和C outputs做了分组，以便能快速的查看相应的端口和信号。</p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps38.jpg" alt="img"> </p><p>Vivado HLS支持C，C++和System C</p><p>强烈建议对每一个C综合的设计都创建相应的C Test Bench</p><p>为了达到最好的C综合的结果，应该去创建多个solution，以用来查看这些solution对C综合效能的影响</p><p>Vivado HLS提供了直观的方式来查看协同仿真（CoSimulation）的结果</p><p>Vivado HLS对于算法的开发起到了很大的加速作用</p><p>结论：好的C Coding Style + 好的 Directives = 好的、最佳的结果</p><h1 id="VIVADO-HLS设计流程（实例）"><a href="#VIVADO-HLS设计流程（实例）" class="headerlink" title="VIVADO HLS设计流程（实例）"></a>VIVADO HLS设计流程（实例）</h1><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps39.jpg" alt="img"> </p><p>设计输入包括：Test Bench、C/C++ Source Code、Directives</p><p>设计输出包括：IP可以放到IP Catalog中、DCP（就是RTL代码综合后的网表文件）、SysGen（我们可以把仿真后的结果导入到SyaGen中使用）</p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps40.jpg" alt="img"> </p><p>Test Bench设计的重要性：第一，用于验证C算法功能的正确性，第二，在C/RTL Cosimulation（C/RTL协同仿真）过程中用于生成RTL验证的Test Bench</p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps41.jpg" alt="img"> </p><p>对于VIVADO HLS，只有一个顶层函数用于综合，</p><p>函数下面的子函数也是可以被综合的</p><p>通常情况下，子函数被综合后也有相应的VHDL或者Verilog代码，而且跟C语言描述的代码结构一致，但是也有例外，比如如果子函数所需要的逻辑量很小，或者算法功能很简单，综合时就会输出一个信息，Inlining function，就会只有一个顶层的VHDL架构，但是也可以通过directive把Inline关掉。</p><p>不可以被综合的情况：动态内存分配和涉及到操作系统层面的一些操作。</p><h2 id="看一个Demo"><a href="#看一个Demo" class="headerlink" title="看一个Demo"></a>看一个Demo</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件VectorAdd.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">//the length of vector</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VectorAdd</span><span class="params">(<span class="keyword">data_t</span> A[N], <span class="keyword">data_t</span> c, <span class="keyword">data_t</span> B[N])</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"VectorAdd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VectorAdd</span><span class="params">(<span class="keyword">data_t</span> A[N], <span class="keyword">data_t</span> c, <span class="keyword">data_t</span> B[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    myloop:</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        B[i] = A[i] + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test Bench</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">data_t</span> A[N] = &#123;<span class="number">-4</span>, <span class="number">-3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">data_t</span> C = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">data_t</span> B[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">data_t</span> RefB[N] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> errcnt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    VectorAdd(A, c, B);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'-'</span>) &lt;&lt; setw(<span class="number">30</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; left &lt;&lt; <span class="string">"A"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; left &lt;&lt; <span class="string">'C'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; left &lt;&lt; <span class="string">'B'</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'-'</span>) &lt;&lt; setw(<span class="number">30</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; left &lt;&lt; A[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; left &lt;&lt; c;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">' '</span>) &lt;&lt; setw(<span class="number">10</span>) &lt;&lt; left &lt;&lt; B[i];</span><br><span class="line">        <span class="keyword">if</span>(B[i] == RefB[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; RefB[i] &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            errcnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'-'</span>) &lt;&lt; setw(<span class="number">30</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(errcnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'-'</span>) &lt;&lt; setw(<span class="number">30</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test Pass"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test Bench中最终结果，错误的个数大于0，返回1，没有错误返回0。</p><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p><img data-src="1.PNG" alt="1"></p><p>项目名字可以跟函数名字不一致，然要指定用于综合的顶层函数的名字：</p><p><img data-src="2.PNG" alt="2"></p><p>然后再加test bench：</p><p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D%5C3.PNG" alt="3"></p><p>然后创建一个Solution，选板子，Uncertainty先不用管：</p><p><img data-src="4.PNG" alt="4"></p><p>这就创建好了一个Vivado HLS工程</p><p><img data-src="5.PNG" alt="5"></p><p>执行<code>C</code>的仿真：</p><p><img data-src="6.PNG" alt="6"></p><p>仿真结束会给出仿真结果，可以看到Test Pass，没有问题。</p><p><img data-src="7.PNG" alt="7"></p><p>然后执行C综合，综合结束之后会自动打开综合报告，切换到Outline，可以看相应的Performance，也可以看Utilization：</p><p><img data-src="8.PNG" alt="8"></p><p>在左边栏Solution文件夹的syn文件夹中有相应的report文件夹和verilog和vhdl文件夹，代码可读性不好。</p><p><img data-src="9.PNG" alt="9"></p><p>接下来选择C/RTL的协同仿真：</p><p><img data-src="10.PNG" alt="10"></p><p>然后会显示协同仿真的结果</p><p><img data-src="11.PNG" alt="11"></p><p>然后查看波形图</p><p><img data-src="12.PNG" alt="12"></p><p>重新创建一个Solution，加directive，%号开头表示directive放在独立的文件里，#开头表示directive放在源代码文件里</p><p><img data-src="13.PNG" alt="13"></p><p>综合完成后可以跟第一个solution综合的结果进行对比，这里只是做了pipeline，就可以看到latency和Interval都减小了</p><p><img data-src="14.PNG" alt="14"></p><p>Directive：</p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps42.jpg" alt="img"> </p><p>可以写在单独的Directive文件里，此时可以在directive的面板下看到每个directive前面都有个“%”百分号</p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps43.jpg" alt="img"> </p><p>也可以写在C Source file里面，此时directive面板里面会以“#”＃号标记。</p><p>两种方式对比：</p><p>第一，如果是在单独的directive文件中，每个directive是一个tcl命令：</p><p>优点：每个solution都有自己独立的directive；</p><p>如果这个solution需要重新综合，只有这个solution下面的directive会起到作用；</p><p>缺点：如果需要把C source file给第三方工具，则directive的tcl文件也要被包含在其中；</p><p>第二，directive在C source file中以pragma形式：</p><p>优点：给到第三方工具时，只用source file就能重现结果； 缺点：如果solution需要重新综合，由于directive写在source file里，这时候所有的directive都会被重新执行。</p><p><img data-src="file:///C:%5CUsers%5Cylyang%5CAppData%5CLocal%5CTemp%5Cksohtml8288%5Cwps44.jpg" alt="img"> </p><p>第一，最好在源代码中为每一个for循环创建一个标签，以便于设置directive；</p><p>第二，推荐在directive文件中存储directives；</p><p>第三，关于Test Bench的返回值，如果仿真通过（结果正确）就返回0，如果仿真不通过（结果错误）就返回1；</p><p>第四，通常情况下，生成的RTL代码的层次和原始的C函数的层次是一致的。 </p>]]></content>
      
      
      <categories>
          
          <category> Vivado HLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vivado HLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络之Http和Https</title>
      <link href="/2019/11/05/Http%E5%92%8CHttps/"/>
      <url>/2019/11/05/Http%E5%92%8CHttps/</url>
      
        <content type="html"><![CDATA[<h1 id="Http和Https"><a href="#Http和Https" class="headerlink" title="Http和Https"></a>Http和Https</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http是一种无状态协议。无状态是指客户机和服务器之间不需要建立持久连接，这意味着当一个客户端向服务器发出请求，然后服务器返回响应（response），连接就被关闭了，在服务器端不保留连接的有关信息，HTTP遵循请求/应答模型。客户机向服务器发送请求，服务器处理请求并返回适当的应答。所有HTTP连接都构成一套请求和应答。</p><a id="more"></a><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>HTTPS是以安全为目标的HTTP通道，简单将就是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。其所用的端口是443，过程大致如下：</p><h3 id="获取连接证书"><a href="#获取连接证书" class="headerlink" title="获取连接证书"></a>获取连接证书</h3><p>SSL客户端通过TCP和服务器建立连接后（443端口），并且在一般的TCP连接协商过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共密钥）</p><h3 id="证书验证"><a href="#证书验证" class="headerlink" title="证书验证"></a>证书验证</h3><p>客户端在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共密钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名</p><h3 id="数据加密和传输"><a href="#数据加密和传输" class="headerlink" title="数据加密和传输"></a>数据加密和传输</h3><p>如果确认证书有效，那么生成对称密钥并使用服务器的公共密钥进行加密。然后发送给服务器，服务器使用它的密钥进行解密，这样两台计算机可以开始进行对称加密进行通信。</p><p><img data-src="image-20200413085448943.png" alt="image"></p><p>对称加密：是指加密和解密用的都是同一个密钥，目前微信小程序采用的就是这个加密方式</p><h3 id="对称加密存在的问题"><a href="#对称加密存在的问题" class="headerlink" title="对称加密存在的问题"></a>对称加密存在的问题</h3><p>首先我们知道对称加密是指：加密和解密都使用的同一个密钥，这种方式存在的最大的问题就是密钥发送问题，即如果安全的将密钥发送给对方。</p><h4 id="为什么叫对称加密？"><a href="#为什么叫对称加密？" class="headerlink" title="为什么叫对称加密？"></a>为什么叫对称加密？</h4><p>一方通过密钥将信息加密后，把密文传给另一个方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。他们之间的关系如下</p><blockquote><p>明文 -&gt; 密钥 -&gt; 密文</p></blockquote><p>但是从上面的图我们可以看出，我们在进行加密后，首先需要将密钥发送给服务器，那么这个过程就可能存在危险的</p><p><img data-src="image-20200413091318404.png" alt="image"></p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>上面提到的是对称加密，其实还有一种是非对称加密，非对称加密是通过两个密钥（公钥 - 私钥）来实现对数据的加密和解密的，公钥用于加密，私钥用于解密。</p><p><img data-src="image-20200413085937800.png" alt="image"></p><p>过程如下：</p><p>首先服务器会颁发一个公钥放在网络中，同时它自己还有一份私钥，然后客户端可以直接获取到对应的公钥</p><p>然后将客户端的数据进行公钥的加密，加密后传输的服务器中，服务器在进行私钥解密，得到最终的数据</p><p><img data-src="image-20200413102124070.png" alt="image"></p><p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性，但是和对称加密比起来，它非常慢，所以我们还是要用对称加密来传送消息，但是对称加密使用的密钥我们通过非对称加密的方式发送出去。这个结果就变成了：</p><p><img data-src="image-20200413102622594.png" alt="image"></p><p>但是我们需要注意的是，此时交换的两个公钥不一定正确，因为可能会被中间人截获，同时掉包</p><p>例如：中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥Key1之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥Key3发送给小灰。</p><p><img data-src="image-20200413102718466.png" alt="image"></p><p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了Key3的加密，获得Key2，然后再用当初小红发来的Key1重新加密，再发给小红</p><p><img data-src="image-20200413102738635.png" alt="image"></p><h3 id="证书机制"><a href="#证书机制" class="headerlink" title="证书机制"></a>证书机制</h3><p>这个时候我们需要做的就是从指定的机构出获取公钥，而不是任由其在网络传输</p><ul><li>作为服务器端的小红，首先先把自己的公钥给证书颁发机构，向证书颁发机构申请证书</li><li>证书颁发机构自己也有一堆公钥和私钥。机构利用自己的私钥来解密Key1，通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给服务端的小红。</li><li>当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</li><li>小灰收到证书以后，要做的第一件事就是验证证书的真伪，需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥，所以小灰只需要知道是哪个机构颁发的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</li></ul><p><img data-src="image-20200413103251089.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Http </tag>
            
            <tag> Https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络之TCP三次握手和四次挥手</title>
      <link href="/2019/11/01/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2019/11/01/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>为什么需要握手：握手的作用就是为了同步一些信息，比如最大滑动窗口</p><p>TCP：是一个可靠的连接，也就是客户端和服务器双方必须感知对方的存在，也就是需要经历一个建立连接的过程</p><a id="more"></a><p>用三次握手建立TCP连接，连接有三个阶段</p><ul><li>建立连接</li><li>数据传输</li><li>连接释放</li></ul><p>连接的管理就是使连接的建立和释放都能正常地进行，连接阶段过程中要解决以下三个问题</p><ul><li>要使每一方都能确知对方的存在</li><li>要允许双方协商一些参数</li><li>能够对运输实体分配资源</li></ul><h3 id="TCP连接建立过程"><a href="#TCP连接建立过程" class="headerlink" title="TCP连接建立过程"></a>TCP连接建立过程</h3><p>TCP建立连接的过程：被称为握手</p><p><img data-src="image-20200412155010409.png" alt="image"></p><p>① 握手过程其实是发送的TCP报文，在这里面有两个字段，SYN 和 seq</p><ul><li>SYN = 1：表示该报文不能携带数据，但是需要消耗一个SEQ（序号），可以想象成我们对消息编号</li><li>seq：TCP的每个字节发送的时候，都有一个序号，主要是为了保证可靠性，比如当我服务器通过TCP报文得到了有N个字节需要接受，但是最后只接受到了N-1个，我们通过序号就知道哪个没有被接收到。</li></ul><p>② 当服务器接受到我们的握手请求时，会回复一个确认报文</p><ul><li>SYN：表示不携带数据，同时消耗一个SEQ = y（这里的y是任意数字，可以是1,2,3,4）</li><li>ACK：=1 表示这是一条确定报文</li><li>ack：x+1，其中x是刚刚客户端发送过来的</li></ul><p>③ 当客户端收到确认报文的时候，客户端需要对这个确认报文进行回复</p><ul><li>ACK：=1，表示这是一条确认报文</li><li>seq：= x +1，</li><li>ack：= y+1</li></ul><p>经过了这三次握手，两者就进入了连接状态</p><h3 id="通俗的理解"><a href="#通俗的理解" class="headerlink" title="通俗的理解"></a>通俗的理解</h3><ul><li>客户端：服务器，我们可以建立连接么？ -&gt;  SYN= 1 ， seq = x</li><li>服务器：可以啊，我们建立连接吧 ！  -&gt; ACK =1, SYN = 1, seq = y, ack  = x+1</li><li>客户端：收到，建立连接吧！  -&gt;  ACK = 1,  SYN = 1，seq = x + 1， ack = y + 1</li></ul><p>然后建立TCP连接</p><p>中国机长版三次握手</p><p><img data-src="image-20200412163516738.png" alt="image"></p><h3 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h3><h4 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h4><p>四次连接有点多余，第三次的时候，我们已经互相进行了连接确认</p><p>但是因为我们无法保证百分百的可靠性</p><h4 id="两次握手："><a href="#两次握手：" class="headerlink" title="两次握手："></a>两次握手：</h4><p>客户端知道服务器有接收 和 发送的能力，服务器不知道客户端有没有接收数据的能力，因为通过第一次握手，已经知道了客户端能够发送数据，但是能不能接收数据，还是不清楚，因此这个TCP连接是不可靠的。</p><p>为什么不能两次握手就建立连接</p><p>因为超时重传机制的存在</p><p>但客户端发送第一次握手的时候，可能会经历网络拥塞，然后客户端会以为这个连接已经丢失，然后会重新发送一个请求连接的信息到服务器，这次发送的消息很快被服务器接受，然后服务器建立连接就开始建立连接。但是当第一次发送的请求经过一段时间的阻塞后，成功到达服务器，然后服务器又连接连接，而此时客户端是不会理会这次请求的建立，所以服务器一直在等待客户端数据的发送。</p><p><img data-src="image-20200412162156748.png" alt="image"></p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>当客户端与服务器在规定的时间内没有得到应答</p><p>会发送报文进行探测，假设没有应答，那么就会关闭连接</p><p><img data-src="image-20200412163756161.png" alt="image"></p><p>下面是四次挥手的过程</p><p><img data-src="image-20200412165407014.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot之时区问题</title>
      <link href="/2019/10/25/SpringBoot%E4%B9%8B%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2019/10/25/SpringBoot%E4%B9%8B%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot解决时区问题"><a href="#SpringBoot解决时区问题" class="headerlink" title="SpringBoot解决时区问题"></a>SpringBoot解决时区问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发过程中发现SpringBoot存在时区不正确的问题，但是我们查看数据库的和服务器的时间能够发现，时间显示是正常的。</p><a id="more"></a><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>1、我们设置mysql连接，在连接语句后面加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br></pre></td></tr></table></figure><p>2、然后修改jackson配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#spring</span><br><span class="line">spring:</span><br><span class="line">  jackson:</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ss</span><br><span class="line">    time-zone: Asia&#x2F;Shanghai</span><br></pre></td></tr></table></figure><p>3、修改启动类</p><p>在启动类中，添加这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 设置时区</span><br><span class="line"> *&#x2F;</span><br><span class="line">@PostConstruct</span><br><span class="line">void setDefaultTimezone() &#123;</span><br><span class="line">    TimeZone.setDefault(TimeZone.getTimeZone(&quot;Asia&#x2F;Shanghai&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在启动类的main方法中，设置时区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    TimeZone.setDefault(TimeZone.getTimeZone(&quot;Asia&#x2F;Shanghai&quot;));</span><br><span class="line">    SpringApplication.run(AdminApplication.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot之使用DevTools实现SpringBoot项目热部署</title>
      <link href="/2019/10/19/SpringBoot%E4%B9%8B%E4%BD%BF%E7%94%A8DevTools%E5%AE%9E%E7%8E%B0SpringBoot%E9%A1%B9%E7%9B%AE%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/10/19/SpringBoot%E4%B9%8B%E4%BD%BF%E7%94%A8DevTools%E5%AE%9E%E7%8E%B0SpringBoot%E9%A1%B9%E7%9B%AE%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot之使用DevTools实现SpringBoot项目热部署"><a href="#SpringBoot之使用DevTools实现SpringBoot项目热部署" class="headerlink" title="SpringBoot之使用DevTools实现SpringBoot项目热部署"></a>SpringBoot之使用DevTools实现SpringBoot项目热部署</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在开发的时候，每次改动代码都需要启动项目，因为有的时候改动的服务比较多，所以重启的次数也就比较多了，想着每次重启等待也挺麻烦的，就打算使用DevTools工具实现项目的热部署</p><a id="more"></a><h2 id="热部署是什么"><a href="#热部署是什么" class="headerlink" title="热部署是什么"></a>热部署是什么</h2><p>大家都知道在项目开发过程中，常常会改动页面数据或者修改数据结构，为了显示改动效果，往往需要重启应用查看改变效果，其实就是重新编译生成了新的Class文件，这个文件里记录着和代码等对应的各种信息，然后Class文件将被虚拟机的ClassLoader加载。</p><p>而热部署正是利用了这个特点，它监听到如果有Class文件改动了，就会创建一个新的ClaassLoader进行加载该文件，经过一系列的过程，最终将结果呈现在我们眼前</p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>Java中的类经过编译器可以把代码编译为存储字节码的Class文件，该Class文件存储了各种信息，最终要加载到虚拟机中运行使用。类加载机制（摘自《深入理解 Java 虚拟机》）虚拟机把描述类的数据从Class文件加载到内存中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="DevTools的配置"><a href="#DevTools的配置" class="headerlink" title="DevTools的配置"></a>DevTools的配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#热部署生效</span><br><span class="line">spring.devtools.restart.enabled: true</span><br><span class="line"></span><br><span class="line">#设置重启的目录</span><br><span class="line">spring.devtools.restart.additional-paths: src/main/java</span><br><span class="line"></span><br><span class="line">#classpath目录下的WEB-INF文件夹内容修改不重启</span><br><span class="line">spring.devtools.restart.exclude: WEB-INF/**</span><br></pre></td></tr></table></figure><h2 id="IDEA需要的配置"><a href="#IDEA需要的配置" class="headerlink" title="IDEA需要的配置"></a>IDEA需要的配置</h2><p>当我们修改了Java类后，IDEA默认是不自动编译的，而spring-boot-devtools又是监测classpath下的文件发生变化才会重启应用，所以需要设置IDEA的自动编译：</p><ul><li><p>File-Settings-Compiler-Build Project automatically</p><p><img data-src="image-20200120095021685.png" alt="image"></p></li><li><p>ctrl + shift + alt + /,选择Registry，勾上 compiler.automake.allow.when.app.running</p></li></ul><p><img data-src="image-20200120095107686.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> DevTools </tag>
            
            <tag> 项目热部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot之Bean的生命周期</title>
      <link href="/2019/10/18/SpringBoot%E4%B9%8BBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/10/18/SpringBoot%E4%B9%8BBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我们没有使用Spring框架之前，创建对象一般都是使用new关键字进行创建，当然除了new关键字外，还有</p><ul><li>运用反射手段，使用Class类的newInstance方法 或者 Constructor类中的newInstance方法</li><li>使用clone方法</li><li>使用反序列化（ObjectInputStream）</li></ul><a id="more"></a><p>一旦对象不再被使用的时候，将有可能被JVM垃圾回收器进行回收。</p><p>但是在Spring通过IOC容器进行管理之后，Bean 的生命周期就变得更加复杂了，下图展示了Bean的构造过程</p><p><img data-src="image-20200614155732584.png" alt="image"></p><h2 id="Bean的生命周期-1"><a href="#Bean的生命周期-1" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>我们对上图的每个步骤进行文字说明</p><ul><li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</li><li>Bean实例化后对将Bean的引入和值注入到Bean的属性中</li><li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</li><li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li><li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</li><li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</li><li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</li><li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li><li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</li></ul><h2 id="接口方法的分类"><a href="#接口方法的分类" class="headerlink" title="接口方法的分类"></a>接口方法的分类</h2><p> Bean的完整生命周期经历了各种方法的调用，这些方法可以分类一下三类</p><h3 id="Bean自身的方法："><a href="#Bean自身的方法：" class="headerlink" title="Bean自身的方法："></a>Bean自身的方法：</h3><p>这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</bean></p><h3 id="Bean级生命周期的方法"><a href="#Bean级生命周期的方法" class="headerlink" title="Bean级生命周期的方法"></a>Bean级生命周期的方法</h3><p>这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</p><h3 id="容器级生命周期的方法"><a href="#容器级生命周期的方法" class="headerlink" title="容器级生命周期的方法"></a>容器级生命周期的方法</h3><p>这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</p><h3 id="工程后处理器接口方法"><a href="#工程后处理器接口方法" class="headerlink" title="工程后处理器接口方法"></a>工程后处理器接口方法</h3><p>这个包括了AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer等等非常有用的工厂后处理器　　接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</p><h2 id="DEMO举例"><a href="#DEMO举例" class="headerlink" title="DEMO举例"></a>DEMO举例</h2><p>我们用一个简单的Spring Bean来演示一下Spring Bean的生命周期。</p><p>首先是一个简单的Spring Bean，调用Bean自身的方法和Bean级生命周期接口方法，为了方便演示，它实现了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这4个接口，同时有2个方法，对应配置文件中<bean>的init-method和destroy-method。如下：</bean></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package springBeanTest;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.factory.BeanFactory;</span><br><span class="line">import org.springframework.beans.factory.BeanFactoryAware;</span><br><span class="line">import org.springframework.beans.factory.BeanNameAware;</span><br><span class="line">import org.springframework.beans.factory.DisposableBean;</span><br><span class="line">import org.springframework.beans.factory.InitializingBean;</span><br><span class="line"></span><br><span class="line">public class Person implements BeanFactoryAware, BeanNameAware,</span><br><span class="line">        InitializingBean, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String address;</span><br><span class="line">    private int phone;</span><br><span class="line"></span><br><span class="line">    private BeanFactory beanFactory;</span><br><span class="line">    private String beanName;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">        System.out.println(&quot;【构造器】调用Person的构造器实例化&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        System.out.println(&quot;【注入属性】注入属性name&quot;);</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(String address) &#123;</span><br><span class="line">        System.out.println(&quot;【注入属性】注入属性address&quot;);</span><br><span class="line">        this.address &#x3D; address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getPhone() &#123;</span><br><span class="line">        return phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPhone(int phone) &#123;</span><br><span class="line">        System.out.println(&quot;【注入属性】注入属性phone&quot;);</span><br><span class="line">        this.phone &#x3D; phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person [address&#x3D;&quot; + address + &quot;, name&#x3D;&quot; + name + &quot;, phone&#x3D;&quot;</span><br><span class="line">                + phone + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这是BeanFactoryAware接口方法</span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanFactory(BeanFactory arg0) throws BeansException &#123;</span><br><span class="line">        System.out</span><br><span class="line">                .println(&quot;【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()&quot;);</span><br><span class="line">        this.beanFactory &#x3D; arg0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这是BeanNameAware接口方法</span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanName(String arg0) &#123;</span><br><span class="line">        System.out.println(&quot;【BeanNameAware接口】调用BeanNameAware.setBeanName()&quot;);</span><br><span class="line">        this.beanName &#x3D; arg0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这是InitializingBean接口方法</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out</span><br><span class="line">                .println(&quot;【InitializingBean接口】调用InitializingBean.afterPropertiesSet()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这是DiposibleBean接口方法</span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;【DiposibleBean接口】调用DiposibleBean.destory()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 通过&lt;bean&gt;的init-method属性指定的初始化方法</span><br><span class="line">    public void myInit() &#123;</span><br><span class="line">        System.out.println(&quot;【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 通过&lt;bean&gt;的destroy-method属性指定的初始化方法</span><br><span class="line">    public void myDestory() &#123;</span><br><span class="line">        System.out.println(&quot;【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是演示BeanPostProcessor接口的方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package springBeanTest;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line">public class MyBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    public MyBeanPostProcessor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        System.out.println(&quot;这是BeanPostProcessor实现类构造器！！&quot;);</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated constructor stub</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object arg0, String arg1)</span><br><span class="line">            throws BeansException &#123;</span><br><span class="line">        System.out</span><br><span class="line">        .println(&quot;BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！&quot;);</span><br><span class="line">        return arg0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(Object arg0, String arg1)</span><br><span class="line">            throws BeansException &#123;</span><br><span class="line">        System.out</span><br><span class="line">        .println(&quot;BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！&quot;);</span><br><span class="line">        return arg0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，BeanPostProcessor接口包括2个方法postProcessAfterInitialization和postProcessBeforeInitialization，这两个方法的第一个参数都是要处理的Bean对象，第二个参数都是Bean的name。返回值也都是要处理的Bean对象。这里要注意。</p><p>InstantiationAwareBeanPostProcessor 接口本质是BeanPostProcessor的子接口，一般我们继承Spring为其提供的适配器类InstantiationAwareBeanPostProcessor Adapter来使用它，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package springBeanTest;</span><br><span class="line"></span><br><span class="line">import java.beans.PropertyDescriptor;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.PropertyValues;</span><br><span class="line">import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;</span><br><span class="line"></span><br><span class="line">public class MyInstantiationAwareBeanPostProcessor extends</span><br><span class="line">        InstantiationAwareBeanPostProcessorAdapter &#123;</span><br><span class="line"></span><br><span class="line">    public MyInstantiationAwareBeanPostProcessor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        System.out</span><br><span class="line">                .println(&quot;这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 接口方法、实例化Bean之前调用</span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInstantiation(Class beanClass,</span><br><span class="line">            String beanName) throws BeansException &#123;</span><br><span class="line">        System.out</span><br><span class="line">                .println(&quot;InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 接口方法、实例化Bean之后调用</span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName)</span><br><span class="line">            throws BeansException &#123;</span><br><span class="line">        System.out</span><br><span class="line">                .println(&quot;InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 接口方法、设置某个属性时调用</span><br><span class="line">    @Override</span><br><span class="line">    public PropertyValues postProcessPropertyValues(PropertyValues pvs,</span><br><span class="line">            PropertyDescriptor[] pds, Object bean, String beanName)</span><br><span class="line">            throws BeansException &#123;</span><br><span class="line">        System.out</span><br><span class="line">                .println(&quot;InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法&quot;);</span><br><span class="line">        return pvs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架总结</title>
      <link href="/2019/10/17/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/17/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1）说说常见的集合有哪些吧？"><a href="#1）说说常见的集合有哪些吧？" class="headerlink" title="1）说说常见的集合有哪些吧？"></a><strong>1）说说常见的集合有哪些吧？</strong></h2><p>答：Map接口和Collection接口是所有集合框架的父接口：</p><ol><li><p>Collection接口的子接口包括：Set接口和List接口</p></li><li><p>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</p></li></ol><a id="more"></a><ol start="3"><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li><li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li></ol><h2 id="2）HashMap与HashTable的区别？"><a href="#2）HashMap与HashTable的区别？" class="headerlink" title="2）HashMap与HashTable的区别？"></a><strong>2）HashMap与HashTable的区别？</strong></h2><p>答：</p><ol><li>HashMap没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的；</li><li>HashMap允许K/V都为null；后者K/V都不允许为null；</li><li>HashMap继承自AbstractMap类；而Hashtable继承自Dictionary类；</li></ol><h2 id="3）HashMap的put方法的具体流程？"><a href="#3）HashMap的put方法的具体流程？" class="headerlink" title="3）HashMap的put方法的具体流程？"></a>3）HashMap的put方法的具体流程？</h2><p>答：下面先来分析一下源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 1.如果table为空或者长度为0，即没有元素，那么使用resize()方法扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 2.计算插入存储的数组索引i，此处计算方法同 1.7 中的indexFor()方法</span></span><br><span class="line">    <span class="comment">// 如果数组为空，即不存在Hash冲突，则直接插入数组</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 3.插入时，如果发生Hash冲突，则依次往下判断</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        HashMap.Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// a.判断table[i]的元素的key是否与需要插入的key一样，若相同则直接用新的value覆盖掉旧的value</span></span><br><span class="line">        <span class="comment">// 判断原则equals() - 所以需要当key的对象重写该方法</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// b.继续判断：需要插入的数据结构是红黑树还是链表</span></span><br><span class="line">        <span class="comment">// 如果是红黑树，则直接在树中插入 or 更新键值对</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> HashMap.TreeNode)</span><br><span class="line">            e = ((HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 如果是链表，则在链表中插入 or 更新键值对</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// i .遍历table[i]，判断key是否已存在：采用equals对比当前遍历结点的key与需要插入数据的key</span></span><br><span class="line">            <span class="comment">//    如果存在相同的，则直接覆盖</span></span><br><span class="line">            <span class="comment">// ii.遍历完毕后任务发现上述情况，则直接在链表尾部插入数据</span></span><br><span class="line">            <span class="comment">//    插入完成后判断链表长度是否 &gt; 8：若是，则把链表转换成红黑树</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于i 情况的后续操作：发现key已存在，直接用新value覆盖旧value&amp;返回旧value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 插入成功后，判断实际存在的键值对数量size &gt; 最大容量</span></span><br><span class="line">    <span class="comment">// 如果大于则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入成功时会调用的方法（默认实现为空）</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图片简单总结为：</p><p><img data-src="https://upload-images.jianshu.io/upload_images/7896890-cf5aa3b08dd9684f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><h2 id="4）HashMap的扩容操作是怎么实现的？"><a href="#4）HashMap的扩容操作是怎么实现的？" class="headerlink" title="4）HashMap的扩容操作是怎么实现的？"></a>4）HashMap的扩容操作是怎么实现的？</h2><p>答：通过分析源码我们知道了HashMap通过<code>resize()</code>方法进行扩容或者初始化的操作，下面是对源码进行的一些简单分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该函数有2中使用情况：1.初始化哈希表；2.当前数组容量过小，需要扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;<span class="comment">// 扩容前的数组（当前数组）</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">// 扩容前的数组容量（数组长度）</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;<span class="comment">// 扩容前数组的阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 针对情况2：若扩容前的数组容量超过最大值，则不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 针对情况2：若没有超过最大值，就扩容为原来的2倍（左移1位）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对情况1：初始化哈希表（采用指定或者使用默认值的方式）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每一个bucket都移动到新的bucket中去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5）HashMap是怎么解决哈希冲突的？"><a href="#5）HashMap是怎么解决哈希冲突的？" class="headerlink" title="5）HashMap是怎么解决哈希冲突的？"></a>5）HashMap是怎么解决哈希冲突的？</h2><p>答：在解决这个问题之前，我们首先需要知道<strong>什么是哈希冲突</strong>，而在了解哈希冲突之前我们还要知道<strong>什么是哈希</strong>才行；</p><h3 id="什么是哈希？"><a href="#什么是哈希？" class="headerlink" title="什么是哈希？"></a>什么是哈希？</h3><p><strong>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；</strong>这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。<strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</strong></p><p>所有散列函数都有如下一个基本特性：<strong>根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。</strong></p><h3 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h3><p><strong>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</strong></p><h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。<strong>数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；</strong>所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<strong>链地址法</strong>的方式可以解决哈希冲突：</p><p><img data-src="https://upload-images.jianshu.io/upload_images/7896890-c66a4bd8907f49f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/861/format/webp" alt="img"></p><p>这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下，<strong>但相比于hashCode返回的int类型，我们HashMap初始的容量大小<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，</strong>所以我们还需要对hashCode作一定的优化</p><h3 id="hash-函数"><a href="#hash-函数" class="headerlink" title="hash()函数"></a>hash()函数</h3><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于<strong>参与运算的只有hashCode的低位</strong>，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的hash()函数如下：</p><p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</strong></p><h3 id="JDK1-8新增红黑树"><a href="#JDK1-8新增红黑树" class="headerlink" title="JDK1.8新增红黑树"></a>JDK1.8新增红黑树</h3><p><img data-src="https://upload-images.jianshu.io/upload_images/7896890-798f1387e3f8de9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/970/format/webp" alt="img"></p><p>通过上面的<strong>链地址法（使用散列表）</strong>和<strong>扰动函数</strong>我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p><p><strong>1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据；</strong><br> <strong>2. 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</strong><br> <strong>3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</strong></p><h2 id="6）HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#6）HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="6）HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>6）HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h2><p>答：<code>hashCode()</code>方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过<code>hashCode()</code>计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p><p><strong>面试官：那怎么解决呢？</strong></p><p>答：</p><ol><li>HashMap自己实现了自己的<code>hash()</code>方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li><li>在保证数组长度为2的幂次方的时候，使用<code>hash()</code>运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li></ol><p><strong>面试官：为什么数组长度要保证为2的幂次方呢？</strong></p><p>答：</p><ol><li>只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，即实现了key的定位，2的幂次方也可以减少冲突次数，提高HashMap的查询效率；</li><li>如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。</li></ol><p><strong>面试官：那为什么是两次扰动呢？</strong></p><p>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p><hr><h2 id="7）HashMap在JDK1-7和JDK1-8中有哪些不同？"><a href="#7）HashMap在JDK1-7和JDK1-8中有哪些不同？" class="headerlink" title="7）HashMap在JDK1.7和JDK1.8中有哪些不同？"></a>7）HashMap在JDK1.7和JDK1.8中有哪些不同？</h2><p>答：</p><table><thead><tr><th>不同</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>存储结构</td><td>数组 + 链表</td><td>数组 + 链表 + 红黑树</td></tr><tr><td>初始化方式</td><td>单独函数：<code>inflateTable()</code></td><td>直接集成到了扩容函数<code>resize()</code>中</td></tr><tr><td>hash值计算方式</td><td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td><td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td></tr><tr><td>存放数据的规则</td><td>无冲突时，存放数组；冲突时，存放链表</td><td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td></tr><tr><td>插入数据方式</td><td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td><td>尾插法（直接插入到链表尾部/红黑树）</td></tr><tr><td>扩容后存储位置的计算方式</td><td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td><td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td></tr></tbody></table><h2 id="8）为什么HashMap中String、Integer这样的包装类适合作为K？"><a href="#8）为什么HashMap中String、Integer这样的包装类适合作为K？" class="headerlink" title="8）为什么HashMap中String、Integer这样的包装类适合作为K？"></a>8）为什么HashMap中String、Integer这样的包装类适合作为K？</h2><p>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p><ol><li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li><li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li></ol><p><strong>面试官：如果我想要让自己的Object作为K应该怎么办呢？</strong></p><p>答：重写<code>hashCode()</code>和<code>equals()</code>方法</p><ol><li><strong>重写<code>hashCode()</code>是因为需要计算存储数据的存储位置</strong>，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li><li><strong>重写<code>equals()</code>方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性</strong>；</li></ol><h2 id="9）ConcurrentHashMap和Hashtable的区别？"><a href="#9）ConcurrentHashMap和Hashtable的区别？" class="headerlink" title="9）ConcurrentHashMap和Hashtable的区别？"></a>9）ConcurrentHashMap和Hashtable的区别？</h2><p>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p><p><strong>面试官：ConcurrentHashMap的具体实现知道吗？</strong></p><p>答：<strong>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现</strong>，结构如下：</p><p><img data-src="https://upload-images.jianshu.io/upload_images/7896890-645836e722c2a9f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/767/format/webp" alt="img"></p><ol><li>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li><li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li></ol><p>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，结构如下：</p><p><img data-src="https://upload-images.jianshu.io/upload_images/7896890-ec8560395e25547a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/768/format/webp" alt="img"></p><p>插入元素过程（建议去看看源码）：</p><ol><li>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    binCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">        K ek;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((ek = e.key) == key ||</span><br><span class="line">             (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">            oldVal = e.val;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;K,V&gt; pred = e;</span><br><span class="line">        <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p></li><li><p>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</p></li></ol><h2 id="10）Java集合的快速失败机制-“fail-fast”？"><a href="#10）Java集合的快速失败机制-“fail-fast”？" class="headerlink" title="10）Java集合的快速失败机制 “fail-fast”？"></a>10）Java集合的快速失败机制 “fail-fast”？</h2><p>答：</p><p><strong>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</strong></p><p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p><p><strong>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</strong></p><p><strong>解决办法：</strong></p><p><strong>1. 在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</strong></p><p><strong>2. 使用CopyOnWriteArrayList来替换ArrayList</strong></p><h2 id="11）ArrayList-和-Vector-的区别？"><a href="#11）ArrayList-和-Vector-的区别？" class="headerlink" title="11）ArrayList 和 Vector 的区别？"></a>11）ArrayList 和 Vector 的区别？</h2><p>答：</p><p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引来取出某个元素，并且其中的数据是允许重复的，这是与 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。</p><p>ArrayList 与 Vector 的区别主要包括两个方面：</p><ol><li>同步性：<br>Vector 是线程安全的，也就是说它的方法之间是线程同步（加了synchronized 关键字）的，而 ArrayList 是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全的问题，所以效率会高一些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</li><li>数据增长：<br>ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个人超过了容量时，就需要增加 ArrayList 和 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要去的一定的平衡。Vector 在数据满时（加载因子1）增长为原来的两倍（扩容增量：原容量的 2 倍），而 ArrayList 在数据量达到容量的一半时（加载因子 0.5）增长为原容量的 (0.5 倍 + 1) 个空间。</li></ol><hr><h2 id="12）ArrayList和LinkedList的区别？"><a href="#12）ArrayList和LinkedList的区别？" class="headerlink" title="12）ArrayList和LinkedList的区别？"></a>12）ArrayList和LinkedList的区别？</h2><p>答：</p><ol><li>LinkedList 实现了 List 和 Deque 接口，一般称为双向链表；ArrayList 实现了 List 接口，动态数组；</li><li>LinkedList 在插入和删除数据时效率更高，ArrayList 在查找某个 index 的数据时效率更高；</li><li>LinkedList 比 ArrayList 需要更多的内存；</li></ol><p><strong>面试官：Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？</strong></p><p>答：它们的区别是：</p><ol><li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li><li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li><li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</li></ol><p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p><hr><h2 id="13）HashSet是如何保证数据不可重复的？"><a href="#13）HashSet是如何保证数据不可重复的？" class="headerlink" title="13）HashSet是如何保证数据不可重复的？"></a>13）HashSet是如何保证数据不可重复的？</h2><p>答：HashSet的底层其实就是HashMap，只不过我们<strong>HashSet是实现了Set接口并且把数据作为K值，而V值一直使用一个相同的虚值来保存</strong>，我们可以看到源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;<span class="comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于HashMap的K值本身就不允许重复，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V，那么在HashSet中执行这一句话始终会返回一个false，导致插入失败，这样就保证了数据的不可重复性；</p><hr><h2 id="14）BlockingQueue是什么？"><a href="#14）BlockingQueue是什么？" class="headerlink" title="14）BlockingQueue是什么？"></a>14）BlockingQueue是什么？</h2><p>答：</p><p>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis常见面试题</title>
      <link href="/2019/10/16/MyBatis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/10/16/MyBatis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="1、-和-的区别是什么？"><a href="#1、-和-的区别是什么？" class="headerlink" title="1、#{}和${}的区别是什么？"></a>1、#{}和${}的区别是什么？</h4><p>答：${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，比如ps.setInt(0, parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。</p><a id="more"></a><h4 id="2、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#2、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="2、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>2、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h4><p>答：还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。</selectKey></include></sql></selectKey></include></sql></parameterMap></resultMap></p><h4 id="3、最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#3、最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="3、最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a>3、最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h4><p>答：Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。</delete></update></insert></select></p><p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p><p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p><h4 id="4、Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#4、Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="4、Mybatis是如何进行分页的？分页插件的原理是什么？"></a>4、Mybatis是如何进行分页的？分页插件的原理是什么？</h4><p>答：Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><p>举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10</p><h4 id="5、简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#5、简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="5、简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>5、简述Mybatis的插件运行原理，以及如何编写一个插件。</h4><p>答：Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p><h4 id="6、Mybatis执行批量插入，能返回数据库主键列表吗？"><a href="#6、Mybatis执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="6、Mybatis执行批量插入，能返回数据库主键列表吗？"></a>6、Mybatis执行批量插入，能返回数据库主键列表吗？</h4><p>答：能，JDBC都能，Mybatis当然也能。</p><h4 id="7、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"><a href="#7、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="headerlink" title="7、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"></a>7、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h4><p>答：Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。</p><p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p><h4 id="8、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#8、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="8、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>8、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h4><p>答：第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</resultMap></p><p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h4 id="9、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"><a href="#9、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。" class="headerlink" title="9、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"></a>9、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</h4><p>答：能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。</p><p>关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。</p><p>那么问题来了，join查询出来100条记录，如何确定主对象是5个，而不是100个？其去重复的原理是<resultMap>标签内的<id>子标签，指定了唯一确定一条记录的id列，Mybatis根据<id>列值来完成100条记录的去重复功能，<id>可以有多个，代表了联合主键的语意。</id></id></id></resultMap></p><p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p><p>举例：下面join查询出来6条记录，一、二列是Teacher对象列，第三列为Student对象列，Mybatis去重复处理后，结果为1个老师6个学生，而不是6个老师6个学生。</p><p>​    t_id   t_name      s_id</p><p>|      1 | teacher    |    38 |<br>|      1 | teacher    |    39 |<br>|      1 | teacher    |    40 |<br>|      1 | teacher    |    41 |<br>|      1 | teacher    |    42 |<br>|      1 | teacher    |    43 |</p><h4 id="10、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#10、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="10、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>10、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h4><p>答：Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p><h4 id="11、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#11、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="11、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>11、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h4><p>答：不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p><p>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p><h4 id="12、Mybatis中如何执行批处理？"><a href="#12、Mybatis中如何执行批处理？" class="headerlink" title="12、Mybatis中如何执行批处理？"></a>12、Mybatis中如何执行批处理？</h4><p>答：使用BatchExecutor完成批处理。</p><h4 id="13、Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#13、Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="13、Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>13、Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h4><p>答：Mybatis有三种基本的Executor执行器，<strong>SimpleExecutor、ReuseExecutor、BatchExecutor。</strong></p><p><strong>SimpleExecutor：</strong>每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p><p><strong>ReuseExecutor：</strong>执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p><p><strong>BatchExecutor：</strong>执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p><h4 id="14、Mybatis中如何指定使用哪一种Executor执行器？"><a href="#14、Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="14、Mybatis中如何指定使用哪一种Executor执行器？"></a>14、Mybatis中如何指定使用哪一种Executor执行器？</h4><p>答：在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p><h4 id="15、Mybatis是否可以映射Enum枚举类？"><a href="#15、Mybatis是否可以映射Enum枚举类？" class="headerlink" title="15、Mybatis是否可以映射Enum枚举类？"></a>15、Mybatis是否可以映射Enum枚举类？</h4><p>答：Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</p><h4 id="16、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#16、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="16、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a>16、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h4><p>答：虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。</p><p>原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p><h4 id="17、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#17、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="17、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>17、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h4><p>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</delete></update></insert></select></resultMap></parameterMap></p><h4 id="18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h4><p>答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><p>面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的Mybatis系列博客中都有详细讲解和原理分析。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis缓存机制</title>
      <link href="/2019/10/16/MyBatis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/10/16/MyBatis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis-缓存机制"><a href="#MyBatis-缓存机制" class="headerlink" title="MyBatis 缓存机制"></a>MyBatis 缓存机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　缓存是一般的ORM 框架都会提供的功能，目的就是提升查询的效率和减少数据库的压力。跟Hibernate 一样，MyBatis 也有一级缓存和二级缓存，并且预留了集成第三方缓存的接口。</p><a id="more"></a><p>　　缓存体系结构：</p><img data-src="1383365-20190628164226493-430550273.png" alt="img" style="zoom:75%;"><p>MyBatis 跟缓存相关的类都在cache 包里面，其中有一个Cache 接口，只有一个默认的实现类 PerpetualCache，它是用HashMap 实现的。我们可以通过 以下类找到这个缓存的庐山真面目</p><p><strong>DefaultSqlSession</strong></p><p>　　-&gt; <strong>BaseExecutor</strong></p><p>　　　　-&gt; <strong>PerpetualCache</strong> localCache</p><p>　　　　　　-&gt;<strong>private Map cache = new HashMap();</strong></p><p>　　除此之外，还有很多的装饰器，通过这些装饰器可以额外实现很多的功能：回收策略、日志记录、定时刷新等等。但是无论怎么装饰，经过多少层装饰，最后使用的还是基本的实现类（默认PerpetualCache）。可以通过 CachingExecutor 类 Debug 去查看。</p><p><img data-src="1383365-20190628165835198-1731504252.png" alt="img"></p><p>　　所有的缓存实现类总体上可分为三类：基本缓存、淘汰算法缓存、装饰器缓存。</p><p><img data-src="1383365-20190628172253737-1751427739.png" alt="img"></p><h2 id="一级缓存（本地缓存）"><a href="#一级缓存（本地缓存）" class="headerlink" title="一级缓存（本地缓存）"></a>一级缓存（本地缓存）</h2><p>　　一级缓存也叫本地缓存，MyBatis 的一级缓存是在会话（SqlSession）层面进行缓存的。MyBatis 的一级缓存是默认开启的，不需要任何的配置。首先我们必须去弄清楚一个问题，在MyBatis 执行的流程里面，涉及到这么多的对象，那么缓存PerpetualCache 应该放在哪个对象里面去维护？如果要在同一个会话里面共享一级缓存，这个对象肯定是在SqlSession 里面创建的，作为SqlSession 的一个属性。</p><p>　　DefaultSqlSession 里面只有两个属性，Configuration 是全局的，所以缓存只可能放在Executor 里面维护——SimpleExecutor/ReuseExecutor/BatchExecutor 的父类BaseExecutor 的构造函数中持有了PerpetualCache。在同一个会话里面，多次执行相同的SQL 语句，会直接从内存取到缓存的结果，不会再发送SQL 到数据库。但是不同的会话里面，即使执行的SQL 一模一样（通过一个Mapper 的同一个方法的相同参数调用），也不能使用到一级缓存。</p><p>　　每当我们使用MyBatis开启一次和数据库的会话，MyBatis会创建出一个SqlSession对象表示一次数据库会话。</p><p>　　在对数据库的一次会话中，我们有可能会反复地执行完全相同的查询语句，如果不采取一些措施的话，每一次查询都会查询一次数据库,而我们在极短的时间内做了完全相同的查询，那么它们的结果极有可能完全相同，由于查询一次数据库的代价很大，这有可能造成很大的资源浪费。</p><p>　　为了解决这一问题，减少资源的浪费，MyBatis会在表示会话的SqlSession对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。</p><p>　　如下图所示，MyBatis会在一次会话的表示—-一个SqlSession对象中创建一个本地缓存(local cache)，对于每一次查询，都会尝试根据查询的条件去本地缓存中查找是否在缓存中，如果在缓存中，就直接从缓存中取出，然后返回给用户；否则，从数据库读取数据，将查询结果存入缓存并返回给用户。</p><p><img data-src="1383365-20190628172851422-987384747.png" alt="img"></p><p>一级缓存的生命周期有多长？</p><ol><li>MyBatis在开启一个数据库会话时，会 创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。</li><li>如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用；</li><li>如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用；</li><li>SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用；</li></ol><p>SqlSession 一级缓存的工作流程：</p><ol><li><p>对于某个查询，根据statementId,params,rowBounds来构建一个key值，根据这个key值去缓存Cache中取出对应的key值存储的缓存结果</p></li><li><p>判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中；</p></li><li><p>如果命中，则直接将缓存结果返回；</p></li><li><p>如果没命中：</p></li><li><ol><li>去数据库中查询数据，得到查询结果；</li><li>将key和查询到的结果分别作为key,value对存储到Cache中；</li><li>将查询结果返回；</li></ol></li></ol><p>　　接下来我们来验证一下，MyBatis 的一级缓存到底是不是只能在一个会话里面共享，以及跨会话（不同session）操作相同的数据会产生什么问题。判断是否命中缓存：如果再次发送SQL 到数据库执行，说明没有命中缓存；如果直接打印对象，说明是从内存缓存中取到了结果。</p><p>1、在同一个session 中共享（不同session 不能共享）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;同Session</span><br><span class="line">SqlSession session1 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">BlogMapper mapper1 &#x3D; session1.getMapper(BlogMapper.class);</span><br><span class="line">System.out.println(mapper1.selectBlogById(1002));</span><br><span class="line">System.out.println(mapper1.selectBlogById(1002));</span><br></pre></td></tr></table></figure><p>　　执行以上sql我们可以看到控制台打印如下信息（需配置mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl），会发现我们两次的查询就发送了一次查询数据库的操作，这说明了缓存在发生作用：</p><p><em><img data-src="1383365-20190628173854959-1659491558.png" alt="img"></em></p><p>　　PS：一级缓存在BaseExecutor 的query()——queryFromDatabase()中存入。在queryFromDatabase()之前会get()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">        ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());</span><br><span class="line">　　　　。。。。。。try &#123;</span><br><span class="line">                ++this.queryStack;&#x2F;&#x2F;从缓存中获取</span><br><span class="line">                list &#x3D; resultHandler &#x3D;&#x3D; null ? (List)this.localCache.getObject(key) : null;</span><br><span class="line">                if (list !&#x3D; null) &#123;</span><br><span class="line">                    this.handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">                &#125; else &#123;&#x2F;&#x2F;缓存中获取不到，查询数据库</span><br><span class="line">                    list &#x3D; this.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">                &#125;</span><br><span class="line">　　　　。。。。。。</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2.同一个会话中，update（包括delete）会导致一级缓存被清空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;同Session</span><br><span class="line">SqlSession session1 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">BlogMapper mapper1 &#x3D; session1.getMapper(BlogMapper.class);</span><br><span class="line">System.out.println(mapper1.selectBlogById(1002));</span><br><span class="line">Blog blog3 &#x3D; new Blog();</span><br><span class="line">blog3.setBid(1002);</span><br><span class="line">blog3.setName(&quot;mybatis缓存机制修改&quot;);</span><br><span class="line">mapper1.updateBlog(blog3);</span><br><span class="line">session1.commit();&#x2F;&#x2F; 注意要提交事务，否则不会清除缓存</span><br><span class="line">System.out.println(mapper1.selectBlogById(1002));</span><br></pre></td></tr></table></figure><p>　　一级缓存是在BaseExecutor 中的update()方法中调用clearLocalCache()清空的（无条件），query 中会判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int update(MappedStatement ms, Object parameter) throws SQLException &#123;</span><br><span class="line">        ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());</span><br><span class="line">        if (this.closed) &#123;</span><br><span class="line">            throw new ExecutorException(&quot;Executor was closed.&quot;);</span><br><span class="line">        &#125; else &#123;　　　　　　  &#x2F;&#x2F;清除本地缓存</span><br><span class="line">            this.clearLocalCache();</span><br><span class="line">            return this.doUpdate(ms, parameter);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.其他会话更新了数据，导致读取到脏数据（一级缓存不能跨会话共享）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session1 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">BlogMapper mapper1 &#x3D; session1.getMapper(BlogMapper.class);</span><br><span class="line">SqlSession session2 &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">BlogMapper mapper2 &#x3D; session2.getMapper(BlogMapper.class);</span><br><span class="line">System.out.println(mapper2.selectBlogById(1002));</span><br><span class="line">Blog blog3 &#x3D; new Blog();</span><br><span class="line">blog3.setBid(1002);</span><br><span class="line">blog3.setName(&quot;mybatis缓存机制1&quot;);</span><br><span class="line">mapper1.updateBlog(blog3);</span><br><span class="line">session1.commit();</span><br><span class="line">System.out.println(mapper2.selectBlogById(1002));</span><br></pre></td></tr></table></figure><p>一级缓存的不足：</p><p>　　使用一级缓存的时候，因为缓存不能跨会话共享，不同的会话之间对于相同的数据可能有不一样的缓存。在有多个会话或者分布式环境下，会存在脏数据的问题。如果要解决这个问题，就要用到二级缓存。MyBatis 一级缓存（MyBaits 称其为 Local Cache）无法关闭，但是有两种级别可选：</p><ol><li>session 级别的缓存，在同一个 sqlSession 内，对同样的查询将不再查询数据库，直接从缓存中。</li><li>statement 级别的缓存，避坑： 为了避免这个问题，可以将一级缓存的级别设为 statement 级别的，这样每次查询结束都会清掉一级缓存。</li></ol><h2 id="二级缓存："><a href="#二级缓存：" class="headerlink" title="二级缓存："></a>二级缓存：</h2><p>　　二级缓存是用来解决一级缓存不能跨会话共享的问题的，范围是namespace 级别的，可以被多个SqlSession 共享（只要是同一个接口里面的相同方法，都可以共享），生命周期和应用同步。如果你的MyBatis使用了二级缓存，并且你的Mapper和select语句也配置使用了二级缓存，那么在执行select查询的时候，MyBatis会先从二级缓存中取输入，其次才是一级缓存，即MyBatis查询数据的顺序是：二级缓存  —&gt; 一级缓存 —&gt; 数据库。</p><p>　　作为一个作用范围更广的缓存，它肯定是在SqlSession 的外层，否则不可能被多个SqlSession 共享。而一级缓存是在SqlSession 内部的，所以第一个问题，肯定是工作在一级缓存之前，也就是只有取不到二级缓存的情况下才到一个会话中去取一级缓存。第二个问题，二级缓存放在哪个对象中维护呢？ 要跨会话共享的话，SqlSession 本身和它里面的BaseExecutor 已经满足不了需求了，那我们应该在BaseExecutor 之外创建一个对象。</p><p>　　实际上MyBatis 用了一个装饰器的类来维护，就是CachingExecutor。如果启用了二级缓存，MyBatis 在创建Executor 对象的时候会对Executor 进行装饰。CachingExecutor 对于查询请求，会判断二级缓存是否有缓存结果，如果有就直接返回，如果没有委派交给真正的查询器Executor 实现类，比如SimpleExecutor 来执行查询，再走到一级缓存的流程。最后会把结果缓存起来，并且返回给用户。</p><p><img data-src="1383365-20190628180149776-546074458.png" alt="img"></p><p>　　开启二级缓存的方法</p><p>第一步：配置 mybatis.configuration.cache-enabled=true，只要没有显式地设置cacheEnabled=false，都会用CachingExecutor 装饰基本的执行器。</p><p>第二步：在Mapper.xml 中配置<cache>标签：</cache></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache type&#x3D;&quot;org.apache.ibatis.cache.impl.PerpetualCache&quot;</span><br><span class="line">    size&#x3D;&quot;1024&quot;</span><br><span class="line">eviction&#x3D;&quot;LRU&quot;</span><br><span class="line">flushInterval&#x3D;&quot;120000&quot;</span><br><span class="line">readOnly&#x3D;&quot;false&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>基本上就是这样。这个简单语句的效果如下:</p><ul><li>映射语句文件中的所有 select 语句的结果将会被缓存。</li><li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li><li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li><li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li><li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li><li>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li></ul><p>这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。可用的清除策略有：</p><ul><li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li><li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li><li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li><li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li></ul><p>默认的清除策略是 LRU。</p><p>flushInterval（刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。</p><p>size（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。</p><p>readOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。</p><p>　　注：二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache=true 的 insert/delete/update 语句时，缓存会获得更新。</p><p>　　Mapper.xml 配置了<cache>之后，select()会被缓存。update()、delete()、insert()会刷新缓存。：如果cacheEnabled=true，Mapper.xml 没有配置标签，还有二级缓存吗？（没有）还会出现CachingExecutor 包装对象吗？（会）</cache></p><p>　　只要cacheEnabled=true 基本执行器就会被装饰。有没有配置<cache>，决定了在启动的时候会不会创建这个mapper 的Cache 对象，只是最终会影响到CachingExecutorquery 方法里面的判断。如果某些查询方法对数据的实时性要求很高，不需要二级缓存，怎么办？我们可以在单个Statement ID 上显式关闭二级缓存（默认是true）：</cache></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectBlog&quot; resultMap&#x3D;&quot;BaseResultMap&quot; useCache&#x3D;&quot;false&quot;&gt;</span><br></pre></td></tr></table></figure><p>　　二级缓存验证（验证二级缓存需要先开启二级缓存）</p><p> 1、事务不提交，二级缓存不存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(mapper1.selectBlogById(1002));</span><br><span class="line">&#x2F;&#x2F; 事务不提交的情况下，二级缓存不会写入</span><br><span class="line">&#x2F;&#x2F; session1.commit();</span><br><span class="line">System.out.println(mapper2.selectBlogById(1002));</span><br></pre></td></tr></table></figure><p>　　为什么事务不提交，二级缓存不生效？因为二级缓存使用TransactionalCacheManager（TCM）来管理，最后又调用了TransactionalCache 的getObject()、putObject 和commit()方法，TransactionalCache里面又持有了真正的Cache 对象，比如是经过层层装饰的PerpetualCache。在putObject 的时候，只是添加到了entriesToAddOnCommit 里面，只有它的commit()方法被调用的时候才会调用flushPendingEntries()真正写入缓存。它就是在DefaultSqlSession 调用commit()的时候被调用的。</p><p>2、使用不同的session 和mapper，验证二级缓存可以跨session 存在取消以上commit()的注释</p><p>3、在其他的session 中执行增删改操作，验证缓存会被刷新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(mapper1.selectBlogById(1002));</span><br><span class="line">&#x2F;&#x2F;主键自增返回测试</span><br><span class="line">Blog blog3 &#x3D; new Blog();</span><br><span class="line">blog3.setBid(1002);</span><br><span class="line">blog3.setName(&quot;mybatis缓存机制&quot;);</span><br><span class="line">mapper1.updateBlog(blog3);</span><br><span class="line">session1.commit();</span><br><span class="line">System.out.println(mapper2.selectBlogById(1002));</span><br></pre></td></tr></table></figure><p>　　为什么增删改操作会清空缓存？在CachingExecutor 的update()方法里面会调用flushCacheIfRequired(ms)，isFlushCacheRequired 就是从标签里面渠道的flushCache 的值。而增删改操作的flushCache 属性默认为true。</p><p>什么时候开启二级缓存？</p><p>一级缓存默认是打开的，二级缓存需要配置才可以开启。那么我们必须思考一个问题，在什么情况下才有必要去开启二级缓存？</p><ol><li>因为所有的增删改都会刷新二级缓存，导致二级缓存失效，所以适合在查询为主的应用中使用，比如历史交易、历史订单的查询。否则缓存就失去了意义。</li><li>如果多个namespace 中有针对于同一个表的操作，比如Blog 表，如果在一个namespace 中刷新了缓存，另一个namespace 中没有刷新，就会出现读到脏数据的情况。所以，推荐在一个Mapper 里面只操作单表的情况使用。</li></ol><p>　　如果要让多个namespace 共享一个二级缓存，应该怎么做？跨namespace 的缓存共享的问题，可以使用<cache-ref>来解决：</cache-ref></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache-ref namespace&#x3D;&quot;com.wuzz.crud.dao.DepartmentMapper&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>　　cache-ref 代表引用别的命名空间的Cache 配置，两个命名空间的操作使用的是同一个Cache。在关联的表比较少，或者按照业务可以对表进行分组的时候可以使用。</p><p>　　注意：在这种情况下，多个Mapper 的操作都会引起缓存刷新，缓存的意义已经不大了.</p><p>第三方缓存做二级缓存</p><p>　　除了MyBatis 自带的二级缓存之外，我们也可以通过实现Cache 接口来自定义二级缓存。MyBatis 官方提供了一些第三方缓存集成方式，比如ehcache 和redis：<a href="https://github.com/mybatis/redis-cache" target="_blank" rel="noopener">https://github.com/mybatis/redis-cache</a> ,这里就不过多介绍了。当然，我们也可以使用独立的缓存服务，不使用MyBatis 自带的二级缓存。</p><p>自定义缓存：</p><p>　　除了上述自定义缓存的方式，你也可以通过实现你自己的缓存，或为其他第三方缓存方案创建适配器，来完全覆盖缓存行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache type&#x3D;&quot;com.domain.something.MyCustomCache&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>　　这个示例展示了如何使用一个自定义的缓存实现。type 属性指定的类必须实现 org.mybatis.cache.Cache 接口，且提供一个接受 String 参数作为 id 的构造器。 这个接口是 MyBatis 框架中许多复杂的接口之一，但是行为却非常简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Cache &#123;</span><br><span class="line">  String getId();</span><br><span class="line">  int getSize();</span><br><span class="line">  void putObject(Object key, Object value);</span><br><span class="line">  Object getObject(Object key);</span><br><span class="line">  boolean hasKey(Object key);</span><br><span class="line">  Object removeObject(Object key);</span><br><span class="line">  void clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　为了对你的缓存进行配置，只需要简单地在你的缓存实现中添加公有的 JavaBean 属性，然后通过 cache 元素传递属性值，例如，下面的例子将在你的缓存实现上调用一个名为 <code>setCacheFile(String file)</code> 的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache type&#x3D;&quot;com.domain.something.MyCustomCache&quot;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;cacheFile&quot; value&#x3D;&quot;&#x2F;tmp&#x2F;my-custom-cache.tmp&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;cache&gt;</span><br></pre></td></tr></table></figure><p>　　你可以使用所有简单类型作为 JavaBean 属性的类型，MyBatis 会进行转换。 你也可以使用占位符（如 <code>${cache.file}</code>），以便替换成在配置文件属性中定义的值。从版本 3.4.2 开始，MyBatis 已经支持在所有属性设置完毕之后，调用一个初始化方法。 如果想要使用这个特性，请在你的自定义缓存类里实现 <code>org.apache.ibatis.builder.InitializingObject</code> 接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface InitializingObject &#123;</span><br><span class="line">  void initialize() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　请注意，缓存的配置和缓存实例会被绑定到 SQL 映射文件的命名空间中。 因此，同一命名空间中的所有语句和缓存将通过命名空间绑定在一起。 每条语句可以自定义与缓存交互的方式，或将它们完全排除于缓存之外，这可以通过在每条语句上使用两个简单属性来达成。 默认情况下，语句会这样来配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select ... flushCache&#x3D;&quot;false&quot; useCache&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;insert ... flushCache&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;update ... flushCache&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;delete ... flushCache&#x3D;&quot;true&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>　　鉴于这是默认行为，显然你永远不应该以这样的方式显式配置一条语句。但如果你想改变默认的行为，只需要设置 flushCache 和 useCache 属性。比如，某些情况下你可能希望特定 select 语句的结果排除于缓存之外，或希望一条 select 语句清空缓存。类似地，你可能希望某些 update 语句执行时不要刷新缓存。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
            <tag> 缓存机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程通信和线程通信</title>
      <link href="/2019/10/15/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%92%8C%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/10/15/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%92%8C%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="进程通信和线程通信"><a href="#进程通信和线程通信" class="headerlink" title="进程通信和线程通信"></a>进程通信和线程通信</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程就是正在运行的程序，它是系统资源调度的独立单位，并且一个进程可以执行多个任务，而线程是程序执行的任务，它是程序使用CPU的基本单位，因此也可以说线程是依赖进程的</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程就是正在运行的程序，它是系统资源调度的独立单位，各个进程之间不会相互影响，因为系统给它们分配了不同的空间和资源，它分为单进程和多进程</p><a id="more"></a><p>单进程的计算机一次只能做一件事，而多个进程的计算机可以做到一次做不同的事情，一边听音乐，一边打游戏，这两件事虽然看起来在同时进行，但是其实是CPU在做成程序之间的高效切换，才让我们感觉是同时进行的。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是程序执行的任务，它是程序使用CPU的基本单位，同时单线程也就是做的事情很专一，不会分神去做别的 事，也就是程序只有一条执行路径，多线程就是可以分出多条路径去做同一件事情，也就是程序有多条执行路径。因为多线程的存在，不是提高了程序的执行速度，其实是为了提高应用程序的使用率，也可以说程序的执行其实都是抢CPU的资源，也就是抢CPU的执行权，而其中的某一个进程如果执行路径比较多，就会有更高的几率抢到CPU执行权，但是这一过程是随机的，不知道哪一个线程会在哪一个时刻占到这个资源，所以线程的执行有随机性。</p><h3 id="获取线程的方式"><a href="#获取线程的方式" class="headerlink" title="获取线程的方式"></a>获取线程的方式</h3><p>目前获取线程有四种方式</p><ul><li>实现Runnable接口（无返回值）</li><li>实现Callable接口（有返回值）</li><li>实例化Thread类</li><li>使用线程池获取</li></ul><h2 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h2><ul><li>管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系</li><li>信号量：信号量是一个计数器，可以用来控制多线进程对共享资源的访问。它常作为一种锁机制，防止某个进程正在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信息传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。</li><li>共享内存：共享内存就是映射一段能够被其它进程所访问的内存，这段共享内存由一个进程创建，但多个进程可以访问。共享内存是最快的IPC方式，它是针对进程内通信方式运行效率而专门设计。它往往与其它通信机制，如信号量配合使用，来实现进程间的同步和通信。</li><li>套接字：套接字也是一种进程通信机制，与其它通信机制不同的是，它可以用于不同设备间的进程通信</li></ul><h2 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h2><ul><li>锁机制：包括互斥锁，条件变量，读写锁<ul><li>互斥锁提供了以排他方式防止数据结构被并发修改的问题</li><li>读写锁运行多线程同时读共享数据，而对写操作是互斥的</li><li>条件变量可以以原子方式阻塞进程，知道某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的，条件变量始终与互斥锁一起使用。</li></ul></li><li>信号量机制（Semaphore）：包括无名线程信号量和命名线程信号量</li><li>信号机制（Signal）：类似进程间的信号处理，线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</li></ul><h2 id="线程如何按照自己指定的顺序执行"><a href="#线程如何按照自己指定的顺序执行" class="headerlink" title="线程如何按照自己指定的顺序执行"></a>线程如何按照自己指定的顺序执行</h2><p>我们在日常的多线程开发中，可能有时会想让每个线程都按照我们指定的顺序来运行，而不是让CPU随机调度，这样可能会让我们在日常开发的工作中带来不必要的。</p><p>如下代码所示，我们按照顺序写了一段多线程的代码，然后想让t1，t2，t3都能顺序的执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 没有顺序执行的示例</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void test() &#123;</span><br><span class="line">    Thread t1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;1&quot;);</span><br><span class="line">    &#125;, &quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">    Thread t2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;2&quot;);</span><br><span class="line">    &#125;, &quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">    Thread t3 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;3&quot;);</span><br><span class="line">    &#125;, &quot;t3&quot;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们在运行后会发现，他们并没有按照我们的代码顺序执行的，那么有什么方法能够让他们按顺序执行？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="使用join"><a href="#使用join" class="headerlink" title="使用join"></a>使用join</h3><p>jion的意思是加入线程，需要等待线程执行完毕以后，其它线程才能够继续执行</p><p>实例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void test2() throws InterruptedException &#123;</span><br><span class="line">    Thread t1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;1&quot;);</span><br><span class="line">    &#125;, &quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">    Thread t2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;2&quot;);</span><br><span class="line">    &#125;, &quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">    Thread t3 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;3&quot;);</span><br><span class="line">    &#125;, &quot;t3&quot;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t1.join();</span><br><span class="line"></span><br><span class="line">    t2.start();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    t3.start();</span><br><span class="line">    t3.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>这里主要利用了join的阻塞效果，来达到我们的使用目的，从上可知，程序已经按照我们指定的顺序执行结束了，并得到了我们想要的结果，我们进入join的源码页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized void join(long millis)</span><br><span class="line">throws InterruptedException &#123;</span><br><span class="line">    long base &#x3D; System.currentTimeMillis();</span><br><span class="line">    long now &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    if (millis &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (millis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            wait(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line">            long delay &#x3D; millis - now;</span><br><span class="line">            if (delay &lt;&#x3D; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now &#x3D; System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们可以看到，join方法是线程安全的，因为引入了 <code>Synchronized</code> 重量锁，同时我们可以看到，join方法默认是传递的参数为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void join() throws InterruptedException &#123;</span><br><span class="line">join(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么它就会进入这个方法，也就是while循环，isAlive()方法就是判断这个线程是否激活，但线程没有运行完成的时候，处于激活状态，也就是说当t1没有执行完成后，主线程会进入阻塞状态，也就是不断自旋的操作，直到线程执行完毕后，才跳出循环</p><p>需要注意的是，这里的wait不是阻塞调用者，而是阻塞主线程，也就是说当t1线程没有执行完毕，主线程是无法继续往下执行的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (millis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    while (isAlive()) &#123;</span><br><span class="line">    wait(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用Executors线程池"><a href="#利用Executors线程池" class="headerlink" title="利用Executors线程池"></a>利用Executors线程池</h3><p>Executors是JUC里面的操作类，可以方便的给我们提供线程池的操作，这里我们使用Executors中的newSingleThreadExecutor方法，创建一个单线程的线程池。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用线程池</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void test3() &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建一个单例线程</span><br><span class="line">    ExecutorService executorService &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line">    Thread t1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;1&quot;);</span><br><span class="line">    &#125;, &quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">    Thread t2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;2&quot;);</span><br><span class="line">    &#125;, &quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">    Thread t3 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;3&quot;);</span><br><span class="line">    &#125;, &quot;t3&quot;);</span><br><span class="line">    executorService.submit(t1);</span><br><span class="line">    executorService.submit(t2);</span><br><span class="line">    executorService.submit(t3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>我们能够看到，线程也按照我们的顺序进行执行，这里主要就是利用了newSingleThreadExecutor()方法，其实原理很简单，因为单例线程池的内部是一个基于FIFO的队列，也就是说当我们依次将t1, t2, t3加入队列中，实际上就绪状态只有t1这个线程，t2，t3则会被添加到队列中，当t1执行完毕后，在从队列中获取一个放到就绪队列。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM类加载机制</title>
      <link href="/2019/10/14/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/10/14/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h1><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机设计团队把加载动作放到JVM外部实现，以便于引用程序决定如何获取所需的类，JVM提供了三种类加载器</p><h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>Bootstrap ClassLoader，负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath 参数指定路径下的，且被虚拟机认可（按文件名识别，如tr.jar）的类</p><a id="more"></a><h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>Extension ClassLoader，负责加载JAVA_HOME\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库。</p><h3 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h3><p>Application ClassLoader，负责加载用户路径（classpath）上的类库。JVM通过双亲委派进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>JVM类加载机制主要分为以下五个部分：加载、验证、准备、解析、初始化</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（例如从jar包或者war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>这一阶段的主要目的就是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。</p><p>注意这里所说的初始值概念，比如一个类变量定义为： v = 8080，实际上变量v在准备阶段过后的初始值为0，而不是8080，将v赋值为808的put static指令是在程序被编译后，存放在类构造器方法之中。</p><p>但是注意如果使用的是以下申明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final int v &#x3D; 8080;</span><br></pre></td></tr></table></figure><p>在编译阶段会给v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的类型常量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_CLASS_info</span><br><span class="line">CONSTANT_Field_info</span><br><span class="line">CONSTANT_Method_info</span><br></pre></td></tr></table></figure><h4 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h4><p>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class的文件格式中。编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中</p><h4 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h4><p>直接引用可以是指向目标的指针，相对于偏移量或是一个能直接定位到目标的句柄，如果有了直接引用，那引用的目标必定已经在内存中存在了。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载的最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都是由JVM主导，到了初始化阶段，才开始真正指定类中定义的Java程序代码。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 类加载机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐观锁和悲观锁</title>
      <link href="/2019/10/14/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
      <url>/2019/10/14/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>乐观锁：顾名思义，就是十分乐观，它总是认为不会出现问题，无论干什么都不去上锁~，如果出现了问题，再次更新值测试，这里使用了version字段。</p><a id="more"></a><p>也就是每次更新的时候同时维护一个version字段</p><h3 id="乐观锁实现方式"><a href="#乐观锁实现方式" class="headerlink" title="乐观锁实现方式"></a>乐观锁实现方式</h3><ul><li>取出记录时，获取当前的version</li><li>更新时，带上这个version</li><li>执行更新时，set version = newVersion where version = oldVersion</li><li>如果version不对，就更新失败</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">乐观锁：1：先查询，获得版本号 version &#x3D;1</span><br><span class="line"></span><br><span class="line">-- A 线程</span><br><span class="line">update user set name &#x3D; &quot;陌溪&quot;, version &#x3D; version + 1 </span><br><span class="line">where id &#x3D; 2 and version &#x3D; 1</span><br><span class="line"></span><br><span class="line">-- B 线程抢先完成，这个时候Version &#x3D; 2，导致A修改失败</span><br><span class="line">update user set name &#x3D; &quot;陌溪&quot;, version &#x3D; version + 1 </span><br><span class="line">where id &#x3D; 2 and version &#x3D; 1</span><br></pre></td></tr></table></figure><h2 id="Mybatis-Plus使用乐观锁"><a href="#Mybatis-Plus使用乐观锁" class="headerlink" title="Mybatis-Plus使用乐观锁"></a>Mybatis-Plus使用乐观锁</h2><p>首先需要在数据库增加version字典，默认为1</p><p><img data-src="image-20200329172158610.png" alt="image"></p><p>然后在实体类增加对应的字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 乐观锁Version注解</span><br><span class="line">@Version</span><br><span class="line">private Integer version;</span><br></pre></td></tr></table></figure><p>注册组件，在MybatisPlusConfig中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册乐观锁</span><br><span class="line">@Bean</span><br><span class="line">public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123;</span><br><span class="line">return new OptimisticLockerInterceptor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>顾名思义，就是十分悲观，它总是认为什么时候都会出现问题，无论什么操作都会上锁，再次操作</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 乐观锁和悲观锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub基本使用学习</title>
      <link href="/2019/10/11/GitHub%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/10/11/GitHub%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub学习"><a href="#GitHub学习" class="headerlink" title="GitHub学习"></a>GitHub学习</h1><p>使用Github可以查找很多优秀框架 + 源码</p><h2 id="常用词含义"><a href="#常用词含义" class="headerlink" title="常用词含义"></a>常用词含义</h2><ul><li><p>watch：会持续收到该项目的动态</p></li><li><p>fork：复制某个仓库到自己的Github仓库中</p></li><li><p>star：可以理解为点赞</p></li><li><p>clone：将项目下载至本地</p></li><li><p>follow：关注你感兴趣的作者，会收到他们的动态</p><a id="more"></a></li></ul><h2 id="in关键字限制搜索范围"><a href="#in关键字限制搜索范围" class="headerlink" title="in关键字限制搜索范围"></a>in关键字限制搜索范围</h2><ul><li>公式：<code>XXX关键字 in:name 或 description 或 readme</code></li><li>xxx in:name   项目名称含有XXX的</li><li>xxx in:description   项目描述含有XXX的</li><li>xxx in:readme   项目的readme文件中包含XXX的</li><li>组合使用<ul><li>xxx   in:name,readme    项目的名称和readme中包含xxx的</li></ul></li></ul><h2 id="stars或fork数量关键字查找"><a href="#stars或fork数量关键字查找" class="headerlink" title="stars或fork数量关键字查找"></a>stars或fork数量关键字查找</h2><ul><li>公式：<ul><li><code>xxx关键字  stars 通配符</code>  :&gt;  或者 :&gt;=</li><li>区间范围数字：  <code>stars:数字1..数字2</code></li></ul></li><li>案例<ul><li>查找stars数大于等于5000的Springboot项目：springboot  stars:&gt;=5000</li><li>查找forks数在1000~2000之间的springboot项目：springboot forks:1000..5000</li></ul></li><li>组合使用<ul><li>查找star大于1000，fork数在500到1000：<code>springboot stars:&gt;1000 forks:500..1000</code></li></ul></li></ul><h2 id="awesome加强搜索"><a href="#awesome加强搜索" class="headerlink" title="awesome加强搜索"></a>awesome加强搜索</h2><ul><li>公式：<code>awesome 关键字</code>：awesome系列，一般用来收集学习、工具、书籍类相关的项目</li><li>搜索优秀的redis相关的项目，包括框架，教程等  awesome redis</li></ul><h2 id="高亮显示某行代码"><a href="#高亮显示某行代码" class="headerlink" title="高亮显示某行代码"></a>高亮显示某行代码</h2><ul><li>一行：地址后面紧跟  #L10<ul><li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13</code></li></ul></li><li>多行：地址后面紧跟 #Lx - #Ln<ul><li><code>https://github.com/moxi624/mogu_blog_v2/blob/master/mogu_admin/pom.xml#L13-L30</code></li></ul></li></ul><h2 id="项目内搜索"><a href="#项目内搜索" class="headerlink" title="项目内搜索"></a>项目内搜索</h2><ul><li>使用英文字母 <code>t</code> ,开启项目内搜索</li></ul><p><img data-src="image-20200326212650322.png" alt="image"></p><h2 id="搜索某个地区内的大佬"><a href="#搜索某个地区内的大佬" class="headerlink" title="搜索某个地区内的大佬"></a>搜索某个地区内的大佬</h2><ul><li>location：地区</li><li>language：语言</li><li>例如：<code>location:beijing language:java</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产环境服务器变慢，诊断思路和性能评估</title>
      <link href="/2019/10/11/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%98%E6%85%A2%EF%BC%8C%E8%AF%8A%E6%96%AD%E6%80%9D%E8%B7%AF%E5%92%8C%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/"/>
      <url>/2019/10/11/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%98%E6%85%A2%EF%BC%8C%E8%AF%8A%E6%96%AD%E6%80%9D%E8%B7%AF%E5%92%8C%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux诊断原因"><a href="#Linux诊断原因" class="headerlink" title="Linux诊断原因"></a>Linux诊断原因</h1><h2 id="命令集合"><a href="#命令集合" class="headerlink" title="命令集合"></a>命令集合</h2><h3 id="整机：top，查看整机系统新能"><a href="#整机：top，查看整机系统新能" class="headerlink" title="整机：top，查看整机系统新能"></a>整机：top，查看整机系统新能</h3><a id="more"></a><p><img data-src="image-20200326162329550.png" alt="image"></p><p>使用top命令的话，重点关注的是 %CPU、%MEM 、load average 三个指标</p><p>在这个命令下，按1的话，可以看到每个CPU的占用情况</p><p>uptime：系统性能命令的精简版</p><h3 id="CPU：vmstat"><a href="#CPU：vmstat" class="headerlink" title="CPU：vmstat"></a>CPU：vmstat</h3><ul><li>查看CPU（包含但是不限于）</li><li>查看额外<ul><li>查看所有CPU核信息：mpstat -p ALL 2</li><li>每个进程使用CPU的用量分解信息：pidstat -u 1 -p 进程编号</li></ul></li></ul><p>命令格式：<code>vmstat -n 2 3</code></p><p><img data-src="image-20200326162803165.png" alt="image"></p><p>一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是残阳的时间间隔数（单位秒），第二个参数是采样的次数</p><p><strong>procs</strong></p><p>​        r：运行和等待的CPU时间片的进程数，原则上1核的CPU的运行队列不要超过2，整个系统的运行队列不超过总核数的2倍，否则代表系统压力过大，我们看蘑菇博客测试服务器，能发现都超过了2，说明现在压力过大</p><p>​        b：等待资源的进程数，比如正在等待磁盘I/O、网络I/O等</p><p><strong>cpu</strong></p><p>​    us：用户进程消耗CPU时间百分比，us值高，用户进程消耗CPU时间多，如果长期大于50%，优化程序</p><p>​    sy：内核进程消耗的CPU时间百分比</p><p><img data-src="image-20200326164521263.png" alt="image"></p><p>​    us + sy 参考值为80%，如果us + sy 大于80%，说明可能存在CPU不足，从上面的图片可以看出，us + sy还没有超过百分80，因此说明蘑菇博客的CPU消耗不是很高</p><p>​    id：处于空闲的CPU百分比</p><p>​    wa：系统等待IO的CPU时间百分比</p><p>​    st：来自于一个虚拟机偷取的CPU时间比</p><h3 id="内存：free"><a href="#内存：free" class="headerlink" title="内存：free"></a>内存：free</h3><ul><li><p>应用程序可用内存数：free -m</p></li><li><p>应用程序可用内存/系统物理内存 &gt; 70% 内存充足</p></li><li><p>应用程序可用内存/系统物理内存 &lt; 20% 内存不足，需要增加内存</p></li><li><p>20% &lt;  应用程序可用内存/系统物理内存 &lt; 70%，表示内存基本够用</p></li></ul><p>free -h：以人类能看懂的方式查看物理内存</p><p><img data-src="image-20200326170217637.png" alt="image"></p><p>free -m：以MB为单位，查看物理内存</p><p><img data-src="image-20200326165815071.png" alt="image"></p><p>free -g：以GB为单位，查看物理内存</p><h3 id="硬盘：df"><a href="#硬盘：df" class="headerlink" title="硬盘：df"></a>硬盘：df</h3><p>格式：<code>df -h  /</code>  (-h：human，表示以人类能看到的方式换算)</p><p><img data-src="image-20200326170318733.png" alt="image"></p><ul><li>硬盘IO：iostat</li></ul><p>系统慢有两种原因引起的，一个是CPU高，一个是大量IO操作</p><p>格式：<code>iostat -xdk 2 3</code></p><p><img data-src="image-20200326170522559.png" alt="image"></p><p>磁盘块设备分布：</p><p>rkB /s：每秒读取数据量kB；</p><p>wkB/s：每秒写入数据量kB；</p><p>svctm I/O：请求的平均服务时间，单位毫秒</p><p>await I/O：请求的平均等待时间，单位毫秒，值越小，性能越好</p><p>util：一秒钟有百分几的时间用于I/O操作。接近100%时，表示磁盘带宽跑满，需要优化程序或者增加磁盘；</p><p>rkB/s，wkB/s根据系统应用不同会有不同的值，但有规律遵循：长期、超大数据读写，肯定不正常，需要优化程序读取。</p><p>svctm的值与await的值很接近，表示几乎没有I/O等待，磁盘性能好，如果await的值远高于svctm的值，则表示I/O队列等待太长，需要优化程序或更换更快磁盘</p><h3 id="网络IO：ifstat"><a href="#网络IO：ifstat" class="headerlink" title="网络IO：ifstat"></a>网络IO：ifstat</h3><ul><li>默认本地没有，下载ifstat</li></ul><p><img data-src="image-20200326171559406.png" alt="image"></p><h2 id="生产环境服务器变慢，诊断思路和性能评估"><a href="#生产环境服务器变慢，诊断思路和性能评估" class="headerlink" title="生产环境服务器变慢，诊断思路和性能评估"></a>生产环境服务器变慢，诊断思路和性能评估</h2><p>记一次印象深刻的故障？</p><p>结合Linux 和 JDK命令一起分析，步骤如下</p><ul><li><p>使用top命令找出CPU占比最高的</p></li><li><p>ps -ef 或者 jps 进一步定位，得知是一个怎么样的后台程序出的问题</p></li><li><p>定位到具体线程或者代码</p><ul><li>ps -mp 进程  -o THREAD，tid，time</li><li>参数解释<ul><li>-m：显示所有的线程</li><li>-p：pid进程使用CPU的时间</li><li>-o：该参数后是用户自定义格式</li></ul></li></ul><p><img data-src="image-20200326173656164.png" alt="image"></p></li><li><p>将需要的线程ID转换为16进制格式（英文小写格式）</p><ul><li>printf “%x\n” 有问题的线程ID</li></ul></li><li><p>jstack 进程ID | grep tid（16进制线程ID小写英文） -A60</p><p>精准定位到错误的地方</p></li></ul><p><img data-src="image-20200326174107444.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM之垃圾回收器</title>
      <link href="/2019/10/11/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2019/10/11/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM之垃圾收集器"><a href="#JVM之垃圾收集器" class="headerlink" title="JVM之垃圾收集器"></a>JVM之垃圾收集器</h1><h2 id="GC垃圾回收算法和垃圾收集器关系"><a href="#GC垃圾回收算法和垃圾收集器关系" class="headerlink" title="GC垃圾回收算法和垃圾收集器关系"></a>GC垃圾回收算法和垃圾收集器关系</h2><blockquote><p>天上飞的理念，要有落地的实现（垃圾收集器就是GC垃圾回收算法的实现）</p><p>GC算法是内存回收的方法论，垃圾收集器就是算法的落地实现</p></blockquote><a id="more"></a><p>GC算法主要有以下几种</p><ul><li>引用计数（几乎不用，无法解决循环引用的问题）</li><li>复制拷贝（用于新生代）</li><li>标记清除（用于老年代）</li><li>标记整理（用于老年代）</li></ul><p>因为目前为止还没有完美的收集器出现，更没有万能的收集器，只是针对具体应用最合适的收集器，进行分代收集（那个代用什么收集器）</p><h2 id="四种主要的垃圾收集器"><a href="#四种主要的垃圾收集器" class="headerlink" title="四种主要的垃圾收集器"></a>四种主要的垃圾收集器</h2><ul><li>Serial：串行回收  <code>-XX:+UseSeriallGC</code></li><li>Parallel：并行回收  <code>-XX:+UseParallelGC</code></li><li>CMS：并发标记清除</li><li>G1</li><li>ZGC：（java 11 出现的）</li></ul><p><img data-src="image-20200325084453631.png" alt="image1"></p><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>串行垃圾回收器，它为单线程环境设计且值使用一个线程进行垃圾收集，会暂停所有的用户线程，只有当垃圾回收完成时，才会重新唤醒主线程继续执行。所以不适合服务器环境</p><p><img data-src="image-20200325085320683.png" alt="image"></p><h3 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h3><p>并行垃圾收集器，多个垃圾收集线程并行工作，此时用户线程也是阻塞的，适用于科学计算 / 大数据处理等弱交互场景，也就是说Serial 和 Parallel其实是类似的，不过是多了几个线程进行垃圾收集，但是主线程都会被暂停，但是并行垃圾收集器处理时间，肯定比串行的垃圾收集器要更短</p><p><img data-src="image-20200325085729428.png" alt="image"></p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>并发标记清除，用户线程和垃圾收集线程同时执行（不一定是并行，可能是交替执行），不需要停顿用户线程，互联网公司都在使用，适用于响应时间有要求的场景。并发是可以有交互的，也就是说可以一边进行收集，一边执行应用程序。</p><p><img data-src="image-20200325090858921.png" alt="image"></p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>G1垃圾回收器将堆内存分割成不同区域，然后并发的进行垃圾回收</p><p><img data-src="image-20200325093222711.png" alt="image"></p><h2 id="垃圾收集器总结"><a href="#垃圾收集器总结" class="headerlink" title="垃圾收集器总结"></a>垃圾收集器总结</h2><p>注意：并行垃圾回收在单核CPU下可能会更慢</p><p><img data-src="image-20200325091619082.png" alt="image"></p><h2 id="查看默认垃圾收集器"><a href="#查看默认垃圾收集器" class="headerlink" title="查看默认垃圾收集器"></a>查看默认垃圾收集器</h2><p>使用下面JVM命令，查看配置的初始参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags</span><br></pre></td></tr></table></figure><p>然后运行一个程序后，能够看到它的一些初始配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize&#x3D;266376000 -XX:MaxHeapSize&#x3D;4262016000 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure><p>移动到最后一句，就能看到 <code>-XX:+UseParallelGC</code> 说明使用的是并行垃圾回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br></pre></td></tr></table></figure><h2 id="默认垃圾收集器有哪些"><a href="#默认垃圾收集器有哪些" class="headerlink" title="默认垃圾收集器有哪些"></a>默认垃圾收集器有哪些</h2><p>Java中一共有7大垃圾收集器</p><ul><li>UserSerialGC：串行垃圾收集器</li><li>UserParallelGC：并行垃圾收集器</li><li>UseConcMarkSweepGC：（CMS）并发标记清除</li><li>UseParNewGC：年轻代的并行垃圾回收器</li><li>UseParallelOldGC：老年代的并行垃圾回收器</li><li>UseG1GC：G1垃圾收集器</li><li>UserSerialOldGC：串行老年代垃圾收集器（已经被移除）</li></ul><p>底层源码</p><p><img data-src="image-20200325100653829.png" alt="image"></p><h2 id="各垃圾收集器的使用范围"><a href="#各垃圾收集器的使用范围" class="headerlink" title="各垃圾收集器的使用范围"></a>各垃圾收集器的使用范围</h2><p><img data-src="image-20200325101451849.png" alt="image"></p><p>新生代使用的：</p><ul><li>Serial Copying： UserSerialGC，串行垃圾回收器</li><li>Parallel Scavenge：UserParallelGC，并行垃圾收集器</li><li>ParNew：UserParNewGC，新生代并行垃圾收集器</li></ul><p>老年区使用的：</p><ul><li>Serial Old：UseSerialOldGC，老年代串行垃圾收集器</li><li>Parallel Compacting（Parallel Old）：UseParallelOldGC，老年代并行垃圾收集器</li><li>CMS：UseConcMarkSwepp，并行标记清除垃圾收集器</li></ul><p>各区都能使用的：</p><p>G1：UseG1GC，G1垃圾收集器</p><p>垃圾收集器就来具体实现这些GC算法并实现内存回收，不同厂商，不同版本的虚拟机实现差别很大，HotSpot中包含的收集器如下图所示：</p><p><img data-src="image-20200325102329216.png" alt="image"></p><h2 id="部分参数说明"><a href="#部分参数说明" class="headerlink" title="部分参数说明"></a>部分参数说明</h2><ul><li>DefNew：Default New Generation</li><li>Tenured：Old</li><li>ParNew：Parallel New Generation</li><li>PSYoungGen：Parallel Scavenge</li><li>ParOldGen：Parallel Old Generation</li></ul><h2 id="Java中的Server和Client模式"><a href="#Java中的Server和Client模式" class="headerlink" title="Java中的Server和Client模式"></a>Java中的Server和Client模式</h2><p>使用范围：一般使用Server模式，Client模式基本不会使用</p><p>操作系统</p><ul><li>32位的Window操作系统，不论硬件如何都默认使用Client的JVM模式</li><li>32位的其它操作系统，2G内存同时有2个cpu以上用Server模式，低于该配置还是Client模式</li><li>64位只有Server模式</li></ul><p><img data-src="image-20200325175208231.png" alt="image"></p><h2 id="新生代下的垃圾收集器"><a href="#新生代下的垃圾收集器" class="headerlink" title="新生代下的垃圾收集器"></a>新生代下的垃圾收集器</h2><h3 id="串行GC-Serial"><a href="#串行GC-Serial" class="headerlink" title="串行GC(Serial)"></a>串行GC(Serial)</h3><p>串行GC（Serial）（Serial Copying）</p><p>是一个单线程单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。</p><p><img data-src="image-20200325175704604.png" alt="image"></p><p>串行收集器是最古老，最稳定以及效率高的收集器，只使用一个线程去回收但其在垃圾收集过程中可能会产生较长的停顿(Stop-The-World 状态)。 虽然在收集垃圾过程中需要暂停所有其它的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是Java虚拟机运行在Client模式下默认的新生代垃圾收集器</p><p>对应JVM参数是：-XX:+UseSerialGC</p><p>开启后会使用：Serial(Young区用) + Serial Old(Old区用) 的收集器组合</p><p>表示：新生代、老年代都会使用串行回收收集器，新生代使用复制算法，老年代使用标记-整理算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseSerialGC</span><br></pre></td></tr></table></figure><h3 id="并行GC-ParNew"><a href="#并行GC-ParNew" class="headerlink" title="并行GC(ParNew)"></a>并行GC(ParNew)</h3><p>并行收集器，使用多线程进行垃圾回收，在垃圾收集，会Stop-the-World暂停其他所有的工作线程直到它收集结束</p><p><img data-src="image-20200325191328733.png" alt="image"></p><p>ParNew收集器其实就是Serial收集器新生代的并行多线程版本，最常见的应用场景时配合老年代的CMS GC工作，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。它是很多Java虚拟机运行在Server模式下新生代的默认垃圾收集器。</p><p>常见对应JVM参数：-XX:+UseParNewGC     启动ParNew收集器，只影响新生代的收集，不影响老年代</p><p>开启上述参数后，会使用：ParNew（Young区用） + Serial Old的收集器组合，新生代使用复制算法，老年代采用标记-整理算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParNewGC</span><br></pre></td></tr></table></figure><p>但是会出现警告，即 ParNew 和 Serial Old 这样搭配，Java8已经不再被推荐</p><p><img data-src="image-20200325194316660.png" alt="image"></p><p>备注： -XX:ParallelGCThreads   限制线程数量，默认开启和CPU数目相同的线程数</p><h3 id="并行回收GC（Parallel）-（Parallel-Scavenge）"><a href="#并行回收GC（Parallel）-（Parallel-Scavenge）" class="headerlink" title="并行回收GC（Parallel）/ （Parallel Scavenge）"></a>并行回收GC（Parallel）/ （Parallel Scavenge）</h3><p>因为Serial 和 ParNew都不推荐使用了，因此现在新生代默认使用的是Parallel Scavenge，也就是新生代和老年代都是使用并行</p><p><img data-src="image-20200325204437678.png" alt="image"></p><p>Parallel Scavenge收集器类似ParNew也是一个新生代垃圾收集器，使用复制算法，也是一个并行的多线程的垃圾收集器，俗称吞吐量优先收集器。一句话：串行收集器在新生代和老年代的并行化</p><p>它关注的重点是：</p><p>可控制的吞吐量（Thoughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) ），也即比如程序运行100分钟，垃圾收集时间1分钟，吞吐量就是99%。高吞吐量意味着高效利用CPU时间，它多用于在后台运算而不需要太多交互的任务。</p><p>自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间( -XX:MaxGCPauseMills)）或最大的吞吐量。</p><p>常用JVM参数：-XX:+UseParallelGC 或 -XX:+UseParallelOldGC（可互相激活）使用Parallel Scanvenge收集器</p><p>开启该参数后：新生代使用复制算法，老年代使用标记-整理算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParallelGC</span><br></pre></td></tr></table></figure><h2 id="老年代下的垃圾收集器"><a href="#老年代下的垃圾收集器" class="headerlink" title="老年代下的垃圾收集器"></a>老年代下的垃圾收集器</h2><h3 id="串行GC（Serial-Old）-Serial-MSC"><a href="#串行GC（Serial-Old）-Serial-MSC" class="headerlink" title="串行GC（Serial Old） / (Serial MSC)"></a>串行GC（Serial Old） / (Serial MSC)</h3><p>Serial Old是Serial垃圾收集器老年代版本，它同样是一个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的Java虚拟机中默认的老年代垃圾收集器</p><p>在Server模式下，主要有两个用途（了解，版本已经到8及以后）</p><ul><li>在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用（Parallel Scavenge + Serial Old）</li><li>作为老年代版中使用CMS收集器的后备垃圾收集方案。</li></ul><p>配置方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseSerialOldlGC</span><br></pre></td></tr></table></figure><p>该垃圾收集器，目前已经不推荐使用了</p><h3 id="并行GC（Parallel-Old）-（Parallel-MSC）"><a href="#并行GC（Parallel-Old）-（Parallel-MSC）" class="headerlink" title="并行GC（Parallel Old）/ （Parallel MSC）"></a>并行GC（Parallel Old）/ （Parallel MSC）</h3><p>Parallel Old收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，Parallel Old收集器在JDK1.6才开始提供。</p><p>在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配老年代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。在JDK1.6以前(Parallel Scavenge + Serial Old)</p><p>Parallel Old正是为了在老年代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，JDK1.8后可以考虑新生代Parallel Scavenge和老年代Parallel Old 收集器的搭配策略。在JDK1.8及后（Parallel Scavenge + Parallel Old）</p><p>JVM常用参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX +UseParallelOldGC：使用Parallel Old收集器，设置该参数后，新生代Parallel+老年代 Parallel Old</span><br></pre></td></tr></table></figure><p><img data-src="image-20200325211525152.png" alt="image"></p><p>使用老年代并行收集器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:PrintGCDetails -XX:+PrintConmandLineFlags -XX:+UseParallelOldlGC</span><br></pre></td></tr></table></figure><h3 id="并发标记清除GC（CMS）"><a href="#并发标记清除GC（CMS）" class="headerlink" title="并发标记清除GC（CMS）"></a>并发标记清除GC（CMS）</h3><p>CMS收集器（Concurrent Mark Sweep：并发标记清除）是一种以最短回收停顿时间为目标的收集器</p><p>适合应用在互联网或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短。</p><p>CMS非常适合堆内存大，CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。</p><p><img data-src="image-20200325212836441.png" alt="image"></p><p>Concurrent Mark Sweep：并发标记清除，并发收集低停顿，并发指的是与用户线程一起执行</p><p>开启该收集器的JVM参数： -XX:+UseConcMarkSweepGC  开启该参数后，会自动将 -XX:+UseParNewGC打开，开启该参数后，使用ParNew(young 区用）+ CMS（Old 区用） + Serial Old 的收集器组合，Serial Old将作为CMS出错的后备收集器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><h4 id="四个步骤"><a href="#四个步骤" class="headerlink" title="四个步骤"></a>四个步骤</h4><ul><li>初始标记（CMS initial mark）<ul><li>只是标记一个GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程</li></ul></li><li>并发标记（CMS concurrent mark）和用户线程一起<ul><li>进行GC Roots跟踪过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象</li></ul></li><li>重新标记（CMS remark）<ul><li>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程，由于并发标记时，用户线程依然运行，因此在正式清理前，在做修正</li></ul></li><li>并发清除（CMS concurrent sweep）和用户线程一起<ul><li>清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。基于标记结果，直接清理对象，由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。</li></ul></li></ul><p><img data-src="image-20200325215401981.png" alt="image"></p><p>优点：并发收集低停顿</p><p>缺点：并发执行，对CPU资源压力大，采用的标记清除算法会导致大量碎片</p><p>由于并发进行，CMS在收集与应用线程会同时增加对堆内存的占用，也就是说，CMS必须在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW方式进行一次GC，从而造成较大的停顿时间</p><p>标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩，CMS也提供了参数 -XX:CMSFullGCSBeForeCompaction（默认0，即每次都进行内存整理）来指定多少次CMS收集之后，进行一次压缩的Full GC</p><h2 id="垃圾收集器如何选择"><a href="#垃圾收集器如何选择" class="headerlink" title="垃圾收集器如何选择"></a>垃圾收集器如何选择</h2><h3 id="组合的选择"><a href="#组合的选择" class="headerlink" title="组合的选择"></a>组合的选择</h3><ul><li>单CPU或者小内存，单机程序<ul><li>-XX:+UseSerialGC</li></ul></li><li>多CPU，需要最大的吞吐量，如后台计算型应用<ul><li>-XX:+UseParallelGC（这两个相互激活）</li><li>-XX:+UseParallelOldGC</li></ul></li><li>多CPU，追求低停顿时间，需要快速响应如互联网应用<ul><li>-XX:+UseConcMarkSweepGC</li><li>-XX:+ParNewGC</li></ul></li></ul><table><thead><tr><th align="center">参数</th><th align="center">新生代垃圾收集器</th><th align="center">新生代算法</th><th align="center">老年代垃圾收集器</th><th align="center">老年代算法</th></tr></thead><tbody><tr><td align="center">-XX:+UseSerialGC</td><td align="center">SerialGC</td><td align="center">复制</td><td align="center">SerialOldGC</td><td align="center">标记整理</td></tr><tr><td align="center">-XX:+UseParNewGC</td><td align="center">ParNew</td><td align="center">复制</td><td align="center">SerialOldGC</td><td align="center">标记整理</td></tr><tr><td align="center">-XX:+UseParallelGC</td><td align="center">Parallel [Scavenge]</td><td align="center">复制</td><td align="center">Parallel Old</td><td align="center">标记整理</td></tr><tr><td align="center">-XX:+UseConcMarkSweepGC</td><td align="center">ParNew</td><td align="center">复制</td><td align="center">CMS + Serial Old的收集器组合，Serial Old作为CMS出错的后备收集器</td><td align="center">标记清除</td></tr><tr><td align="center">-XX:+UseG1GC</td><td align="center">G1整体上采用标记整理算法</td><td align="center">局部复制</td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h2><p><img data-src="image-20200326115120405.png" alt="image"></p><h3 id="开启G1垃圾收集器"><a href="#开启G1垃圾收集器" class="headerlink" title="开启G1垃圾收集器"></a>开启G1垃圾收集器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure><h3 id="以前收集器的特点"><a href="#以前收集器的特点" class="headerlink" title="以前收集器的特点"></a>以前收集器的特点</h3><ul><li>年轻代和老年代是各自独立且连续的内存块</li><li>年轻代收集使用单eden + S0 + S1 进行复制算法</li><li>老年代收集必须扫描珍整个老年代区域</li><li>都是以尽可能少而快速地执行GC为设计原则</li></ul><h3 id="G1是什么"><a href="#G1是什么" class="headerlink" title="G1是什么"></a>G1是什么</h3><p>G1：Garbage-First 收集器，是一款面向服务端应用的收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能满足垃圾收集暂停时间的要求。另外，它还具有一下特征：</p><ul><li>像CMS收集器一样，能与应用程序并发执行</li><li>整理空闲空间更快</li><li>需要更多的时间来预测GC停顿时间</li><li>不希望牺牲大量的吞吐量性能</li><li>不需要更大的Java Heap</li></ul><p>G1收集器设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色</p><ul><li>G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。</li><li>G1的Stop The World（STW）更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</li></ul><p>CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是它还存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器-G1垃圾收集器</p><p>G1是在2012奶奶才在JDK1.7中可用，Oracle官方计划在JDK9中将G1变成默认的垃圾收集器以替代CMS，它是一款面向服务端应用的收集器，主要应用在多CPU和大内存服务器环境下，极大减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换Java8以前的CMS收集器</p><p>主要改变时：Eden，Survivor和Tenured等内存区域不再是连续了，而是变成一个个大小一样的region，每个region从1M到32M不等。一个region有可能属于Eden，Survivor或者Tenured内存区域。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>G1能充分利用多CPU，多核环境硬件优势，尽量缩短STW</li><li>G1整体上采用标记-整理算法，局部是通过复制算法，不会产生内存碎片</li><li>宏观上看G1之中不再区分年轻代和老年代。把内存划分成多个独立的子区域（Region），可以近似理解为一个围棋的棋盘</li><li>G1收集器里面将整个内存区域都混合在一起了，但其本身依然在小范围内要进行年轻代和老年代的区分，保留了新生代和老年代，但他们不再是物理隔离的，而是通过一部分Region的集合且不需要Region是连续的，也就是说依然会采取不同的GC方式来处理不同的区域</li><li>G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代和老年代的区别，也不需要完全独立的Survivor（to space）堆做复制准备，G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换。</li></ul><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>Region区域化垃圾收集器，化整为零，打破了原来新生区和老年区的壁垒，避免了全内存扫描，只需要按照区域来进行扫描即可。</p><p>区域化内存划片Region，整体遍为了一些列不连续的内存区域，避免了全内存区的GC操作。</p><p>核心思想是将整个堆内存区域分成大小相同的子区域（Region），在JVM启动时会自动设置子区域大小</p><p>在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可，每个分区也不会固定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code> 可指定分区大小（1MB~32MB，且必须是2的幂），默认将整堆划分为2048个分区。</p><p>大小范围在1MB~32MB，最多能设置2048个区域，也即能够支持的最大内存为：32MB*2048 = 64G内存</p><p>Region区域化垃圾收集器</p><h3 id="Region区域化垃圾收集器"><a href="#Region区域化垃圾收集器" class="headerlink" title="Region区域化垃圾收集器"></a>Region区域化垃圾收集器</h3><p>G1将新生代、老年代的物理空间划分取消了</p><p><img data-src="image-20200326120105859.png" alt="image"></p><p>同时对内存进行了区域划分</p><p><img data-src="image-20200326120130427.png" alt="image"></p><p>G1算法将堆划分为若干个区域（Reign），它仍然属于分代收集器，这些Region的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间</p><p>这些Region的一部分包含老年代，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有CMS内存碎片的问题存在了。</p><p>在G1中，还有一种特殊的区域，叫做Humongous（巨大的）区域，如果一个对象占用了空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象，这些巨型对象默认直接分配在老年代，但是如果他是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响，为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H区来存储，为了能找到连续的H区，有时候不得不启动Full GC。</p><h3 id="回收步骤"><a href="#回收步骤" class="headerlink" title="回收步骤"></a>回收步骤</h3><p>针对Eden区进行收集，Eden区耗尽后会被触发，主要是小区域收集 + 形成连续的内存块，避免内碎片</p><ul><li>Eden区的数据移动到Survivor区，加入出现Survivor区空间不够，Eden区数据会晋升到Old区</li><li>Survivor区的数据移动到新的Survivor区，部分数据晋升到Old区</li><li>最后Eden区收拾干净了，GC结束，用户的应用程序继续执行</li></ul><p><img data-src="image-20200326121409237.png" alt="image"></p><p>回收完成后</p><p><img data-src="image-20200326121622208.png" alt="image"></p><p>小区域收集 + 形成连续的内存块，最后在收集完成后，就会形成连续的内存空间，这样就解决了内存碎片的问题</p><h3 id="四步过程"><a href="#四步过程" class="headerlink" title="四步过程"></a>四步过程</h3><ul><li>初始标记：只标记GC Roots能直接关联到的对象</li><li>并发标记：进行GC Roots Tracing（链路扫描）的过程</li><li>最终标记：修正并发标记期间，因为程序运行导致标记发生变化的那一部分对象</li><li>筛选回收：根据时间来进行价值最大化回收</li></ul><p><img data-src="image-20200326121914326.png" alt="image"></p><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>开发人员仅仅需要申明以下参数即可</p><p>三步归纳：<code>-XX:+UseG1GC  -Xmx32G  -XX:MaxGCPauseMillis=100</code></p><p>-XX:MaxGCPauseMillis=n：最大GC停顿时间单位毫秒，这是个软目标，JVM尽可能停顿小于这个时间</p><h3 id="G1和CMS比较"><a href="#G1和CMS比较" class="headerlink" title="G1和CMS比较"></a>G1和CMS比较</h3><ul><li>G1不会产生内碎片</li><li>是可以精准控制停顿。该收集器是把整个堆（新生代、老年代）划分成多个固定大小的区域，每次根据允许停顿的时间去收集垃圾最多的区域。</li></ul><h2 id="SpringBoot结合JVM-GC"><a href="#SpringBoot结合JVM-GC" class="headerlink" title="SpringBoot结合JVM GC"></a>SpringBoot结合JVM GC</h2><p>启动微服务时候，就可以带上JVM和GC的参数</p><ul><li>IDEA开发完微服务工程</li><li>maven进行clean package</li><li>要求微服务启动的时候，同时配置我们的JVM/GC的调优参数</li><li>我们就可以根据具体的业务配置我们启动的JVM参数</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms1024m -Xmx1024 -XX:UseG1GC -jar   xxx.jar</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java垃圾回收 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存溢出OOM</title>
      <link href="/2019/10/10/Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BAOOM/"/>
      <url>/2019/10/10/Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BAOOM/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存溢出OOM"><a href="#Java内存溢出OOM" class="headerlink" title="Java内存溢出OOM"></a>Java内存溢出OOM</h1><h2 id="经典错误"><a href="#经典错误" class="headerlink" title="经典错误"></a>经典错误</h2><p>JVM中常见的两个错误</p><p>StackoverFlowError ：栈溢出</p><p>OutofMemoryError: java heap space：堆溢出</p><a id="more"></a><p>除此之外，还有以下的错误</p><ul><li>java.lang.StackOverflowError</li><li>java.lang.OutOfMemoryError：java heap space</li><li>java.lang.OutOfMemoryError：GC overhead limit exceeeded</li><li>java.lang.OutOfMemoryError：Direct buffer memory</li><li>java.lang.OutOfMemoryError：unable to create new native thread</li><li>java.lang.OutOfMemoryError：Metaspace</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>OutOfMemoryError和StackOverflowError是属于Error，不是Exception</p><p><img data-src="image-20200324144802828.png" alt="image-1"></p><h2 id="StackoverFlowError"><a href="#StackoverFlowError" class="headerlink" title="StackoverFlowError"></a>StackoverFlowError</h2><p>堆栈溢出，我们有最简单的一个递归调用，就会造成堆栈溢出，也就是深度的方法调用</p><p>栈一般是512K，不断的深度调用，直到栈被撑破</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class StackOverflowErrorDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        stackOverflowError();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈一般是512K，不断的深度调用，直到栈被撑破</span><br><span class="line">     * Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void stackOverflowError() &#123;</span><br><span class="line">        stackOverflowError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">at com.moxi.interview.study.oom.StackOverflowErrorDemo.stackOverflowError(StackOverflowErrorDemo.java:17)</span><br></pre></td></tr></table></figure><h2 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h2><h3 id="java-heap-space"><a href="#java-heap-space" class="headerlink" title="java heap space"></a>java heap space</h3><p>创建了很多对象，导致堆空间不够存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Java堆内存不足</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JavaHeapSpaceDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 堆空间的大小 -Xms10m -Xmx10m</span><br><span class="line">        &#x2F;&#x2F; 创建一个 80M的字节数组</span><br><span class="line">        byte [] bytes &#x3D; new byte[80 * 1024 * 1024];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建一个80M的数组，会直接出现Java heap space</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><h3 id="GC-overhead-limit-exceeded"><a href="#GC-overhead-limit-exceeded" class="headerlink" title="GC overhead limit exceeded"></a>GC overhead limit exceeded</h3><p>GC回收时间过长时会抛出OutOfMemoryError，过长的定义是，超过了98%的时间用来做GC，并且回收了不到2%的堆内存</p><p>连续多次GC都只回收了不到2%的极端情况下，才会抛出。假设不抛出GC overhead limit 错误会造成什么情况呢？</p><p>那就是GC清理的这点内存很快会再次被填满，迫使GC再次执行，这样就形成了恶性循环，CPU的使用率一直都是100%，而GC却没有任何成果。</p><p><img data-src="image-20200324150646260.png" alt="image1"></p><p>代码演示：</p><p>为了更快的达到效果，我们首先需要设置JVM启动参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize&#x3D;5m</span><br></pre></td></tr></table></figure><p>这个异常出现的步骤就是，我们不断的像list中插入String对象，直到启动GC回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * GC 回收超时</span><br><span class="line"> * JVM参数配置: -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize&#x3D;5m</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class GCOverheadLimitDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                list.add(String.valueOf(++i).intern());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;***************i:&quot; + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;2047K(2560K)] [ParOldGen: 7106K-&gt;7106K(7168K)] 9154K-&gt;9154K(9728K), [Metaspace: 3504K-&gt;3504K(1056768K)], 0.0311093 secs] [Times: user&#x3D;0.13 sys&#x3D;0.00, real&#x3D;0.03 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2047K-&gt;0K(2560K)] [ParOldGen: 7136K-&gt;667K(7168K)] 9184K-&gt;667K(9728K), [Metaspace: 3540K-&gt;3540K(1056768K)], 0.0058093 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 114K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 5% used [0x00000000ffd00000,0x00000000ffd1c878,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line"> ParOldGen       total 7168K, used 667K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 9% used [0x00000000ff600000,0x00000000ff6a6ff8,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 3605K, capacity 4540K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 399K, capacity 428K, committed 512K, reserved 1048576K</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">at java.lang.Integer.toString(Integer.java:403)</span><br><span class="line">at java.lang.String.valueOf(String.java:3099)</span><br><span class="line">at com.moxi.interview.study.oom.GCOverheadLimitDemo.main(GCOverheadLimitDemo.java:18)</span><br></pre></td></tr></table></figure><p>我们能够看到 多次Full GC，并没有清理出空间，在多次执行GC操作后，就抛出异常 GC overhead limit</p><h3 id="Direct-buffer-memory"><a href="#Direct-buffer-memory" class="headerlink" title="Direct buffer memory"></a>Direct buffer memory</h3><p>Netty + NIO：这是由于NIO引起的</p><p>写NIO程序的时候经常会使用ByteBuffer来读取或写入数据，这是一种基于通道(Channel) 与 缓冲区(Buffer)的I/O方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>ByteBuffer.allocate(capability)：第一种方式是分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度相对较慢</p><p>ByteBuffer.allocteDirect(capability)：第二种方式是分配OS本地内存，不属于GC管辖范围，由于不需要内存的拷贝，所以速度相对较快</p><p>但如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象就不会被回收，这时候怼内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那么程序就奔溃了。</p><p>一句话说：本地内存不足，但是堆内存充足的时候，就会出现这个问题</p><p>我们使用 -XX:MaxDirectMemorySize=5m 配置能使用的堆外物理内存为5M</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize&#x3D;5m</span><br></pre></td></tr></table></figure><p>然后我们申请一个6M的空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 只设置了5M的物理内存使用，但是却分配 6M的空间</span><br><span class="line">ByteBuffer bb &#x3D; ByteBuffer.allocateDirect(6 * 1024 * 1024);</span><br></pre></td></tr></table></figure><p>这个时候，运行就会出现问题了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">配置的maxDirectMemory：5.0MB</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 2030K-&gt;488K(2560K)] 2030K-&gt;796K(9728K), 0.0008326 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 488K-&gt;0K(2560K)] [ParOldGen: 308K-&gt;712K(7168K)] 796K-&gt;712K(9728K), [Metaspace: 3512K-&gt;3512K(1056768K)], 0.0052052 secs] [Times: user&#x3D;0.09 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">at java.nio.Bits.reserveMemory(Bits.java:693)</span><br><span class="line">at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)</span><br><span class="line">at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)</span><br><span class="line">at com.moxi.interview.study.oom.DIrectBufferMemoryDemo.main(DIrectBufferMemoryDemo.java:19)</span><br></pre></td></tr></table></figure><h3 id="unable-to-create-new-native-thread"><a href="#unable-to-create-new-native-thread" class="headerlink" title="unable to create new native thread"></a>unable to create new native thread</h3><p>不能够创建更多的新的线程了，也就是说创建线程的上限达到了</p><p>在高并发场景的时候，会应用到</p><p>高并发请求服务器时，经常会出现如下异常<code>java.lang.OutOfMemoryError:unable to create new native thread</code>，准确说该native thread异常与对应的平台有关</p><p>导致原因：</p><ul><li>应用创建了太多线程，一个应用进程创建多个线程，超过系统承载极限</li><li>服务器并不允许你的应用程序创建这么多线程，linux系统默认运行单个进程可以创建的线程为1024个，如果应用创建超过这个数量，就会报 <code>java.lang.OutOfMemoryError:unable to create new native thread</code></li></ul><p>解决方法：</p><ol><li>想办法降低你应用程序创建线程的数量，分析应用是否真的需要创建这么多线程，如果不是，改代码将线程数降到最低</li><li>对于有的应用，确实需要创建很多线程，远超过linux系统默认1024个线程限制，可以通过修改linux服务器配置，扩大linux默认限制</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 无法创建更多的线程</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class UnableCreateNewThreadDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; ; i++) &#123;</span><br><span class="line">            System.out.println(&quot;************** i &#x3D; &quot; + i);</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，就会出现下列的错误，线程数大概在 900多个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to cerate new native thread</span><br></pre></td></tr></table></figure><p>如何查看线程数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -u</span><br></pre></td></tr></table></figure><h3 id="Metaspace"><a href="#Metaspace" class="headerlink" title="Metaspace"></a>Metaspace</h3><p>元空间内存不足，Matespace元空间应用的是本地内存</p><p><code>-XX:MetaspaceSize</code> 的处理化大小为20M</p><h4 id="元空间是什么"><a href="#元空间是什么" class="headerlink" title="元空间是什么"></a>元空间是什么</h4><p>元空间就是我们的方法区，存放的是类模板，类信息，常量池等</p><p>Metaspace是方法区HotSpot中的实现，它与持久代最大的区别在于：Metaspace并不在虚拟内存中，而是使用本地内存，也即在java8中，class metadata（the virtual machines internal presentation of Java class），被存储在叫做Matespace的native memory</p><p>永久代（java8后背元空间Metaspace取代了）存放了以下信息：</p><ul><li>虚拟机加载的类信息</li><li>常量池</li><li>静态变量</li><li>即时编译后的代码</li></ul><p>模拟Metaspace空间溢出，我们不断生成类 往元空间里灌输，类占据的空间总会超过Metaspace指定的空间大小</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>在模拟异常生成时候，因为初始化的元空间为20M，因此我们使用JVM参数调整元空间的大小，为了更好的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize&#x3D;8m -XX:MaxMetaspaceSize&#x3D;8m</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 元空间溢出</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MetaspaceOutOfMemoryDemo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态类</span><br><span class="line">    static class OOMTest &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(final String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟计数多少次以后发生异常</span><br><span class="line">        int i &#x3D;0;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                &#x2F;&#x2F; 使用Spring的动态字节码技术</span><br><span class="line">                Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">                enhancer.setSuperclass(OOMTest.class);</span><br><span class="line">                enhancer.setUseCache(false);</span><br><span class="line">                enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">                        return methodProxy.invokeSuper(o, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;发生异常的次数:&quot; + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发生异常的次数: 201</span><br><span class="line">java.lang.OutOfMemoryError:Metaspace</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> OOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的强引用、软引用、弱引用、虚引用</title>
      <link href="/2019/10/10/Java%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/"/>
      <url>/2019/10/10/Java%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的引用"><a href="#Java中的引用" class="headerlink" title="Java中的引用"></a>Java中的引用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在原来的时候，我们谈到一个类的实例化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p &#x3D; new Person()</span><br></pre></td></tr></table></figure><p>在等号的左边，就是一个对象的引用，存储在栈中</p><p>而等号右边，就是实例化的对象，存储在堆中</p><p>其实这样的一个引用关系，就被称为强引用</p><a id="more"></a><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img data-src="image-20200323155120778.png" alt="image1"></p><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>当内存不足的时候，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收，打死也不回收~！</p><p>强引用是我们最常见的普通对象引用，只要还有一个强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到，JVM也不会回收，因此强引用是造成Java内存泄漏的主要原因之一。</p><p>对于一个普通的对象，如果没有其它的引用关系，只要超过了引用的作用于或者显示地将相应（强）引用赋值为null，一般可以认为就是可以被垃圾收集的了（当然具体回收时机还是要看垃圾回收策略）</p><p>强引用小例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 强引用</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class StrongReferenceDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这样定义的默认就是强应用</span><br><span class="line">        Object obj1 &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 使用第二个引用，指向刚刚创建的Object对象</span><br><span class="line">        Object obj2 &#x3D; obj1;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 置空</span><br><span class="line">        obj1 &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 垃圾回收</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(obj1);</span><br><span class="line"></span><br><span class="line">        System.out.println(obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果我们能够发现，即使 obj1 被设置成了null，然后调用gc进行回收，但是也没有回收实例出来的对象，obj2还是能够指向该地址，也就是说垃圾回收器，并没有将该对象进行垃圾回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">java.lang.Object@14ae5a5</span><br></pre></td></tr></table></figure><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用是一种相对弱化了一些的引用，需要用Java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集，对于只有软引用的对象来讲：</p><ul><li>当系统内存充足时，它不会被回收</li><li>当系统内存不足时，它会被回收</li></ul><p>软引用通常在对内存敏感的程序中，比如高速缓存就用到了软引用，内存够用 的时候就保留，不够用就回收</p><p>具体使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 软引用</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SoftReferenceDemo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 内存够用的时候</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void softRefMemoryEnough() &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建一个强应用</span><br><span class="line">        Object o1 &#x3D; new Object();</span><br><span class="line">        &#x2F;&#x2F; 创建一个软引用</span><br><span class="line">        SoftReference&lt;Object&gt; softReference &#x3D; new SoftReference&lt;&gt;(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">        o1 &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 手动GC</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * JVM配置，故意产生大对象并配置小的内存，让它的内存不够用了导致OOM，看软引用的回收情况</span><br><span class="line">     * -Xms5m -Xmx5m -XX:+PrintGCDetails</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void softRefMemoryNoEnough() &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        &#x2F;&#x2F; 创建一个强应用</span><br><span class="line">        Object o1 &#x3D; new Object();</span><br><span class="line">        &#x2F;&#x2F; 创建一个软引用</span><br><span class="line">        SoftReference&lt;Object&gt; softReference &#x3D; new SoftReference&lt;&gt;(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">        o1 &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 模拟OOM自动GC</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 创建30M的大对象</span><br><span class="line">            byte[] bytes &#x3D; new byte[30 * 1024 * 1024];</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(softReference.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        softRefMemoryEnough();</span><br><span class="line"></span><br><span class="line">        softRefMemoryNoEnough();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们写了两个方法，一个是内存够用的时候，一个是内存不够用的时候</p><p>我们首先查看内存够用的时候，首先输出的是 o1 和 软引用的 softReference，我们都能够看到值</p><p>然后我们把o1设置为null，执行手动GC后，我们发现softReference的值还存在，说明内存充足的时候，软引用的对象不会被回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">java.lang.Object@14ae5a5</span><br><span class="line"></span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1396K-&gt;504K(1536K)] 1504K-&gt;732K(5632K), 0.0007842 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 504K-&gt;0K(1536K)] [ParOldGen: 228K-&gt;651K(4096K)] 732K-&gt;651K(5632K), [Metaspace: 3480K-&gt;3480K(1056768K)], 0.0058450 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line"></span><br><span class="line">null</span><br><span class="line">java.lang.Object@14ae5a5</span><br></pre></td></tr></table></figure><p>下面我们看当内存不够的时候，我们使用了JVM启动参数配置，给初始化堆内存为5M</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms5m -Xmx5m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>但是在创建对象的时候，我们创建了一个30M的大对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建30M的大对象</span><br><span class="line">byte[] bytes &#x3D; new byte[30 * 1024 * 1024];</span><br></pre></td></tr></table></figure><p>这就必然会触发垃圾回收机制，这也是中间出现的垃圾回收过程，最后看结果我们发现，o1 和 softReference都被回收了，因此说明，软引用在内存不足的时候，会自动回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@7f31245a</span><br><span class="line">java.lang.Object@7f31245a</span><br><span class="line"></span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 31K-&gt;160K(1536K)] 682K-&gt;811K(5632K), 0.0003603 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 160K-&gt;96K(1536K)] 811K-&gt;747K(5632K), 0.0006385 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 96K-&gt;0K(1536K)] [ParOldGen: 651K-&gt;646K(4096K)] 747K-&gt;646K(5632K), [Metaspace: 3488K-&gt;3488K(1056768K)], 0.0067976 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 646K-&gt;646K(5632K), 0.0004024 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] [ParOldGen: 646K-&gt;627K(4096K)] 646K-&gt;627K(5632K), [Metaspace: 3488K-&gt;3488K(1056768K)], 0.0065506 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line"></span><br><span class="line">null</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>不管内存是否够，只要有GC操作就会进行回收</p><p>弱引用需要用 <code>java.lang.ref.WeakReference</code> 类来实现，它比软引用生存期更短</p><p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 弱引用</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class WeakReferenceDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object o1 &#x3D; new Object();</span><br><span class="line">        WeakReference&lt;Object&gt; weakReference &#x3D; new WeakReference&lt;&gt;(o1);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        o1 &#x3D; null;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看结果，能够发现，我们并没有制造出OOM内存溢出，而只是调用了一下GC操作，垃圾回收就把它给收集了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">java.lang.Object@14ae5a5</span><br><span class="line"></span><br><span class="line">[GC (System.gc()) [PSYoungGen: 5246K-&gt;808K(76288K)] 5246K-&gt;816K(251392K), 0.0008236 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 808K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;675K(175104K)] 816K-&gt;675K(251392K), [Metaspace: 3494K-&gt;3494K(1056768K)], 0.0035953 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line"></span><br><span class="line">null</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h2 id="软引用和弱引用的使用场景"><a href="#软引用和弱引用的使用场景" class="headerlink" title="软引用和弱引用的使用场景"></a>软引用和弱引用的使用场景</h2><p>场景：假如有一个应用需要读取大量的本地图片</p><ul><li>如果每次读取图片都从硬盘读取则会严重影响性能</li><li>如果一次性全部加载到内存中，又可能造成内存溢出</li></ul><p>此时使用软引用可以解决这个问题</p><p>设计思路：使用HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占的空间，从而有效地避免了OOM的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, SoftReference&lt;String&gt;&gt; imageCache &#x3D; new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="WeakHashMap是什么？"><a href="#WeakHashMap是什么？" class="headerlink" title="WeakHashMap是什么？"></a>WeakHashMap是什么？</h3><p>比如一些常常和底层打交道的，mybatis等，底层都应用到了WeakHashMap</p><p>WeakHashMap和HashMap类似，只不过它的Key是使用了弱引用的，也就是说，当执行GC的时候，HashMap中的key会进行回收，下面我们使用例子来测试一下</p><p>我们使用了两个方法，一个是普通的HashMap方法</p><p>我们输入一个Key-Value键值对，然后让它的key置空，然后在查看结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static void myHashMap() &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    Integer key &#x3D; new Integer(1);</span><br><span class="line">    String value &#x3D; &quot;HashMap&quot;;</span><br><span class="line"></span><br><span class="line">    map.put(key, value);</span><br><span class="line">    System.out.println(map);</span><br><span class="line"></span><br><span class="line">    key &#x3D; null;</span><br><span class="line"></span><br><span class="line">    System.gc();</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个是使用了WeakHashMap，完整代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * WeakHashMap</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class WeakHashMapDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        myHashMap();</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        myWeakHashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void myHashMap() &#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        Integer key &#x3D; new Integer(1);</span><br><span class="line">        String value &#x3D; &quot;HashMap&quot;;</span><br><span class="line"></span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        key &#x3D; null;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void myWeakHashMap() &#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map &#x3D; new WeakHashMap&lt;&gt;();</span><br><span class="line">        Integer key &#x3D; new Integer(1);</span><br><span class="line">        String value &#x3D; &quot;WeakHashMap&quot;;</span><br><span class="line"></span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        key &#x3D; null;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;1&#x3D;HashMap&#125;</span><br><span class="line">&#123;1&#x3D;HashMap&#125;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#123;1&#x3D;WeakHashMap&#125;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>从这里我们看到，对于普通的HashMap来说，key置空并不会影响，HashMap的键值对，因为这个属于强引用，不会被垃圾回收。</p><p>但是WeakHashMap，在进行GC操作后，弱引用的就会被回收</p><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>虚引用又称为幽灵引用，需要<code>java.lang.ref.PhantomReference</code> 类来实现</p><p>顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。</p><p>如果一个对象持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列ReferenceQueue联合使用。</p><p>虚引用的主要作用和跟踪对象被垃圾回收的状态，仅仅是提供一种确保对象被finalize以后，做某些事情的机制。</p><p>PhantomReference的get方法总是返回null，因此无法访问对象的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作</p><p>换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候，收到一个系统通知或者后续添加进一步的处理，Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前，做必要的清理工作</p><p>这个就相当于Spring AOP里面的后置通知</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>一般用于在回收时候做通知相关操作</p><h2 id="引用队列-ReferenceQueue"><a href="#引用队列-ReferenceQueue" class="headerlink" title="引用队列 ReferenceQueue"></a>引用队列 ReferenceQueue</h2><p>软引用，弱引用，虚引用在回收之前，需要在引用队列保存一下</p><p>我们在初始化的弱引用或者虚引用的时候，可以传入一个引用队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object o1 &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建引用队列</span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个弱引用</span><br><span class="line">WeakReference&lt;Object&gt; weakReference &#x3D; new WeakReference&lt;&gt;(o1, referenceQueue);</span><br></pre></td></tr></table></figure><p>那么在进行GC回收的时候，弱引用和虚引用的对象都会被回收，但是在回收之前，它会被送至引用队列中</p><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 虚引用</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class PhantomReferenceDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Object o1 &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建引用队列</span><br><span class="line">        ReferenceQueue&lt;Object&gt; referenceQueue &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建一个弱引用</span><br><span class="line">        WeakReference&lt;Object&gt; weakReference &#x3D; new WeakReference&lt;&gt;(o1, referenceQueue);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建一个弱引用</span><br><span class="line">&#x2F;&#x2F;        PhantomReference&lt;Object&gt; weakReference &#x3D; new PhantomReference&lt;&gt;(o1, referenceQueue);</span><br><span class="line"></span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        &#x2F;&#x2F; 取队列中的内容</span><br><span class="line">        System.out.println(referenceQueue.poll());</span><br><span class="line"></span><br><span class="line">        o1 &#x3D; null;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(&quot;执行GC操作&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        &#x2F;&#x2F; 取队列中的内容</span><br><span class="line">        System.out.println(referenceQueue.poll());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">java.lang.Object@14ae5a5</span><br><span class="line">null</span><br><span class="line">执行GC操作</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">java.lang.ref.WeakReference@7f3124</span><br></pre></td></tr></table></figure><p>从这里我们能看到，在进行垃圾回收后，我们弱引用对象，也被设置成null，但是在队列中还能够导出该引用的实例，这就说明在回收之前，该弱引用的实例被放置引用队列中了，我们可以通过引用队列进行一些后置操作</p><h2 id="GCRoots和四大引用小总结"><a href="#GCRoots和四大引用小总结" class="headerlink" title="GCRoots和四大引用小总结"></a>GCRoots和四大引用小总结</h2><ul><li><p>红色部分在垃圾回收之外，也就是强引用的</p></li><li><p>蓝色部分：属于软引用，在内存不够的时候，才回收</p></li><li><p>虚引用和弱引用：每次垃圾回收的时候，都会被干掉，但是它在干掉之前还会存在引用队列中，我们可以通过引用队列进行一些通知机制</p></li></ul><p><img data-src="image-20200324123829937.png" alt="image-2"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM之参数调优</title>
      <link href="/2019/10/10/JVM%E4%B9%8B%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/"/>
      <url>/2019/10/10/JVM%E4%B9%8B%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM之参数调优"><a href="#JVM之参数调优" class="headerlink" title="JVM之参数调优"></a>JVM之参数调优</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你说你做过JVM调优和参数配置，请问如何盘点查看JVM系统默认值</p><p>使用jps和jinfo进行查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xms：初始堆空间</span><br><span class="line">-Xmx：堆最大值</span><br><span class="line">-Xss：栈空间</span><br></pre></td></tr></table></figure><p>-Xms 和 -Xmx最好调整一致，防止JVM频繁进行收集和回收</p><a id="more"></a><h2 id="JVM参数类型"><a href="#JVM参数类型" class="headerlink" title="JVM参数类型"></a>JVM参数类型</h2><ul><li>标配参数（从JDK1.0 - Java12都在，很稳定）<ul><li>-version</li><li>-help</li><li>java -showversion</li></ul></li><li>X参数（了解）<ul><li>-Xint：解释执行</li><li>-Xcomp：第一次使用就编译成本地代码</li><li>-Xmixed：混合模式</li></ul></li><li>XX参数（重点）<ul><li>Boolean类型<ul><li>公式：-XX:+ 或者-某个属性   + 表示开启，-表示关闭</li><li>Case：-XX:-PrintGCDetails：表示关闭了GC详情输出</li></ul></li><li>key-value类型<ul><li>公式：-XX:属性key=属性value</li><li>不满意初始值，可以通过下列命令调整</li><li>case：如何：-XX:MetaspaceSize=21807104：查看Java元空间的值</li></ul></li></ul></li></ul><h2 id="查看运行的Java程序，JVM参数是否开启，具体值为多少？"><a href="#查看运行的Java程序，JVM参数是否开启，具体值为多少？" class="headerlink" title="查看运行的Java程序，JVM参数是否开启，具体值为多少？"></a>查看运行的Java程序，JVM参数是否开启，具体值为多少？</h2><p>首先我们运行一个HelloGC的java程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ylyang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello GC"</span>);</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用下列命令查看它的默认参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps：查看java的后台进程</span><br><span class="line">jinfo：查看正在运行的java程序</span><br></pre></td></tr></table></figure><p>具体使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l得到进程号</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">12608 com.moxi.interview.study.GC.HelloGC</span><br><span class="line">15200 sun.tools.jps.Jps</span><br><span class="line">15296 org.jetbrains.idea.maven.server.RemoteMavenServer36</span><br><span class="line">4528</span><br><span class="line">12216 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">9772 org.jetbrains.kotlin.daemon.KotlinCompileDaemon</span><br></pre></td></tr></table></figure><p>查看到HelloGC的进程号为：12608</p><p>我们使用jinfo -flag 然后查看是否开启PrintGCDetails这个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag PrintGCDetails 12608</span><br></pre></td></tr></table></figure><p>得到的内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-PrintGCDetails</span><br></pre></td></tr></table></figure><p>上面提到了，-号表示关闭，即没有开启PrintGCDetails这个参数</p><p>下面我们需要在启动HelloGC的时候，增加 PrintGCDetails这个参数，需要在运行程序的时候配置JVM参数</p><p><img data-src="image-20200319122922264.png" alt="image1"></p><p>然后在VM Options中加入下面的代码，现在+号表示开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>然后在使用jinfo查看我们的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br><span class="line">jinfo -flag PrintGCDetails 13540</span><br></pre></td></tr></table></figure><p>得到的结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>我们看到原来的-号变成了+号，说明我们通过 VM Options配置的JVM参数已经生效了</p><p>使用下列命令，会把jvm的全部默认参数输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flags ***</span><br></pre></td></tr></table></figure><h2 id="题外话（坑题）"><a href="#题外话（坑题）" class="headerlink" title="题外话（坑题）"></a>题外话（坑题）</h2><p>两个经典参数：-Xms  和 -Xmx，这两个参数 如何解释</p><p>这两个参数，还是属于XX参数，因为取了别名</p><ul><li>-Xms  等价于 -XX:InitialHeapSize  ：初始化堆内存（默认只会用最大物理内存的64分1）</li><li>-Xmx 等价于 -XX:MaxHeapSize    ：最大堆内存（默认只会用最大物理内存的4分1）</li></ul><h2 id="查看JVM默认参数"><a href="#查看JVM默认参数" class="headerlink" title="查看JVM默认参数"></a>查看JVM默认参数</h2><ul><li><p>-XX:+PrintFlagsInitial</p><ul><li>主要是查看初始默认值</li><li>公式<ul><li>java -XX:+PrintFlagsInitial -version</li><li>java -XX:+PrintFlagsInitial（重要参数）</li></ul></li></ul><p><img data-src="image-20200320212256284.png" alt="image2"></p></li></ul><ul><li>-XX:+PrintFlagsFinal：表示修改以后，最终的值</li></ul><p>​         会将JVM的各个结果都进行打印</p><p>​         如果有  := 表示修改过的， = 表示没有修改过的</p><h2 id="工作中常用的JVM基本配置参数"><a href="#工作中常用的JVM基本配置参数" class="headerlink" title="工作中常用的JVM基本配置参数"></a>工作中常用的JVM基本配置参数</h2><p><img data-src="image-20200322163252777.png" alt="image3"></p><h3 id="查看堆内存"><a href="#查看堆内存" class="headerlink" title="查看堆内存"></a>查看堆内存</h3><p>查看JVM的初始化堆内存 -Xms 和最大堆内存 Xmx</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ylyang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机中内存的总量</span></span><br><span class="line">        <span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回Java虚拟机中试图使用的最大内存量</span></span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"TOTAL_MEMORY(-Xms) = "</span> + totalMemory + <span class="string">"(字节)、"</span> + (totalMemory / (<span class="keyword">double</span>)<span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">"MB"</span>);</span><br><span class="line">        System.out.println(<span class="string">"MAX_MEMORY(-Xmx) = "</span> + maxMemory + <span class="string">"(字节)、"</span> + (maxMemory / (<span class="keyword">double</span>)<span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">"MB"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TOTAL_MEMORY(-Xms) &#x3D; 257425408(字节)、245.5MB</span><br><span class="line">MAX_MEMORY(-Xmx) &#x3D; 3790077952(字节)、3614.5MB</span><br></pre></td></tr></table></figure><p>-Xms 初始堆内存为：物理内存的1/64          -Xmx 最大堆内存为：系统物理内存的 1/4</p><h3 id="打印JVM默认参数"><a href="#打印JVM默认参数" class="headerlink" title="打印JVM默认参数"></a>打印JVM默认参数</h3><p>使用 <code>-XX:+PrintCommandLineFlags</code> 打印出JVM的默认的简单初始化参数</p><p>比如我的机器输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize&#x3D;266376000 -XX:MaxHeapSize&#x3D;4262016000 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure><h3 id="生活常用调优参数"><a href="#生活常用调优参数" class="headerlink" title="生活常用调优参数"></a>生活常用调优参数</h3><ul><li>-Xms：初始化堆内存，默认为物理内存的1/64，等价于 -XX:initialHeapSize</li><li>-Xmx：最大堆内存，默认为物理内存的1/4，等价于-XX:MaxHeapSize</li><li>-Xss：设计单个线程栈的大小，一般默认为512K~1024K，等价于 -XX:ThreadStackSize<ul><li>使用 jinfo -flag ThreadStackSize   会发现 -XX:ThreadStackSize = 0</li><li>这个值的大小是取决于平台的</li><li>Linux/x64:1024KB</li><li>OS X：1024KB</li><li>Oracle Solaris：1024KB</li><li>Windows：取决于虚拟内存的大小</li></ul></li><li>-Xmn：设置年轻代大小</li><li>-XX:MetaspaceSize：设置元空间大小<ul><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存，因此，默认情况下，元空间的大小仅受本地内存限制。</li><li>-Xms10m -Xmx10m -XX:MetaspaceSize=1024m  -XX:+PrintFlagsFinal</li><li>但是默认的元空间大小：只有20多M</li><li>为了防止在频繁的实例化对象的时候，让元空间出现OOM，因此可以把元空间设置的大一些</li></ul></li><li>-XX:PrintGCDetails：输出详细GC收集日志信息<ul><li>GC</li><li>Full GC</li></ul></li></ul><p>GC日志收集流程图</p><p><img data-src="image-20200322185639902.png" alt="image3"></p><p>我们使用一段代码，制造出垃圾回收的过程</p><p>首先我们设置一下程序的启动配置:  设置初始堆内存为10M，最大堆内存为10M</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><p>然后用下列代码，创建一个 非常大空间的byte类型数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte [] byteArray &#x3D; new byte[50 * 1024 * 1024];</span><br></pre></td></tr></table></figure><p>运行后，发现会出现下列错误，这就是OOM：java内存溢出，也就是堆空间不足</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.moxi.interview.study.GC.HelloGC.main(HelloGC.java:22)</span><br></pre></td></tr></table></figure><p>同时还打印出了GC垃圾回收时候的详情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 1972K-&gt;504K(2560K)] 1972K-&gt;740K(9728K), 0.0156109 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.03 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 504K-&gt;480K(2560K)] 740K-&gt;772K(9728K), 0.0007815 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 480K-&gt;0K(2560K)] [ParOldGen: 292K-&gt;648K(7168K)] 772K-&gt;648K(9728K), [Metaspace: 3467K-&gt;3467K(1056768K)], 0.0080505 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 648K-&gt;648K(9728K), 0.0003035 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 648K-&gt;630K(7168K)] 648K-&gt;630K(9728K), [Metaspace: 3467K-&gt;3467K(1056768K)], 0.0058502 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 80K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 3% used [0x00000000ffd00000,0x00000000ffd143d8,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 7168K, used 630K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 8% used [0x00000000ff600000,0x00000000ff69dbd0,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 3510K, capacity 4500K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 389K, capacity 392K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p>问题发生的原因：</p><p>因为们通过 -Xms10m  和 -Xmx10m 只给Java堆栈设置了10M的空间，但是创建了50M的对象，因此就会出现空间不足，而导致出错</p><p>同时在垃圾收集的时候，我们看到有两个对象：GC 和 Full GC</p><h4 id="GC垃圾收集"><a href="#GC垃圾收集" class="headerlink" title="GC垃圾收集"></a>GC垃圾收集</h4><p>GC在新生区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 1972K-&gt;504K(2560K)] 1972K-&gt;740K(9728K), 0.0156109 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.03 secs]</span><br></pre></td></tr></table></figure><p>GC (Allocation Failure)：表示分配失败，那么就需要触发年轻代空间中的内容被回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PSYoungGen: 1972K-&gt;504K(2560K)] 1972K-&gt;740K(9728K), 0.0156109 secs]</span><br></pre></td></tr></table></figure><p>参数对应的图为：</p><p><img data-src="image-20200323124000865.png" alt="image"></p><h4 id="Full-GC垃圾回收"><a href="#Full-GC垃圾回收" class="headerlink" title="Full GC垃圾回收"></a>Full GC垃圾回收</h4><p>Full GC大部分发生在养老区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 648K-&gt;630K(7168K)] 648K-&gt;630K(9728K), [Metaspace: 3467K-&gt;3467K(1056768K)], 0.0058502 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs]</span><br></pre></td></tr></table></figure><p><img data-src="image-20200323125839653.png" alt="image"></p><p>规律：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[名称： GC前内存占用 -&gt; GC后内存占用 (该区内存总大小)]</span><br></pre></td></tr></table></figure><p>当我们出现了老年代都扛不住的时候，就会出现OOM异常</p><h3 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h3><p>调节新生代中 eden 和 S0、S1的空间比例，默认为 -XX:SuriviorRatio=8，Eden:S0:S1 = 8:1:1</p><p>加入设置成 -XX:SurvivorRatio=4，则为 Eden:S0:S1 = 4:1:1</p><p>SurvivorRatio值就是设置eden区的比例占多少，S0和S1相同</p><p>Java堆从GC的角度还可以细分为：新生代（Eden区，From Survivor区合To Survivor区）和老年代</p><p><img data-src="image-20200323130442088.png" alt="image"></p><ul><li>eden、SurvivorFrom复制到SurvivorTo，年龄 + 1</li></ul><p>首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到SurvivorFrom去，当Eden区再次触发GC的时候会扫描Eden区合From区域，对这两个区域进行垃圾回收，经过这次回收后还存活的对象，则直接复制到To区域（如果对象的年龄已经到达老年的标准，则赋值到老年代区），通知把这些对象的年龄 + 1</p><ul><li>清空eden、SurvivorFrom</li></ul><p>然后，清空eden，SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to</p><ul><li>SurvivorTo和SurvivorFrom互换</li></ul><p>最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认为15），最终如果还是存活，就存入老年代</p><p><img data-src="image-20200323150946414.png" alt="image"></p><h3 id="XX-NewRatio（了解）"><a href="#XX-NewRatio（了解）" class="headerlink" title="-XX:NewRatio（了解）"></a>-XX:NewRatio（了解）</h3><p>配置年轻代new 和老年代old 在堆结构的占比</p><p>默认： -XX:NewRatio=2 新生代占1，老年代2，年轻代占整个堆的1/3</p><p>-XX:NewRatio=4：新生代占1，老年代占4，年轻代占整个堆的1/5，NewRadio值就是设置老年代的占比，剩下的1个新生代</p><p>新生代特别小，会造成频繁的进行GC收集</p><h3 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h3><p>设置垃圾最大年龄，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区，部分对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认为15），最终如果还是存活，就存入老年代</p><p>这里就是调整这个次数的，默认是15，并且设置的值 在 0~15之间</p><p>查看默认进入老年代年龄：jinfo -flag MaxTenuringThreshold 17344</p><p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻对象不经过Survivor区，直接进入老年代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大的值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概念</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> JVM参数调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM之GCRoots</title>
      <link href="/2019/10/10/JVM%E4%B9%8BGCRoots/"/>
      <url>/2019/10/10/JVM%E4%B9%8BGCRoots/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM之GCRoots"><a href="#JVM之GCRoots" class="headerlink" title="JVM之GCRoots"></a>JVM之GCRoots</h1><h2 id="JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC-Roots"><a href="#JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC-Roots" class="headerlink" title="JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC Roots"></a>JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC Roots</h2><h3 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h3><p>简单来说就是内存中已经不再被使用的空间就是垃圾</p><h3 id="如何判断一个对象是否可以被回收"><a href="#如何判断一个对象是否可以被回收" class="headerlink" title="如何判断一个对象是否可以被回收"></a>如何判断一个对象是否可以被回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><a id="more"></a><p>Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。</p><p>因此，很显然一个简单的办法就是通过引用计数来判断一个对象是否可以回收。简单说，给对象中添加一个引用计数器</p><p>每当有一个地方引用它，计数器值加1</p><p>每当有一个引用失效，计数器值减1</p><p>任何时刻计数器值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象。</p><p>那么为什么主流的Java虚拟机里面都没有选用这个方法呢？其中最主要的原因是它很难解决对象之间相互循环引用的问题。</p><p>该算法存在但目前无人用了，解决不了循环引用的问题，了解即可。</p><p><img data-src="image-20200318213301603.png" alt="image-1"></p><h4 id="枚举根节点做可达性分析"><a href="#枚举根节点做可达性分析" class="headerlink" title="枚举根节点做可达性分析"></a>枚举根节点做可达性分析</h4><p>根搜索路径算法</p><p>为了解决引用计数法的循环引用个问题，Java使用了可达性分析的方法：</p><p><img data-src="image-20200319113611244.png" alt="image-2"></p><p>所谓 GC Roots 或者说 Tracing Roots的“根集合” 就是一组必须活跃的引用</p><p>基本思路就是通过一系列名为 GC Roots的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有被遍历到的对象就被判定为死亡</p><p><img data-src="image-20200319114526625.png" alt="image3"></p><p>必须从GC Roots对象开始，这个类似于linux的 /  也就是根目录</p><p>蓝色部分是从GC Roots出发，能够循环可达</p><p>而白色部分，从GC Roots出发，无法到达</p><h4 id="一句话理解GC-Roots"><a href="#一句话理解GC-Roots" class="headerlink" title="一句话理解GC Roots"></a>一句话理解GC Roots</h4><p>假设我们现在有三个实体，分别是 人，狗，毛衣</p><p>然后他们之间的关系是：人 牵着 狗，狗穿着毛衣，他们之间是强连接的关系</p><p>有一天人消失了，只剩下狗狗 和 毛衣，这个时候，把人想象成 GC Roots，因为 人 和 狗之间失去了绳子连接，</p><p>那么狗可能被回收，也就是被警察抓起来，被送到流浪狗寄养所</p><p>假设狗和人有强连接的时候，狗狗就不会被当成是流浪狗</p><h4 id="那些对象可以当做GC-Roots"><a href="#那些对象可以当做GC-Roots" class="headerlink" title="那些对象可以当做GC Roots"></a>那些对象可以当做GC Roots</h4><ul><li>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中的引用对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中的JNI（Native方法）的引用对象</li></ul><h4 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在Java中，可以作为GC Roots的对象有：</span></span><br><span class="line"><span class="comment"> * - 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中的引用对象</span></span><br><span class="line"><span class="comment"> * - 方法区中的类静态属性引用的对象</span></span><br><span class="line"><span class="comment"> * - 方法区中常量引用的对象</span></span><br><span class="line"><span class="comment"> * - 本地方法栈中的JNI（Native方法）的引用对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ylyang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCRootDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法区中的类静态属性引用的对象</span></span><br><span class="line">    <span class="comment">// private static GCRootDemo2 t2;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法区中的常量引用，GC Roots 也会以这个为起点，进行遍历</span></span><br><span class="line">    <span class="comment">// private static final GCRootDemo3 t3 = new GCRootDemo3(8);</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种，虚拟机栈中的引用对象</span></span><br><span class="line">        GCRootDemo t1 = <span class="keyword">new</span> GCRootDemo();</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"第一次GC完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> GCRoots </tag>
            
            <tag> GC </tag>
            
            <tag> Java垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM体系结构概述</title>
      <link href="/2019/10/10/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
      <url>/2019/10/10/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>java gc 主要回收的是 方法区 和 堆中的内容</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li>类加载器是什么</li><li>双亲委派机制</li><li>Java类加载的沙箱安全机制</li></ul><a id="more"></a><p><img data-src="image-20200318182540332.png" alt="image1"></p><p><img data-src="image-20200318184401133.png" alt="image2"></p><h2 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h2><ul><li>引用计数</li></ul><p><img data-src="image-20200318184508982.png" alt="image3"></p><p>在双端循环，互相引用的时候，容易报错，目前很少使用这种方式了</p><ul><li>复制</li></ul><p>复制算法在年轻代的时候，进行使用，复制时候有交换</p><p><img data-src="image-20200318184759295.png" alt="image4"></p><p><img data-src="image-20200318184820787.png" alt="image5"></p><p>优点：没有产生内存碎片</p><ul><li>标记清除</li></ul><p>先标记，后清除，缺点是会产生内存碎片，用于老年代多一些</p><p><img data-src="image-20200318184944878.png" alt="image6"></p><ul><li>标记整理</li></ul><p>标记清除整理</p><p><img data-src="image-20200318185100936.png" alt="image7"></p><p>但是需要付出代价，因为移动对象需要成本</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> GC </tag>
            
            <tag> JVM </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死锁编码及快速定位</title>
      <link href="/2019/10/07/%E6%AD%BB%E9%94%81%E7%BC%96%E7%A0%81%E5%8F%8A%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D/"/>
      <url>/2019/10/07/%E6%AD%BB%E9%94%81%E7%BC%96%E7%A0%81%E5%8F%8A%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="死锁编码及定位分析"><a href="#死锁编码及定位分析" class="headerlink" title="死锁编码及定位分析"></a>死锁编码及定位分析</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>死锁是指两个或多个以上的进程在执行过程中，因争夺资源而造成一种互相等待的现象，若无外力干涉那他们都将无法推进下去，如果资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁</p><a id="more"></a><p><img data-src="image-20200318175441578.png" alt="image8"></p><h2 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h2><ul><li>系统资源不足</li><li>进程运行推进的顺序不对</li><li>资源分配不当</li></ul><h2 id="死锁代码"><a href="#死锁代码" class="headerlink" title="死锁代码"></a>死锁代码</h2><p>我们创建了一个资源类，然后让两个线程分别持有自己的锁，同时在尝试获取别人的，就会出现死锁现象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 死锁小Demo</span><br><span class="line"> * 死锁是指两个或多个以上的进程在执行过程中，</span><br><span class="line"> * 因争夺资源而造成一种互相等待的现象，</span><br><span class="line"> * 若无外力干涉那他们都将无法推进下去</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 资源类</span><br><span class="line"> *&#x2F;</span><br><span class="line">class HoldLockThread implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private String lockA;</span><br><span class="line">    private String lockB;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 持有自己的锁，还想得到别人的锁</span><br><span class="line"></span><br><span class="line">    public HoldLockThread(String lockA, String lockB) &#123;</span><br><span class="line">        this.lockA &#x3D; lockA;</span><br><span class="line">        this.lockB &#x3D; lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (lockA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 自己持有&quot; + lockA + &quot;\t 尝试获取：&quot; + lockB);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            synchronized (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t 自己持有&quot; + lockB + &quot;\t 尝试获取：&quot; + lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DeadLockDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String lockA &#x3D; &quot;lockA&quot;;</span><br><span class="line">        String lockB &#x3D; &quot;lockB&quot;;</span><br><span class="line"></span><br><span class="line">        new Thread(new HoldLockThread(lockA, lockB), &quot;t1&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(new HoldLockThread(lockB, lockA), &quot;t2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，main线程无法结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1 自己持有lockA 尝试获取：lockB</span><br><span class="line">t2 自己持有lockB 尝试获取：lockA</span><br></pre></td></tr></table></figure><h2 id="如何排查死锁"><a href="#如何排查死锁" class="headerlink" title="如何排查死锁"></a>如何排查死锁</h2><p>当我们出现死锁的时候，首先需要使用jps命令查看运行的程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></table></figure><p>我们能看到DeadLockDemo这个类，一直在运行</p><p><img data-src="images/image-20200318181504703.png" alt="image"></p><p>在使用jstack查看堆栈信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack  7560   # 后面参数是 jps输出的该类的pid</span><br></pre></td></tr></table></figure><p>得到的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;t2&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000001cfc0de8 (object 0x000000076b696e80, a java.lang.String),</span><br><span class="line">  which is held by &quot;t1&quot;</span><br><span class="line">&quot;t1&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000001cfc3728 (object 0x000000076b696eb8, a java.lang.String),</span><br><span class="line">  which is held by &quot;t2&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;t2&quot;:</span><br><span class="line">        at com.moxi.interview.study.Lock.HoldLockThread.run(DeadLockDemo.java:42)</span><br><span class="line">        - waiting to lock &lt;0x000000076b696e80&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;0x000000076b696eb8&gt; (a java.lang.String)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">&quot;t1&quot;:</span><br><span class="line">        at com.moxi.interview.study.Lock.HoldLockThread.run(DeadLockDemo.java:42)</span><br><span class="line">        - waiting to lock &lt;0x000000076b696eb8&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;0x000000076b696e80&gt; (a java.lang.String)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure><p>通过查看最后一行，我们看到  Found 1 deadlock，即存在一个死锁</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> java的锁 </tag>
            
            <tag> 死锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池</title>
      <link href="/2019/10/07/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/10/07/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池（Java中有哪些方法获取多线程）"><a href="#线程池（Java中有哪些方法获取多线程）" class="headerlink" title="线程池（Java中有哪些方法获取多线程）"></a>线程池（Java中有哪些方法获取多线程）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>获取多线程的方法，我们都知道有三种，还有一种是实现Callable接口</p><ul><li>实现Runnable接口</li><li>实现Callable接口</li><li>实例化Thread类</li><li>使用线程池获取</li></ul><a id="more"></a><h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>Callable接口，是一种让线程执行完成后，能够返回结果的</p><p>在说到Callable接口的时候，我们不得不提到Runnable接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 实现Runnable接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">class MyThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，实现Runnable接口的时候，需要重写run方法，也就是线程在启动的时候，会自动调用的方法</p><p>同理，我们实现Callable接口，也需要实现call方法，但是这个时候我们还需要有返回值，这个Callable接口的应用场景一般就在于批处理业务，比如转账的时候，需要给一会返回结果的状态码回来，代表本次操作成功还是失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Callable有返回值</span><br><span class="line"> * 批量处理的时候，需要带返回值的接口（例如支付失败的时候，需要返回错误状态）</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">class MyThread2 implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;come in Callable&quot;);</span><br><span class="line">        return 1024;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要做的就是通过Thread线程， 将MyThread2实现Callable接口的类包装起来</p><p>这里需要用到的是FutureTask类，他实现了Runnable接口，并且还需要传递一个实现Callable接口的类作为构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; FutureTask：实现了Runnable接口，构造函数又需要传入 Callable接口</span><br><span class="line">&#x2F;&#x2F; 这里通过了FutureTask接触了Callable接口</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br></pre></td></tr></table></figure><p>然后在用Thread进行实例化，传入实现Runnabnle接口的FutureTask的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 &#x3D; new Thread(futureTask, &quot;aaa&quot;);</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>最后通过 utureTask.get() 获取到返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出FutureTask的返回值</span><br><span class="line">System.out.println(&quot;result FutureTask &quot; + futureTask.get());</span><br></pre></td></tr></table></figure><p>这就相当于原来我们的方式是main方法一条龙之心，后面在引入Callable后，对于执行比较久的线程，可以单独新开一个线程进行执行，最后在进行汇总输出</p><p>最后需要注意的是 要求获得Callable线程的计算结果，如果没有计算完成就要去强求，会导致阻塞，直到计算完成</p><p><img data-src="image-20200317152541284.png" alt="image"></p><p>也就是说 futureTask.get() 需要放在最后执行，这样不会导致主线程阻塞</p><p>也可以使用下面算法，使用类似于自旋锁的方式来进行判断是否运行完毕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断futureTask是否计算完成</span><br><span class="line">while(!futureTask.isDone()) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>多个线程执行 一个FutureTask的时候，只会计算一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开启两个线程计算futureTask</span><br><span class="line">new Thread(futureTask, &quot;AAA&quot;).start();</span><br><span class="line">new Thread(futureTask, &quot;BBB&quot;).start();</span><br></pre></td></tr></table></figure><p>如果我们要两个线程同时计算任务的话，那么需要这样写，需要定义两个futureTask</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask2 &#x3D; new FutureTask&lt;&gt;(new MyThread2());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开启两个线程计算futureTask</span><br><span class="line">new Thread(futureTask, &quot;AAA&quot;).start();</span><br><span class="line"></span><br><span class="line">new Thread(futureTask2, &quot;BBB&quot;).start();</span><br></pre></td></tr></table></figure><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="为什么用线程池"><a href="#为什么用线程池" class="headerlink" title="为什么用线程池"></a>为什么用线程池</h3><p>线程池做的主要工作就是控制运行的线程的数量，处理过程中，将任务放入到队列中，然后线程创建后，启动这些任务，如果线程数量超过了最大数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p><p>它的主要特点为：线程复用、控制最大并发数、管理线程</p><p>线程池中的任务是放入到阻塞队列中的</p><h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><p>多核处理的好处是：省略的上下文的切换开销</p><p>原来我们实例化对象的时候，是使用 new关键字进行创建，到了Spring后，我们学了IOC依赖注入，发现Spring帮我们将对象已经加载到了Spring容器中，只需要通过@Autowrite注解，就能够自动注入，从而使用</p><p>因此使用多线程有下列的好处</p><ul><li>降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁造成的消耗</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就立即执行</li><li>提高线程的可管理性。线程是稀缺资源，如果无线创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ul><h3 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h3><p>Java中线程池是通过Executor框架实现的，该框架中用到了Executor，Executors（代表工具类），ExecutorService，ThreadPoolExecutor这几个类。</p><p><img data-src="image-20200317175202647.png" alt="image"></p><p><img data-src="image-20200317175241007.png" alt="image"></p><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><ul><li>Executors.newFixedThreadPool(int i) ：创建一个拥有 i 个线程的线程池<ul><li>执行长期的任务，性能好很多</li><li>创建一个定长线程池，可控制线程数最大并发数，超出的线程会在队列中等待</li></ul></li><li>Executors.newSingleThreadExecutor：创建一个只有1个线程的 单线程池<ul><li>一个任务一个任务执行的场景</li><li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行</li></ul></li><li>Executors.newCacheThreadPool();  创建一个可扩容的线程池<ul><li>执行很多短期异步的小程序或者负载教轻的服务器</li><li>创建一个可缓存线程池，如果线程长度超过处理需要，可灵活回收空闲线程，如无可回收，则新建新线程</li></ul></li></ul><p>具体使用，首先我们需要使用Executors工具类，进行创建线程池，这里创建了一个拥有5个线程的线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一池5个处理线程（用池化技术，一定要记得关闭）</span><br><span class="line">ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个只有一个线程的线程池</span><br><span class="line">ExecutorService threadPool &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个拥有N个线程的线程池，根据调度创建合适的线程</span><br><span class="line">ExecutorService threadPool &#x3D; Executors.newCacheThreadPool();</span><br></pre></td></tr></table></figure><p>然后我们执行下面的的应用场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span><br></pre></td></tr></table></figure><p>我们需要使用 threadPool.execute执行业务，execute需要传入一个实现了Runnable接口的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(() -&gt; &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;\t 给用户办理业务&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后我们使用完毕后关闭线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threadPool.shutdown();</span><br></pre></td></tr></table></figure><p>完整代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 第四种获取 &#x2F; 使用 Java多线程的方式，通过线程池</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyThreadPoolDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Array  Arrays(辅助工具类)</span><br><span class="line">        &#x2F;&#x2F; Collection Collections(辅助工具类)</span><br><span class="line">        &#x2F;&#x2F; Executor Executors(辅助工具类)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 一池5个处理线程（用池化技术，一定要记得关闭）</span><br><span class="line">        ExecutorService threadPool &#x3D; Executors.newFixedThreadPool(5);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 循环十次，模拟业务办理，让5个线程处理这10个请求</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                final int tempInt &#x3D; i;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;\t 给用户:&quot; + tempInt + &quot; 办理业务&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-5 给用户:4 办理业务</span><br><span class="line">pool-1-thread-1 给用户:5 办理业务</span><br><span class="line">pool-1-thread-4 给用户:3 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-3 给用户:2 办理业务</span><br><span class="line">pool-1-thread-2 给用户:9 办理业务</span><br><span class="line">pool-1-thread-4 给用户:8 办理业务</span><br><span class="line">pool-1-thread-1 给用户:7 办理业务</span><br><span class="line">pool-1-thread-5 给用户:6 办理业务</span><br></pre></td></tr></table></figure><p>我们能够看到，一共有5个线程，在给10个用户办理业务</p><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>我们通过查看源码，点击了Executors.newSingleThreadExecutor 和 Executors.newFixedThreadPool能够发现底层都是使用了ThreadPoolExecutor</p><p><img data-src="image-20200317182004293.png" alt="image1"></p><p>我们可以看到线程池的内部，还使用到了LinkedBlockingQueue 链表阻塞队列</p><p>同时在查看Executors.newCacheThreadPool 看到底层用的是 SynchronousBlockingQueue阻塞队列</p><p>最后查看一下，完整的三个创建线程的方法</p><p><img data-src="image-20200317183202992.png" alt="image3"></p><h2 id="线程池的重要参数"><a href="#线程池的重要参数" class="headerlink" title="线程池的重要参数"></a>线程池的重要参数</h2><p><img data-src="image-20200317183600957.png" alt="image3"></p><p>线程池在创建的时候，一共有7大参数</p><ul><li>corePoolSize：核心线程数，线程池中的常驻核心线程数<ul><li>在创建线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程</li><li>当线程池中的线程数目达到corePoolSize后，就会把到达的队列放到缓存队列中</li></ul></li><li>maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1、<ul><li>相当有扩容后的线程数，这个线程池能容纳的最多线程数</li></ul></li><li>keepAliveTime：多余的空闲线程存活时间<ul><li>当线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余的空闲线程会被销毁，直到只剩下corePoolSize个线程为止</li><li>默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用</li></ul></li><li>unit：keepAliveTime的单位</li><li>workQueue：任务队列，被提交的但未被执行的任务（类似于银行里面的候客区）<ul><li>LinkedBlockingQueue：链表阻塞队列</li><li>SynchronousBlockingQueue：同步阻塞队列</li></ul></li><li>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程池 一般用默认即可</li><li>handler：拒绝策略，表示当队列满了并且工作线程大于线程池的最大线程数（maximumPoolSize3）时，如何来拒绝请求执行的Runnable的策略</li></ul><p>当营业窗口和阻塞队列中都满了时候，就需要设置拒绝策略</p><p><img data-src="image-20200317201150197.png" alt="image2"></p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>以下所有拒绝策略都实现了RejectedExecutionHandler接口</p><ul><li>AbortPolicy：默认，直接抛出RejectedExcutionException异常，阻止系统正常运行</li><li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常，如果运行任务丢失，这是一种好方案</li><li>CallerRunsPolicy：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者</li><li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务</li></ul><h2 id="线程池底层工作原理"><a href="#线程池底层工作原理" class="headerlink" title="线程池底层工作原理"></a>线程池底层工作原理</h2><h3 id="线程池运行架构图"><a href="#线程池运行架构图" class="headerlink" title="线程池运行架构图"></a>线程池运行架构图</h3><p><img data-src="image-20200318154414717.png" alt="image1"></p><p>文字说明</p><ol><li><p>在创建了线程池后，等待提交过来的任务请求</p></li><li><p>当调用execute()方法添加一个请求任务时，线程池会做出如下判断</p><ol><li>如果正在运行的线程池数量小于corePoolSize，那么马上创建线程运行这个任务</li><li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列</li><li>如果这时候队列满了，并且正在运行的线程数量还小于maximumPoolSize，那么还是创建非核心线程like运行这个任务；</li><li>如果队列满了并且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行</li></ol></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p></li><li><p>当一个线程无事可做操作一定的时间(keepAliveTime)时，线程池会判断：</p><ol><li>如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉</li><li>所以线程池的所有任务完成后，它会最终收缩到corePoolSize的大小</li></ol></li></ol><p>以顾客去银行办理业务为例，谈谈线程池的底层工作原理</p><ol><li>最开始假设来了两个顾客，因为corePoolSize为2，因此这两个顾客直接能够去窗口办理</li><li>后面又来了三个顾客，因为corePool已经被顾客占用了，因此只有去候客区，也就是阻塞队列中等待</li><li>后面的人又陆陆续续来了，候客区可能不够用了，因此需要申请增加处理请求的窗口，这里的窗口指的是线程池中的线程数，以此来解决线程不够用的问题</li><li>假设受理窗口已经达到最大数，并且请求数还是不断递增，此时候客区和线程池都已经满了，为了防止大量请求冲垮线程池，已经需要开启拒绝策略</li><li>临时增加的线程会因为超过了最大存活时间，就会销毁，最后从最大数削减到核心数</li></ol><h2 id="为什么不用默认创建的线程池？"><a href="#为什么不用默认创建的线程池？" class="headerlink" title="为什么不用默认创建的线程池？"></a>为什么不用默认创建的线程池？</h2><p>线程池创建的方法有：固定数的，单一的，可变的，那么在实际开发中，应该使用哪个？</p><p>我们一个都不用，在生产环境中是使用自己自定义的</p><p>为什么不用Executors中JDK提供的？</p><p>根据阿里巴巴手册：并发控制这章</p><ul><li>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程<ul><li>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题</li></ul></li><li>线程池不允许使用Executors去创建，而是通过ThreadToolExecutors的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险<ul><li>Executors返回的线程池对象弊端如下：<ul><li>FixedThreadPool和SingleThreadPool：<ul><li>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</li></ul></li><li>CacheThreadPool和ScheduledThreadPool<ul><li>运行的请求队列长度为：Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</li></ul></li></ul></li></ul></li></ul><h2 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h2><h3 id="采用默认拒绝策略"><a href="#采用默认拒绝策略" class="headerlink" title="采用默认拒绝策略"></a>采用默认拒绝策略</h3><p>从上面我们知道，因为默认的Executors创建的线程池，底层都是使用LinkBlockingQueue作为阻塞队列的，而LinkBlockingQueue虽然是有界的，但是它的界限是 Integer.MAX_VALUE 大概有20多亿，可以相当是无界的了，因此我们要使用ThreadPoolExecutor自己手动创建线程池，然后指定阻塞队列的大小</p><p>下面我们创建了一个 核心线程数为2，最大线程数为5，并且阻塞队列数为3的线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 手写线程池</span><br><span class="line">final Integer corePoolSize &#x3D; 2;</span><br><span class="line">final Integer maximumPoolSize &#x3D; 5;</span><br><span class="line">final Long keepAliveTime &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自定义线程池，只改变了LinkBlockingQueue的队列大小</span><br><span class="line">ExecutorService executorService &#x3D; new ThreadPoolExecutor(</span><br><span class="line">        corePoolSize,</span><br><span class="line">        maximumPoolSize,</span><br><span class="line">        keepAliveTime,</span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        new LinkedBlockingQueue&lt;&gt;(3),</span><br><span class="line">        Executors.defaultThreadFactory(),</span><br><span class="line">        new ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></table></figure><p>然后使用for循环，模拟10个用户来进行请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 模拟10个用户来办理业务，每个用户就是一个来自外部请求线程</span><br><span class="line">  try &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 循环十次，模拟业务办理，让5个线程处理这10个请求</span><br><span class="line">      for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">          final int tempInt &#x3D; i;</span><br><span class="line">          executorService.execute(() -&gt; &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName() + &quot;\t 给用户:&quot; + tempInt + &quot; 办理业务&quot;);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">      executorService.shutdown();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但是在用户执行到第九个的时候，触发了异常，程序中断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-4 给用户:6 办理业务</span><br><span class="line">pool-1-thread-3 给用户:5 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-2 给用户:4 办理业务</span><br><span class="line">pool-1-thread-5 给用户:7 办理业务</span><br><span class="line">pool-1-thread-4 给用户:2 办理业务</span><br><span class="line">pool-1-thread-3 给用户:3 办理业务</span><br><span class="line">java.util.concurrent.RejectedExecutionException: Task com.moxi.interview.study.thread.MyThreadPoolDemo$$Lambda$1&#x2F;1747585824@4dd8dc3 rejected from java.util.concurrent.ThreadPoolExecutor@6d03e736[Running, pool size &#x3D; 5, active threads &#x3D; 3, queued tasks &#x3D; 0, completed tasks &#x3D; 5]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)</span><br><span class="line">at com.moxi.interview.study.thread.MyThreadPoolDemo.main(MyThreadPoolDemo.java:34)</span><br></pre></td></tr></table></figure><p>这是因为触发了拒绝策略，而我们设置的拒绝策略是默认的AbortPolicy，也就是抛异常的</p><p>触发条件是，请求的线程大于 阻塞队列大小 + 最大线程数 = 8 的时候，也就是说第9个线程来获取线程池中的线程时，就会抛出异常从而报错退出。</p><h3 id="采用CallerRunsPolicy拒绝策略"><a href="#采用CallerRunsPolicy拒绝策略" class="headerlink" title="采用CallerRunsPolicy拒绝策略"></a>采用CallerRunsPolicy拒绝策略</h3><p>当我们更好其它的拒绝策略时，采用CallerRunsPolicy拒绝策略，也称为回退策略，就是把任务丢回原来的请求开启线程着，我们看运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-5 给用户:7 办理业务</span><br><span class="line">pool-1-thread-4 给用户:6 办理业务</span><br><span class="line">main 给用户:8 办理业务</span><br><span class="line">pool-1-thread-3 给用户:5 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-3 给用户:9 办理业务</span><br><span class="line">pool-1-thread-4 给用户:4 办理业务</span><br><span class="line">pool-1-thread-5 给用户:3 办理业务</span><br><span class="line">pool-1-thread-1 给用户:2 办理业务</span><br></pre></td></tr></table></figure><p>我们发现，输出的结果里面出现了main线程，因为线程池出发了拒绝策略，把任务回退到main线程，然后main线程对任务进行处理</p><h3 id="采用-DiscardPolicy-拒绝策略"><a href="#采用-DiscardPolicy-拒绝策略" class="headerlink" title="采用 DiscardPolicy 拒绝策略"></a>采用 DiscardPolicy 拒绝策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-3 给用户:5 办理业务</span><br><span class="line">pool-1-thread-1 给用户:2 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-1 给用户:4 办理业务</span><br><span class="line">pool-1-thread-5 给用户:7 办理业务</span><br><span class="line">pool-1-thread-4 给用户:6 办理业务</span><br><span class="line">pool-1-thread-3 给用户:3 办理业务</span><br></pre></td></tr></table></figure><p>采用DiscardPolicy拒绝策略会，线程池会自动把后面的任务都直接丢弃，也不报异常，当任务无关紧要的时候，可以采用这个方式</p><h3 id="采用DiscardOldestPolicy拒绝策略"><a href="#采用DiscardOldestPolicy拒绝策略" class="headerlink" title="采用DiscardOldestPolicy拒绝策略"></a>采用DiscardOldestPolicy拒绝策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 给用户:0 办理业务</span><br><span class="line">pool-1-thread-4 给用户:6 办理业务</span><br><span class="line">pool-1-thread-1 给用户:4 办理业务</span><br><span class="line">pool-1-thread-3 给用户:5 办理业务</span><br><span class="line">pool-1-thread-2 给用户:1 办理业务</span><br><span class="line">pool-1-thread-1 给用户:9 办理业务</span><br><span class="line">pool-1-thread-4 给用户:8 办理业务</span><br><span class="line">pool-1-thread-5 给用户:7 办理业务</span><br></pre></td></tr></table></figure><p>这个策略和刚刚差不多，会把最久的队列中的任务替换掉</p><h2 id="线程池的合理参数"><a href="#线程池的合理参数" class="headerlink" title="线程池的合理参数"></a>线程池的合理参数</h2><p>生产环境中如何配置 corePoolSize 和 maximumPoolSize</p><p>这个是根据具体业务来配置的，分为CPU密集型和IO密集型</p><ul><li>CPU密集型</li></ul><p>CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行</p><p>CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程）</p><p>而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些</p><p>CPU密集型任务配置尽可能少的线程数量：</p><p>一般公式：CPU核数 + 1个线程数</p><ul><li>IO密集型</li></ul><p>由于IO密集型任务线程并不是一直在执行任务，则可能多的线程，如 CPU核数 * 2</p><p>IO密集型，即该任务需要大量的IO操作，即大量的阻塞</p><p>在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力花费在等待上</p><p>所以IO密集型任务中使用多线程可以大大的加速程序的运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</p><p>IO密集时，大部分线程都被阻塞，故需要多配置线程数：</p><p>参考公式：CPU核数 / (1 - 阻塞系数)      阻塞系数在0.8 ~ 0.9左右</p><p>例如：8核CPU：8/ (1 - 0.9) = 80个线程数</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized和Lock的区别与好处</title>
      <link href="/2019/10/06/Synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%A5%BD%E5%A4%84/"/>
      <url>/2019/10/06/Synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%A5%BD%E5%A4%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Synchronized和Lock的区别"><a href="#Synchronized和Lock的区别" class="headerlink" title="Synchronized和Lock的区别"></a>Synchronized和Lock的区别</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>早期的时候我们对线程的主要操作为：</p><ul><li>synchronized wati  notify</li></ul><p>然后后面出现了替代方案</p><a id="more"></a><ul><li>lock await  singal</li></ul><p><img data-src="image-20200317101210376.png" alt="image1"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="synchronized-和-lock-有什么区别？用新的lock有什么好处？举例说明"><a href="#synchronized-和-lock-有什么区别？用新的lock有什么好处？举例说明" class="headerlink" title="synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明"></a>synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明</h3><ul><li>synchronized 和 lock 有什么区别？用新的lock有什么好处？举例说明</li></ul><p>1）synchronized属于JVM层面，属于java的关键字</p><ul><li>​    monitorenter（底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象 只能在同步块或者方法中才能调用 wait/ notify等方法）</li><li>Lock是具体类（java.util.concurrent.locks.Lock）是api层面的锁</li></ul><p>2）使用方法：</p><ul><li><p>synchronized：不需要用户去手动释放锁，当synchronized代码执行后，系统会自动让线程释放对锁的占用</p></li><li><p>ReentrantLock：则需要用户去手动释放锁，若没有主动释放锁，就有可能出现死锁的现象，需要lock() 和 unlock() 配置try catch语句来完成</p></li></ul><p>3）等待是否中断</p><ul><li>synchronized：不可中断，除非抛出异常或者正常运行完成</li><li>ReentrantLock：可中断，可以设置超时方法<ul><li>设置超时方法，trylock(long timeout, TimeUnit unit)</li><li>lockInterrupible() 放代码块中，调用interrupt() 方法可以中断</li></ul></li></ul><p>4）加锁是否公平</p><ul><li>synchronized：非公平锁</li><li>ReentrantLock：默认非公平锁，构造函数可以传递boolean值，true为公平锁，false为非公平锁</li></ul><p>5）锁绑定多个条件Condition</p><ul><li>synchronized：没有，要么随机，要么全部唤醒</li><li>ReentrantLock：用来实现分组唤醒需要唤醒的线程，可以精确唤醒，而不是像synchronized那样，要么随机，要么全部唤醒</li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>针对刚刚提到的区别的第5条，我们有下面这样的一个场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">题目：多线程之间按顺序调用，实现 A-&gt; B -&gt; C 三个线程启动，要求如下：</span><br><span class="line">AA打印5次，BB打印10次，CC打印15次</span><br><span class="line">紧接着</span><br><span class="line">AA打印5次，BB打印10次，CC打印15次</span><br><span class="line">..</span><br><span class="line">来10轮</span><br></pre></td></tr></table></figure><p>我们会发现，这样的场景在使用synchronized来完成的话，会非常的困难，但是使用lock就非常方便了</p><p>也就是我们需要实现一个链式唤醒的操作</p><p><img data-src="image-20200317105121435.png" alt="image2"></p><p>当A线程执行完后，B线程才能执行，然后B线程执行完成后，C线程才执行</p><p>首先我们需要创建一个重入锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个重入锁</span><br><span class="line">private Lock lock &#x3D; new ReentrantLock();</span><br></pre></td></tr></table></figure><p>然后定义三个条件，也可以称为锁的钥匙，通过它就可以获取到锁，进入到方法里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这三个相当于备用钥匙</span><br><span class="line">private Condition condition1 &#x3D; lock.newCondition();</span><br><span class="line">private Condition condition2 &#x3D; lock.newCondition();</span><br><span class="line">private Condition condition3 &#x3D; lock.newCondition();</span><br></pre></td></tr></table></figure><p>然后开始记住锁的三部曲： 判断   干活  唤醒</p><p>这里的判断，为了避免虚假唤醒，一定要采用  while</p><p>干活就是把需要的内容，打印出来</p><p>唤醒的话，就是修改资源类的值，然后精准唤醒线程进行干活：这里A 唤醒B， B唤醒C，C又唤醒A</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void print5() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断</span><br><span class="line">        while(number !&#x3D; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 不等于1，需要等待</span><br><span class="line">            condition1.await();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 干活</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number + &quot;\t&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 唤醒 （干完活后，需要通知B线程执行）</span><br><span class="line">        number &#x3D; 2;</span><br><span class="line">        &#x2F;&#x2F; 通知2号去干活了</span><br><span class="line">        condition2.signal();</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Synchronized 和 Lock的区别</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">class ShareResource &#123;</span><br><span class="line">    &#x2F;&#x2F; A 1   B 2   c 3</span><br><span class="line">    private int number &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; 创建一个重入锁</span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这三个相当于备用钥匙</span><br><span class="line">    private Condition condition1 &#x3D; lock.newCondition();</span><br><span class="line">    private Condition condition2 &#x3D; lock.newCondition();</span><br><span class="line">    private Condition condition3 &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void print5() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断</span><br><span class="line">            while(number !&#x3D; 1) &#123;</span><br><span class="line">                &#x2F;&#x2F; 不等于1，需要等待</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 干活</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number + &quot;\t&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 唤醒 （干完活后，需要通知B线程执行）</span><br><span class="line">            number &#x3D; 2;</span><br><span class="line">            &#x2F;&#x2F; 通知2号去干活了</span><br><span class="line">            condition2.signal();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print10() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断</span><br><span class="line">            while(number !&#x3D; 2) &#123;</span><br><span class="line">                &#x2F;&#x2F; 不等于1，需要等待</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 干活</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number + &quot;\t&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 唤醒 （干完活后，需要通知C线程执行）</span><br><span class="line">            number &#x3D; 3;</span><br><span class="line">            &#x2F;&#x2F; 通知2号去干活了</span><br><span class="line">            condition3.signal();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print15() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断</span><br><span class="line">            while(number !&#x3D; 3) &#123;</span><br><span class="line">                &#x2F;&#x2F; 不等于1，需要等待</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 干活</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 15; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number + &quot;\t&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 唤醒 （干完活后，需要通知C线程执行）</span><br><span class="line">            number &#x3D; 1;</span><br><span class="line">            &#x2F;&#x2F; 通知1号去干活了</span><br><span class="line">            condition1.signal();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SyncAndReentrantLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ShareResource shareResource &#x3D; new ShareResource();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    shareResource.print5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                shareResource.print10();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                shareResource.print15();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Synchronized </tag>
            
            <tag> Lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java之阻塞队列</title>
      <link href="/2019/10/06/Java%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
      <url>/2019/10/06/Java%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列就可以想成是一个数组，从一头进入，一头出去，排队买饭</p><h3 id="阻塞队列-1"><a href="#阻塞队列-1" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>BlockingQueue   阻塞队列，排队拥堵，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p><a id="more"></a><p><img data-src="image-20200316152120272.png" alt="image1"></p><p>线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素</p><ul><li><p><code>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞</code></p><ul><li>当蛋糕店的柜子空的时候，无法从柜子里面获取蛋糕</li></ul></li><li><p><code>当阻塞队列是满时，从队列中添加元素的操作将会被阻塞</code></p><ul><li>当蛋糕店的柜子满的时候，无法继续向柜子里面添加蛋糕了</li></ul></li></ul><p>也就是说 试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它线程往空的队列插入新的元素</p><p>同理，试图往已经满的阻塞队列中添加新元素的线程，直到其它线程往满的队列中移除一个或多个元素，或者完全清空队列后，使队列重新变得空闲起来，并后续新增</p><h2 id="为什么要用？"><a href="#为什么要用？" class="headerlink" title="为什么要用？"></a>为什么要用？</h2><p>去海底捞吃饭，大厅满了，需要进候厅等待，但是这些等待的客户能够对商家带来利润，因此我们非常欢迎他们阻塞</p><p>在多线程领域：所谓的阻塞，在某些清空下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动唤醒</p><h3 id="为什么需要BlockingQueue"><a href="#为什么需要BlockingQueue" class="headerlink" title="为什么需要BlockingQueue"></a>为什么需要BlockingQueue</h3><p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都帮你一手包办了</p><p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己取控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 你用过List集合类</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ArrayList集合类熟悉么？</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 还用过 CopyOnWriteList  和 BlockingQueue</span><br></pre></td></tr></table></figure><p>BlockingQueue阻塞队列是属于一个接口，底下有七个实现类</p><ul><li>ArrayBlockQueue：由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：由链表结构组成的有界（但是默认大小 Integer.MAX_VALUE）的阻塞队列<ul><li>有界，但是界限非常大，相当于无界，可以当成无界</li></ul></li><li>PriorityBlockQueue：支持优先级排序的无界阻塞队列</li><li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li><li>SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列<ul><li>生产一个，消费一个，不存储元素，不消费不生产</li></ul></li><li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</li></ul><p>这里需要掌握的是：ArrayBlockQueue、LinkedBlockingQueue、SynchronousQueue</p><h2 id="BlockingQueue核心方法"><a href="#BlockingQueue核心方法" class="headerlink" title="BlockingQueue核心方法"></a>BlockingQueue核心方法</h2><p><img data-src="image-20200316154442756.png" alt="image2"></p><table><thead><tr><th>抛出异常</th><th>当阻塞队列满时：在往队列中add插入元素会抛出 IIIegalStateException：Queue full                      当阻塞队列空时：再往队列中remove移除元素，会抛出NoSuchException</th></tr></thead><tbody><tr><td>特殊性</td><td>插入方法，成功true，失败false       移除方法：成功返回出队列元素，队列没有就返回空</td></tr><tr><td>一直阻塞</td><td>当阻塞队列满时，生产者继续往队列里put元素，队列会一直阻塞生产线程直到put数据or响应中断退出， 当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用。</td></tr><tr><td>超时退出</td><td>当阻塞队列满时，队里会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td></tr></tbody></table><h3 id="抛出异常组"><a href="#抛出异常组" class="headerlink" title="抛出异常组"></a>抛出异常组</h3><p>但执行add方法，向已经满的ArrayBlockingQueue中添加元素时候，会抛出异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 阻塞队列，需要填入默认值</span><br><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.add(&quot;a&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;b&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;c&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.add(&quot;XXX&quot;));</span><br></pre></td></tr></table></figure><p>运行后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full</span><br><span class="line">at java.util.AbstractQueue.add(AbstractQueue.java:98)</span><br><span class="line">at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)</span><br><span class="line">at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:25)</span><br></pre></td></tr></table></figure><p>同时如果我们多取出元素的时候，也会抛出异常，我们假设只存储了3个值，但是取的时候，取了四次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 阻塞队列，需要填入默认值</span><br><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">System.out.println(blockingQueue.add(&quot;a&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;b&quot;));</span><br><span class="line">System.out.println(blockingQueue.add(&quot;c&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line">System.out.println(blockingQueue.remove());</span><br><span class="line">System.out.println(blockingQueue.remove());</span><br></pre></td></tr></table></figure><p>那么出现异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">Exception in thread &quot;main&quot; java.util.NoSuchElementException</span><br><span class="line">at java.util.AbstractQueue.remove(AbstractQueue.java:117)</span><br><span class="line">at com.moxi.interview.study.queue.BlockingQueueDemo.main(BlockingQueueDemo.java:30)</span><br></pre></td></tr></table></figure><h3 id="布尔类型组"><a href="#布尔类型组" class="headerlink" title="布尔类型组"></a>布尔类型组</h3><p>我们使用 offer的方法，添加元素时候，如果阻塞队列满了后，会返回false，否者返回true</p><p>同时在取的时候，如果队列已空，那么会返回null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue blockingQueue &#x3D; new ArrayBlockingQueue(3);</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.offer(&quot;a&quot;));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;b&quot;));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;c&quot;));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;d&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br><span class="line">System.out.println(blockingQueue.poll());</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h3 id="阻塞队列组"><a href="#阻塞队列组" class="headerlink" title="阻塞队列组"></a>阻塞队列组</h3><p>我们使用 put的方法，添加元素时候，如果阻塞队列满了后，添加消息的线程，会一直阻塞，直到队列元素减少，会被清空，才会唤醒</p><p>一般在消息中间件，比如RabbitMQ中会使用到，因为需要保证消息百分百不丢失，因此只有让它阻塞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">blockingQueue.put(&quot;a&quot;);</span><br><span class="line">blockingQueue.put(&quot;b&quot;);</span><br><span class="line">blockingQueue.put(&quot;c&quot;);</span><br><span class="line">System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">blockingQueue.take();</span><br><span class="line">blockingQueue.take();</span><br><span class="line">blockingQueue.take();</span><br><span class="line">blockingQueue.take();</span><br></pre></td></tr></table></figure><p>同时使用take取消息的时候，如果内容不存在的时候，也会被阻塞</p><h3 id="不见不散组"><a href="#不见不散组" class="headerlink" title="不见不散组"></a>不见不散组</h3><p>offer( )  ， poll 加时间</p><p>使用offer插入的时候，需要指定时间，如果2秒还没有插入，那么就放弃插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;a&quot;, 2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;b&quot;, 2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;c&quot;, 2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.offer(&quot;d&quot;, 2L, TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure><p>同时取的时候也进行判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br><span class="line">System.out.println(blockingQueue.poll(2L, TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure><p>如果2秒内取不出来，那么就返回null</p><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue没有容量，与其他BlockingQueue不同，SynchronousQueue是一个不存储的BlockingQueue，每一个put操作必须等待一个take操作，否者不能继续添加元素</p><p>下面我们测试SynchronousQueue添加元素的过程</p><p>首先我们创建了两个线程，一个线程用于生产，一个线程用于消费</p><p>生产的线程分别put了 A、B、C这三个字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; blockingQueue &#x3D; new SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    try &#123;       </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t put A &quot;);</span><br><span class="line">        blockingQueue.put(&quot;A&quot;);</span><br><span class="line">       </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t put B &quot;);</span><br><span class="line">        blockingQueue.put(&quot;B&quot;);        </span><br><span class="line">        </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t put C &quot;);</span><br><span class="line">        blockingQueue.put(&quot;C&quot;);        </span><br><span class="line">        </span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;t1&quot;).start();</span><br></pre></td></tr></table></figure><p>消费线程使用take，消费阻塞队列中的内容，并且每次消费前，都等待5秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        blockingQueue.take();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t take A &quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        blockingQueue.take();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t take B &quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        blockingQueue.take();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t take C &quot;);</span><br><span class="line"></span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;t2&quot;).start();</span><br></pre></td></tr></table></figure><p>最后结果输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t1 put A </span><br><span class="line">t2 take A </span><br><span class="line"></span><br><span class="line">5秒后...</span><br><span class="line"></span><br><span class="line">t1 put B </span><br><span class="line">t2 take B </span><br><span class="line"></span><br><span class="line">5秒后...</span><br><span class="line"></span><br><span class="line">t1 put C </span><br><span class="line">t2 take C</span><br></pre></td></tr></table></figure><p>我们从最后的运行结果可以看出，每次t1线程向队列中添加阻塞队列添加元素后，t1输入线程就会等待 t2消费线程，t2消费后，t2处于挂起状态，等待t1在存入，从而周而复始，形成 一存一取的状态</p><h2 id="阻塞队列的用处"><a href="#阻塞队列的用处" class="headerlink" title="阻塞队列的用处"></a>阻塞队列的用处</h2><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><p>一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来5轮</p><p>关于多线程的操作，我们需要记住下面几句</p><ul><li>线程 操作 资源类</li><li>判断 干活 通知</li><li>防止虚假唤醒机制</li></ul><p>我们下面实现一个简单的生产者消费者模式，首先有资源类ShareData</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 资源类</span><br><span class="line"> *&#x2F;</span><br><span class="line">class ShareData &#123;</span><br><span class="line"></span><br><span class="line">    private int number &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    private Condition condition &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void increment() throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F; 同步代码块，加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断</span><br><span class="line">            while(number !&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 等待不能生产</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 干活</span><br><span class="line">            number++;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 通知 唤醒</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void decrement() throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F; 同步代码块，加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断</span><br><span class="line">            while(number &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 等待不能消费</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 干活</span><br><span class="line">            number--;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 通知 唤醒</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面有一个number变量，同时提供了increment 和 decrement的方法，分别让number 加1和减1</p><p>但是我们在进行判断的时候，为了防止出现虚假唤醒机制，不能使用if来进行判断，而应该使用while</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断</span><br><span class="line">while(number !&#x3D; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; 等待不能生产</span><br><span class="line">    condition.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能使用 if判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断</span><br><span class="line">if(number !&#x3D; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; 等待不能生产</span><br><span class="line">    condition.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 生产者消费者 传统版</span><br><span class="line"> * 题目：一个初始值为0的变量，两个线程对其交替操作，一个加1，一个减1，来5轮</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 线程 操作 资源类</span><br><span class="line"> * 判断 干活 通知</span><br><span class="line"> * 防止虚假唤醒机制</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 资源类</span><br><span class="line"> *&#x2F;</span><br><span class="line">class ShareData &#123;</span><br><span class="line"></span><br><span class="line">    private int number &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private Lock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    private Condition condition &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void increment() throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F; 同步代码块，加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断</span><br><span class="line">            while(number !&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 等待不能生产</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 干活</span><br><span class="line">            number++;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 通知 唤醒</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void decrement() throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F; 同步代码块，加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断</span><br><span class="line">            while(number &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 等待不能消费</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 干活</span><br><span class="line">            number--;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t &quot; + number);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 通知 唤醒</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class ProdConsumerTraditionDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 高内聚，低耦合    内聚指的是，一个空调，自身带有调节温度高低的方法</span><br><span class="line"></span><br><span class="line">        ShareData shareData &#x3D; new ShareData();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; t1线程，生产</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    shareData.increment();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t1&quot;).start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; t2线程，消费</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    shareData.decrement();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行成功后，我们一个进行生产，一个进行消费</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br><span class="line">t1 1</span><br><span class="line">t2 0</span><br></pre></td></tr></table></figure><h2 id="生成者和消费者3-0"><a href="#生成者和消费者3-0" class="headerlink" title="生成者和消费者3.0"></a>生成者和消费者3.0</h2><p>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，则这会给我们的程序带来不小的时间复杂度</p><p>现在我们使用新版的阻塞队列版生产者和消费者，使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者消费者  阻塞队列版</span></span><br><span class="line"><span class="comment"> * 使用：volatile、CAS、atomicInteger、BlockQueue、线程交互、原子引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ylyang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认开启，进行生产消费</span></span><br><span class="line">    <span class="comment">// 这里用到了volatile是为了保持数据的可见性，也就是当TLAG修改时，要马上通知其它线程进行修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> FLAG = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原子包装类，而不用number++</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里不能为了满足条件，而实例化一个具体的SynchronousBlockingQueue</span></span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 而应该采用依赖注入里面的，构造注入方法传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyResource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        <span class="comment">// 查询出传入的class是什么</span></span><br><span class="line">        System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myProd</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> retValue;</span><br><span class="line">        <span class="comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span></span><br><span class="line">        <span class="comment">// 当FLAG为true的时候，开始生产</span></span><br><span class="line">        <span class="keyword">while</span>(FLAG) &#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet() + <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2秒存入1个data</span></span><br><span class="line">            retValue = blockingQueue.offer(data, <span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(retValue) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t 插入队列:"</span> + data  + <span class="string">"成功"</span> );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t 插入队列:"</span> + data  + <span class="string">"失败"</span> );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 停止生产，表示FLAG=false，生产介绍"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String retValue;</span><br><span class="line">        <span class="comment">// 多线程环境的判断，一定要使用while进行，防止出现虚假唤醒</span></span><br><span class="line">        <span class="comment">// 当FLAG为true的时候，开始生产</span></span><br><span class="line">        <span class="keyword">while</span>(FLAG) &#123;</span><br><span class="line">            <span class="comment">// 2秒存入1个data</span></span><br><span class="line">            retValue = blockingQueue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(retValue != <span class="keyword">null</span> &amp;&amp; retValue != <span class="string">""</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t 消费队列:"</span> + retValue  + <span class="string">"成功"</span> );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                FLAG = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t 消费失败，队列中已为空，退出"</span> );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 退出消费队列</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止生产的判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.FLAG = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumerBlockingQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入具体的实现类， ArrayBlockingQueue</span></span><br><span class="line">        MyResource myResource = <span class="keyword">new</span> MyResource(<span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 生产线程启动"</span>);</span><br><span class="line">            System.out.println(<span class="string">""</span>);</span><br><span class="line">            System.out.println(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myProd();</span><br><span class="line">                System.out.println(<span class="string">""</span>);</span><br><span class="line">                System.out.println(<span class="string">""</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"prod"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 消费线程启动"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.myConsumer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"consumer"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5秒后，停止生产和消费</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"5秒中后，生产和消费线程停止，线程结束"</span>);</span><br><span class="line">        myResource.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ArrayBlockingQueue</span><br><span class="line">prod 生产线程启动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consumer 消费线程启动</span><br><span class="line">prod 插入队列:1成功</span><br><span class="line">consumer 消费队列:1成功</span><br><span class="line">prod 插入队列:2成功</span><br><span class="line">consumer 消费队列:2成功</span><br><span class="line">prod 插入队列:3成功</span><br><span class="line">consumer 消费队列:3成功</span><br><span class="line">prod 插入队列:4成功</span><br><span class="line">consumer 消费队列:4成功</span><br><span class="line">prod 插入队列:5成功</span><br><span class="line">consumer 消费队列:5成功</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5秒中后，生产和消费线程停止，线程结束</span><br><span class="line">prod 停止生产，表示FLAG&#x3D;false，生产介绍</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 阻塞队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC之CountDownLatch</title>
      <link href="/2019/10/05/JUC%E4%B9%8BCountDownLatch-1/"/>
      <url>/2019/10/05/JUC%E4%B9%8BCountDownLatch-1/</url>
      
        <content type="html"><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>让一些线程阻塞直到另一些线程完成一系列操作才被唤醒</p><p>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，调用线程就会被阻塞。其它线程调用CountDown方法会将计数器减1（调用CountDown方法的线程不会被阻塞），当计数器的值变成零时，因调用await方法被阻塞的线程会被唤醒，继续执行</p><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>现在有这样一个场景，假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后，关灯，锁教室门，然后走人，因此班长是需要最后一个走的，那么有什么方法能够控制班长这个线程是最后一个执行，而其它线程是随机执行的</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这个时候就用到了CountDownLatch，计数器了。我们一共创建6个线程，然后计数器的值也设置成6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计数器</span><br><span class="line">CountDownLatch countDownLatch &#x3D; new CountDownLatch(6);</span><br></pre></td></tr></table></figure><p>然后每次学生线程执行完，就让计数器的值减1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; 6; i++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t 上完自习，离开教室&quot;);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要通过CountDownLatch的await方法来控制班长主线程的执行，这里 countDownLatch.await()可以想成是一道墙，只有当计数器的值为0的时候，墙才会消失，主线程才能继续往下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">countDownLatch.await();</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;\t 班长最后关门&quot;);</span><br></pre></td></tr></table></figure><p>不加CountDownLatch的执行结果，我们发现main线程提前已经执行完成了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 上完自习，离开教室</span><br><span class="line">0 上完自习，离开教室</span><br><span class="line">main 班长最后关门</span><br><span class="line">2 上完自习，离开教室</span><br><span class="line">3 上完自习，离开教室</span><br><span class="line">4 上完自习，离开教室</span><br><span class="line">5 上完自习，离开教室</span><br><span class="line">6 上完自习，离开教室</span><br></pre></td></tr></table></figure><p>引入CountDownLatch后的执行结果，我们能够控制住main方法的执行，这样能够保证前提任务的执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 上完自习，离开教室</span><br><span class="line">2 上完自习，离开教室</span><br><span class="line">4 上完自习，离开教室</span><br><span class="line">1 上完自习，离开教室</span><br><span class="line">5 上完自习，离开教室</span><br><span class="line">6 上完自习，离开教室</span><br><span class="line">3 上完自习，离开教室</span><br><span class="line">main 班长最后关门</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.moxi.interview.study.thread;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 计数器</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(6);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; 6; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;\t 上完自习，离开教室&quot;);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t 班长最后关门&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
            <tag> CountDownLatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC之CyclicBarrier</title>
      <link href="/2019/10/05/JUC%E4%B9%8BCyclicBarrier/"/>
      <url>/2019/10/05/JUC%E4%B9%8BCyclicBarrier/</url>
      
        <content type="html"><![CDATA[<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>和CountDownLatch相反，需要集齐七颗龙珠，召唤神龙。也就是做加法，开始是0，加到某个值的时候就执行</p><p>CyclicBarrier的字面意思就是可循环（cyclic）使用的屏障（Barrier）。它要求做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法</p><a id="more"></a><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>集齐7个龙珠，召唤神龙的Demo，我们需要首先创建CyclicBarrier</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"召唤神龙"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后同时编写七个线程，进行龙珠收集，但一个线程收集到了的时候，我们需要让他执行await方法，等待到7个线程全部执行完毕后，我们就执行原来定义好的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> Integer tempInt = i;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 收集到 第"</span> + tempInt + <span class="string">"颗龙珠"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span></span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CyclicBarrier循环屏障</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ylyang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"召唤神龙"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> Integer tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t 收集到 第"</span> + tempInt + <span class="string">"颗龙珠"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span></span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
            <tag> CyclicBarrier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC之CountDownLatch</title>
      <link href="/2019/10/05/JUC%E4%B9%8BCountDownLatch/"/>
      <url>/2019/10/05/JUC%E4%B9%8BCountDownLatch/</url>
      
        <content type="html"><![CDATA[<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>让一些线程阻塞直到另一些线程完成一系列操作才被唤醒</p><p>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，调用线程就会被阻塞。其它线程调用CountDown方法会将计数器减1（调用CountDown方法的线程不会被阻塞），当计数器的值变成零时，因调用await方法被阻塞的线程会被唤醒，继续执行</p><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>现在有这样一个场景，假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后，关灯，锁教室门，然后走人，因此班长是需要最后一个走的，那么有什么方法能够控制班长这个线程是最后一个执行，而其它线程是随机执行的</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这个时候就用到了CountDownLatch，计数器了。我们一共创建6个线程，然后计数器的值也设置成6</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数器</span></span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>然后每次学生线程执行完，就让计数器的值减1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 上完自习，离开教室"</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要通过CountDownLatch的await方法来控制班长主线程的执行，这里 countDownLatch.await()可以想成是一道墙，只有当计数器的值为0的时候，墙才会消失，主线程才能继续往下执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">countDownLatch.await();</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"\t 班长最后关门"</span>);</span><br></pre></td></tr></table></figure><p>不加CountDownLatch的执行结果，我们发现main线程提前已经执行完成了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 上完自习，离开教室</span><br><span class="line"><span class="number">0</span> 上完自习，离开教室</span><br><span class="line">main 班长最后关门</span><br><span class="line"><span class="number">2</span> 上完自习，离开教室</span><br><span class="line"><span class="number">3</span> 上完自习，离开教室</span><br><span class="line"><span class="number">4</span> 上完自习，离开教室</span><br><span class="line"><span class="number">5</span> 上完自习，离开教室</span><br><span class="line"><span class="number">6</span> 上完自习，离开教室</span><br></pre></td></tr></table></figure><p>引入CountDownLatch后的执行结果，我们能够控制住main方法的执行，这样能够保证前提任务的执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 上完自习，离开教室</span><br><span class="line">2 上完自习，离开教室</span><br><span class="line">4 上完自习，离开教室</span><br><span class="line">1 上完自习，离开教室</span><br><span class="line">5 上完自习，离开教室</span><br><span class="line">6 上完自习，离开教室</span><br><span class="line">3 上完自习，离开教室</span><br><span class="line">main 班长最后关门</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moxi.interview.study.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ylyang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t 上完自习，离开教室"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 班长最后关门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
            <tag> CountDownLatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized无法禁止指令重排却能保证有序性的分析</title>
      <link href="/2019/10/04/Synchronized%E6%97%A0%E6%B3%95%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%8D%B4%E8%83%BD%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2019/10/04/Synchronized%E6%97%A0%E6%B3%95%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%8D%B4%E8%83%BD%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么Synchronized无法禁止指令重排，却能保证有序性"><a href="#为什么Synchronized无法禁止指令重排，却能保证有序性" class="headerlink" title="为什么Synchronized无法禁止指令重排，却能保证有序性"></a>为什么Synchronized无法禁止指令重排，却能保证有序性</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先我们要分析下这道题，这简单的一个问题，其实里面还是包含了很多信息的，要想回答好这个问题，面试者至少要知道一下概念：</p><ul><li>Java内存模型</li><li>并发编程有序性问题</li><li>指令重排</li><li>synchronized锁</li><li>可重入锁</li><li>排它锁</li><li>as-if-serial语义</li><li>单线程&amp;多线程</li></ul><a id="more"></a><h2 id="标准解答"><a href="#标准解答" class="headerlink" title="标准解答"></a>标准解答</h2><p>为了进一步提升计算机各方面能力，在硬件层面做了很多优化，如处理器优化和指令重排等，但是这些技术的引入就会导致有序性问题。</p><blockquote><p>先解释什么是有序性问题，也知道是什么原因导致的有序性问题</p></blockquote><p>我们也知道，最好的解决有序性问题的办法，就是禁止处理器优化和指令重排，就像volatile中使用内存屏障一样。</p><blockquote><p>表明你知道啥是指令重排，也知道他的实现原理</p></blockquote><p>但是，虽然很多硬件都会为了优化做一些重排，但是在Java中，不管怎么排序，都不能影响单线程程序的执行结果。这就是as-if-serial语义，所有硬件优化的前提都是必须遵守as-if-serial语义。</p><p>as-if-serial语义把<strong>单线程</strong>程序保护了起来，遵守as-if-serial语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial语义使单线程程序员无需担心重排序会 干扰他们，也无需担心内存可见性问题。</p><blockquote><p>重点！解释下什么是as-if-serial语义，因为这是这道题的第一个关键词，答上来就对了一半了</p></blockquote><p>再说下synchronized，他是Java提供的锁，可以通过他对Java中的对象加锁，并且他是一种排他的、可重入的锁。</p><p>所以，当某个线程执行到一段被synchronized修饰的代码之前，会先进行加锁，执行完之后再进行解锁。在加锁之后，解锁之前，其他线程是无法再次获得锁的，只有这条加锁线程可以重复获得该锁。</p><blockquote><p>介绍synchronized的原理，这是本题的第二个关键点，到这里基本就可以拿满分了。</p></blockquote><p>synchronized通过排他锁的方式就保证了同一时间内，被synchronized修饰的代码是单线程执行的。所以呢，这就满足了as-if-serial语义的一个关键前提，那就是<strong>单线程</strong>，因为有as-if-serial语义保证，单线程的有序性就天然存在了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Synchronized </tag>
            
            <tag> 指令重排 </tag>
            
            <tag> 有序性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java锁之读写锁</title>
      <link href="/2019/10/04/Java%E9%94%81%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/"/>
      <url>/2019/10/04/Java%E9%94%81%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="独占锁（写锁）-共享锁（读锁）-互斥锁"><a href="#独占锁（写锁）-共享锁（读锁）-互斥锁" class="headerlink" title="独占锁（写锁） / 共享锁（读锁） / 互斥锁"></a>独占锁（写锁） / 共享锁（读锁） / 互斥锁</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>独占锁：指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁</p><p>共享锁：指该锁可以被多个线程锁持有</p><p>对ReentrantReadWriteLock其读锁是共享，其写锁是独占</p><p>写的时候只能一个人写，但是读的时候，可以多个人同时读</p><a id="more"></a><h2 id="为什么会有写锁和读锁"><a href="#为什么会有写锁和读锁" class="headerlink" title="为什么会有写锁和读锁"></a>为什么会有写锁和读锁</h2><p>原来我们使用ReentrantLock创建锁的时候，是独占锁，也就是说一次只能一个线程访问，但是有一个读写分离场景，读的时候想同时进行，因此原来独占锁的并发性就没这么好了，因为读锁并不会造成数据不一致的问题，因此可以多个人共享读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</span><br></pre></td></tr></table></figure><p>读-读：能共存</p><p>读-写：不能共存</p><p>写-写：不能共存</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>实现一个读写缓存的操作，假设开始没有加锁的时候，会出现什么情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 读写锁</span><br><span class="line"> * 多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行</span><br><span class="line"> * 但是，如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 资源类</span><br><span class="line"> *&#x2F;</span><br><span class="line">class MyCache &#123;</span><br><span class="line"></span><br><span class="line">    private volatile Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; private Lock lock &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义写操作</span><br><span class="line">     * 满足：原子 + 独占</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void put(String key, Object value) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t 正在写入：&quot; + key);</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 模拟网络拥堵，延迟0.3秒</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(300);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t 写入完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void get(String key) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t 正在读取:&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 模拟网络拥堵，延迟0.3秒</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(300);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Object value &#x3D; map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t 读取完成：&quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class ReadWriteLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MyCache myCache &#x3D; new MyCache();</span><br><span class="line">        &#x2F;&#x2F; 线程操作资源类，5个线程写</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; lambda表达式内部必须是final</span><br><span class="line">            final int tempInt &#x3D; i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(tempInt + &quot;&quot;, tempInt +  &quot;&quot;);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 线程操作资源类， 5个线程读</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; lambda表达式内部必须是final</span><br><span class="line">            final int tempInt &#x3D; i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(tempInt + &quot;&quot;);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分别创建5个线程写入缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 线程操作资源类，5个线程写</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; lambda表达式内部必须是final</span><br><span class="line">    final int tempInt &#x3D; i;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        myCache.put(tempInt + &quot;&quot;, tempInt +  &quot;&quot;);</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5个线程读取缓存，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 线程操作资源类， 5个线程读</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; lambda表达式内部必须是final</span><br><span class="line">    final int tempInt &#x3D; i;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        myCache.get(tempInt + &quot;&quot;);</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0 正在写入：0</span><br><span class="line">4 正在写入：4</span><br><span class="line">3 正在写入：3</span><br><span class="line">1 正在写入：1</span><br><span class="line">2 正在写入：2</span><br><span class="line">0 正在读取:</span><br><span class="line">1 正在读取:</span><br><span class="line">2 正在读取:</span><br><span class="line">3 正在读取:</span><br><span class="line">4 正在读取:</span><br><span class="line">2 写入完成</span><br><span class="line">4 写入完成</span><br><span class="line">4 读取完成：null</span><br><span class="line">0 写入完成</span><br><span class="line">3 读取完成：null</span><br><span class="line">0 读取完成：null</span><br><span class="line">1 写入完成</span><br><span class="line">3 写入完成</span><br><span class="line">1 读取完成：null</span><br><span class="line">2 读取完成：null</span><br></pre></td></tr></table></figure><p>我们可以看到，在写入的时候，写操作都没其它线程打断了，这就造成了，还没写完，其它线程又开始写，这样就造成数据不一致</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>上面的代码是没有加锁的，这样就会造成线程在进行写入操作的时候，被其它线程频繁打断，从而不具备原子性，这个时候，我们就需要用到读写锁来解决了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 创建一个读写锁</span><br><span class="line">* 它是一个读写融为一体的锁，在使用的时候，需要转换</span><br><span class="line">*&#x2F;</span><br><span class="line">private ReentrantReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();</span><br></pre></td></tr></table></figure><p>当我们在进行写操作的时候，就需要转换成写锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个写锁</span><br><span class="line">rwLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写锁 释放</span><br><span class="line">rwLock.writeLock().unlock();</span><br></pre></td></tr></table></figure><p>当们在进行读操作的时候，在转换成读锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个读锁</span><br><span class="line">rwLock.readLock().lock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 读锁 释放</span><br><span class="line">rwLock.readLock().unlock();</span><br></pre></td></tr></table></figure><p>这里的读锁和写锁的区别在于，写锁一次只能一个线程进入，执行写操作，而读锁是多个线程能够同时进入，进行读取的操作</p><p>完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 读写锁</span><br><span class="line"> * 多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行</span><br><span class="line"> * 但是，如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 资源类</span><br><span class="line"> *&#x2F;</span><br><span class="line">class MyCache &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 缓存中的东西，必须保持可见性，因此使用volatile修饰</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private volatile Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 创建一个读写锁</span><br><span class="line">     * 它是一个读写融为一体的锁，在使用的时候，需要转换</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private ReentrantReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义写操作</span><br><span class="line">     * 满足：原子 + 独占</span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void put(String key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建一个写锁</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 正在写入：&quot; + key);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 模拟网络拥堵，延迟0.3秒</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(300);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            map.put(key, value);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 写入完成&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 写锁 释放</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取</span><br><span class="line">     * @param key</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void get(String key) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 读锁</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 正在读取:&quot;);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 模拟网络拥堵，延迟0.3秒</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(300);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object value &#x3D; map.get(key);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 读取完成：&quot; + value);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 读锁释放</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 清空缓存</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void clean() &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class ReadWriteLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MyCache myCache &#x3D; new MyCache();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 线程操作资源类，5个线程写</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; lambda表达式内部必须是final</span><br><span class="line">            final int tempInt &#x3D; i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(tempInt + &quot;&quot;, tempInt +  &quot;&quot;);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 线程操作资源类， 5个线程读</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; lambda表达式内部必须是final</span><br><span class="line">            final int tempInt &#x3D; i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(tempInt + &quot;&quot;);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1 正在写入：1</span><br><span class="line">1 写入完成</span><br><span class="line">2 正在写入：2</span><br><span class="line">2 写入完成</span><br><span class="line">3 正在写入：3</span><br><span class="line">3 写入完成</span><br><span class="line">4 正在写入：4</span><br><span class="line">4 写入完成</span><br><span class="line">5 正在写入：5</span><br><span class="line">5 写入完成</span><br><span class="line">2 正在读取:</span><br><span class="line">3 正在读取:</span><br><span class="line">1 正在读取:</span><br><span class="line">4 正在读取:</span><br><span class="line">5 正在读取:</span><br><span class="line">2 读取完成：2</span><br><span class="line">1 读取完成：1</span><br><span class="line">4 读取完成：4</span><br><span class="line">3 读取完成：3</span><br><span class="line">5 读取完成：5</span><br></pre></td></tr></table></figure><p>从运行结果我们可以看出，写入操作是一个一个线程进行执行的，并且中间不会被打断，而读操作的时候，是同时5个线程进入，然后并发读取操作</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java的锁 </tag>
            
            <tag> 独占锁 </tag>
            
            <tag> 共享锁 </tag>
            
            <tag> 互斥锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java锁之自旋锁</title>
      <link href="/2019/10/03/Java%E9%94%81%E4%B9%8B%E8%87%AA%E6%97%8B%E9%94%81/"/>
      <url>/2019/10/03/Java%E9%94%81%E4%B9%8B%E8%87%AA%E6%97%8B%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Java锁之自旋锁"><a href="#Java锁之自旋锁" class="headerlink" title="Java锁之自旋锁"></a>Java锁之自旋锁</h1><p>自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p><p>原来提到的比较并交换，底层使用的就是自旋，自旋就是多次尝试，多次访问，不会阻塞的状态就是自旋。</p><a id="more"></a><p><img data-src="image-20200315154143781.png" alt="image1"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：循环比较获取直到成功为止，没有类似于wait的阻塞</p><p>缺点：当不断自旋的线程越来越多的时候，会因为执行while循环不断的消耗CPU资源</p><h2 id="手写自旋锁"><a href="#手写自旋锁" class="headerlink" title="手写自旋锁"></a>手写自旋锁</h2><p>通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 手写一个自旋锁</span><br><span class="line"> *</span><br><span class="line"> * 循环比较获取直到成功为止，没有类似于wait的阻塞</span><br><span class="line"> *</span><br><span class="line"> * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SpinLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 现在的泛型装的是Thread，原子引用线程</span><br><span class="line">    AtomicReference&lt;Thread&gt;  atomicReference &#x3D; new AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void myLock() &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取当前进来的线程</span><br><span class="line">        Thread thread &#x3D; Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t come in &quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 开始自旋，期望值是null，更新值是当前线程，如果是null，则更新为当前线程，否者自旋</span><br><span class="line">        while(!atomicReference.compareAndSet(null, thread)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 解锁</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void myUnLock() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取当前进来的线程</span><br><span class="line">        Thread thread &#x3D; Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 自己用完了后，把atomicReference变成null</span><br><span class="line">        atomicReference.compareAndSet(thread, null);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t invoked myUnlock()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        SpinLockDemo spinLockDemo &#x3D; new SpinLockDemo();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 启动t1线程，开始操作</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 开始占有锁</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(5);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 开始释放锁</span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line"></span><br><span class="line">        &#125;, &quot;t1&quot;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 让main线程暂停1秒，使得t1线程，先执行</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 1秒后，启动t2线程，开始占用这个锁</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 开始占有锁</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            &#x2F;&#x2F; 开始释放锁</span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line"></span><br><span class="line">        &#125;, &quot;t2&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1 come in </span><br><span class="line">.....五秒后.....</span><br><span class="line">t1 invoked myUnlock()</span><br><span class="line">t2 come in </span><br><span class="line">t2 invoked myUnlock()</span><br></pre></td></tr></table></figure><p>首先输出的是 t1     come in </p><p>然后1秒后，t2线程启动，发现锁被t1占有，所有不断的执行 compareAndSet方法，来进行比较，直到t1释放锁后，也就是5秒后，t2成功获取到锁，然后释放</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 自旋锁 </tag>
            
            <tag> Java的锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java锁之可重入锁和递归锁</title>
      <link href="/2019/10/03/Java%E9%94%81%E4%B9%8B%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8C%E9%80%92%E5%BD%92%E9%94%81/"/>
      <url>/2019/10/03/Java%E9%94%81%E4%B9%8B%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8C%E9%80%92%E5%BD%92%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="可重入锁和递归锁ReentrantLock"><a href="#可重入锁和递归锁ReentrantLock" class="headerlink" title="可重入锁和递归锁ReentrantLock"></a>可重入锁和递归锁ReentrantLock</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>可重入锁就是递归锁</p><p>指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</p><p>也就是说：<code>线程可以进入任何一个它已经拥有的锁所同步的代码块</code></p><p>ReentrantLock / Synchronized 就是一个典型的可重入锁</p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>可重入锁就是，在一个method1方法中加入一把锁，方法2也加锁了，那么他们拥有的是同一把锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void method1() &#123;</span><br><span class="line">method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void method2() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说我们只需要进入method1后，那么它也能直接进入method2方法，因为他们所拥有的锁，是同一把。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>可重入锁的最大作用就是避免死锁</p><h2 id="可重入锁验证"><a href="#可重入锁验证" class="headerlink" title="可重入锁验证"></a>可重入锁验证</h2><h3 id="证明Synchronized"><a href="#证明Synchronized" class="headerlink" title="证明Synchronized"></a>证明Synchronized</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 可重入锁（也叫递归锁）</span><br><span class="line"> * 指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁</span><br><span class="line"> *</span><br><span class="line"> * 也就是说：&#96;线程可以进入任何一个它已经拥有的锁所同步的代码块&#96;</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 资源类</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Phone &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发送短信</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized void sendSMS() throws Exception&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t invoked sendSMS()&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 在同步方法中，调用另外一个同步方法</span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发邮件</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized void sendEmail() throws Exception&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId() + &quot;\t invoked sendEmail()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ReenterLockDemo &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone &#x3D; new Phone();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 两个线程操作资源列</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t1&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们编写了一个资源类phone，拥有两个加了synchronized的同步方法，分别是sendSMS 和 sendEmail，我们在sendSMS方法中，调用sendEmail。最后在主线程同时开启了两个线程进行测试，最后得到的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 invoked sendSMS()</span><br><span class="line">t1 invoked sendEmail()</span><br><span class="line">t2 invoked sendSMS()</span><br><span class="line">t2 invoked sendEmail()</span><br></pre></td></tr></table></figure><p>这就说明当 t1 线程进入sendSMS的时候，拥有了一把锁，同时t2线程无法进入，直到t1线程拿着锁，执行了sendEmail 方法后，才释放锁，这样t2才能够进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1 invoked sendSMS()      t1线程在外层方法获取锁的时候</span><br><span class="line">t1 invoked sendEmail()    t1在进入内层方法会自动获取锁</span><br><span class="line"></span><br><span class="line">t2 invoked sendSMS()      t2线程在外层方法获取锁的时候</span><br><span class="line">t2 invoked sendEmail()    t2在进入内层方法会自动获取锁</span><br></pre></td></tr></table></figure><h3 id="证明ReentrantLock"><a href="#证明ReentrantLock" class="headerlink" title="证明ReentrantLock"></a>证明ReentrantLock</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 资源类</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Phone implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * set进去的时候，就加锁，调用set方法的时候，能否访问另外一个加锁的set方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void getLock() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t get Lock&quot;);</span><br><span class="line">            setLock();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLock() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t set Lock&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        getLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ReenterLockDemo &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone &#x3D; new Phone();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 因为Phone实现了Runnable接口</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Thread t3 &#x3D; new Thread(phone, &quot;t3&quot;);</span><br><span class="line">        Thread t4 &#x3D; new Thread(phone, &quot;t4&quot;);</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们使用ReentrantLock进行验证，首先资源类实现了Runnable接口，重写Run方法，里面调用get方法，get方法在进入的时候，就加了锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void getLock() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t get Lock&quot;);</span><br><span class="line">        setLock();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在方法里面，又调用另外一个加了锁的setLock方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void setLock() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t set Lock&quot;);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果我们能发现，结果和加synchronized方法是一致的，都是在外层的方法获取锁之后，线程能够直接进入里层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br><span class="line">t4 get Lock</span><br><span class="line">t4 set Lock</span><br></pre></td></tr></table></figure><p><strong>当我们在getLock方法加两把锁会是什么情况呢？</strong>  (阿里面试)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void getLock() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t get Lock&quot;);</span><br><span class="line">        setLock();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后得到的结果也是一样的，因为里面不管有几把锁，其它他们都是同一把锁，也就是说用同一个钥匙都能够打开</p><p><strong>当我们在getLock方法加两把锁，但是只解一把锁会出现什么情况呢？</strong></p><pre><code>public void getLock() {    lock.lock();    lock.lock();    try {        System.out.println(Thread.currentThread().getName() + &quot;\t get Lock&quot;);        setLock();    } finally {        lock.unlock();        lock.unlock();    }}</code></pre><p>得到结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br></pre></td></tr></table></figure><p>也就是说程序直接卡死，线程不能出来，也就说明我们申请几把锁，最后需要解除几把锁</p><p><strong>当我们只加一把锁，但是用两把锁来解锁的时候，又会出现什么情况呢？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void getLock() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t get Lock&quot;);</span><br><span class="line">        setLock();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，运行程序会直接报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">t3 get Lock</span><br><span class="line">t3 set Lock</span><br><span class="line">t4 get Lock</span><br><span class="line">t4 set Lock</span><br><span class="line">Exception in thread &quot;t3&quot; Exception in thread &quot;t4&quot; java.lang.IllegalMonitorStateException</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">java.lang.IllegalMonitorStateException</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)</span><br><span class="line">at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java的锁 </tag>
            
            <tag> 可重入锁 </tag>
            
            <tag> 递归锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java锁之公平锁和非公平锁</title>
      <link href="/2019/10/03/Java%E9%94%81%E4%B9%8B%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/"/>
      <url>/2019/10/03/Java%E9%94%81%E4%B9%8B%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Java锁之公平锁和非公平锁"><a href="#Java锁之公平锁和非公平锁" class="headerlink" title="Java锁之公平锁和非公平锁"></a>Java锁之公平锁和非公平锁</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>是指多个线程按照申请锁的顺序来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是队列</p><h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的线程（也就是某个线程一直得不到锁）</p><a id="more"></a><h2 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h2><p>并发包中ReentrantLock的创建可以指定析构函数的boolean类型来得到公平锁或者非公平锁，默认是非公平锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁</span><br><span class="line">*&#x2F;</span><br><span class="line">Lock lock &#x3D; new ReentrantLock(true);</span><br></pre></td></tr></table></figure><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p><strong>公平锁</strong>：就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，就占用锁，否者就会加入到等待队列中，以后安装FIFO的规则从队列中取到自己</p><p><strong>非公平锁：</strong> 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>Java ReenttrantLock通过构造函数指定该锁是否公平，默认是非公平锁，因为非公平锁的优点在于吞吐量比公平锁大，<code>对于synchronized而言，也是一种非公平锁</code></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java的锁 </tag>
            
            <tag> 公平锁 </tag>
            
            <tag> 非公平锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Java中传值和传址的分析</title>
      <link href="/2019/10/02/%E5%AF%B9Java%E4%B8%AD%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E5%9D%80%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2019/10/02/%E5%AF%B9Java%E4%B8%AD%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E5%9D%80%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h1><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 值传递和引用传递</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Person &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String personName;</span><br><span class="line"></span><br><span class="line">    public Person(String personName) &#123;</span><br><span class="line">        this.personName &#x3D; personName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TransferValueDemo &#123;</span><br><span class="line"></span><br><span class="line">    public void changeValue1(int age) &#123;</span><br><span class="line">        age &#x3D; 30;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void changeValue2(Person person) &#123;</span><br><span class="line">        person.setPersonName(&quot;XXXX&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void changeValue3(String str) &#123;</span><br><span class="line">        str &#x3D; &quot;XXX&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TransferValueDemo test &#x3D; new TransferValueDemo();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 定义基本数据类型</span><br><span class="line">        int age &#x3D; 20;</span><br><span class="line">        test.changeValue1(age);</span><br><span class="line">        System.out.println(&quot;age ----&quot; + age);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 实例化person类</span><br><span class="line">        Person person &#x3D; new Person(&quot;abc&quot;);</span><br><span class="line">        test.changeValue2(person);</span><br><span class="line">        System.out.println(&quot;personName-----&quot; + person.getPersonName());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; String</span><br><span class="line">        String str &#x3D; &quot;abc&quot;;</span><br><span class="line">        test.changeValue3(str);</span><br><span class="line">        System.out.println(&quot;string-----&quot; + str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age ----20</span><br><span class="line">personName-----XXXX</span><br><span class="line">string-----abc</span><br></pre></td></tr></table></figure><h2 id="changeValue1的执行过程"><a href="#changeValue1的执行过程" class="headerlink" title="changeValue1的执行过程"></a>changeValue1的执行过程</h2><p>八种基本数据类型，在栈里面分配内存，属于值传递</p><p><code>栈管运行，堆管存储</code></p><p>当们执行 changeValue1的时候，因为int是基本数据类型，所以传递的是int = 20这个值，相当于传递的是一个副本，main方法里面的age并没有改变，因此输出的结果 age还是20，属于值传递</p><p><img data-src="image-20200314185317851.png" alt="image-1"></p><h2 id="changeValue2的执行过程"><a href="#changeValue2的执行过程" class="headerlink" title="changeValue2的执行过程"></a>changeValue2的执行过程</h2><p>因为Person是属于对象，传递的是内存地址，当执行changeValue2的时候，会改变内存中的Person的值，属于引用传递，两个指针都是指向同一个地址</p><p><img data-src="image-20200314185528034.png" alt="image-2"></p><h2 id="changeValue3的执行过程"><a href="#changeValue3的执行过程" class="headerlink" title="changeValue3的执行过程"></a>changeValue3的执行过程</h2><p>String不属于基本数据类型，但是为什么执行完成后，还是abc呢？</p><p>这是因为String的特殊性，当我们执行String str = “abc”的时候，它会把 <code>abc</code> 放入常量池中</p><p><img data-src="image-20200314190021466.png" alt="image-3"></p><p>当我们执行changeValue3的时候，会重新新建一个xxx，并没有销毁abc，然后指向xxx，然后最后我们输出的是main中的引用，还是指向的abc，因此最后输出结果还是abc。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 值传递 </tag>
            
            <tag> 址传递 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对ArrayList线程不安全的分析</title>
      <link href="/2019/10/02/%E5%AF%B9ArrayList%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2019/10/02/%E5%AF%B9ArrayList%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Collection线程不安全的举例"><a href="#Collection线程不安全的举例" class="headerlink" title="Collection线程不安全的举例"></a>Collection线程不安全的举例</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1、当我们执行下面语句的时候，底层进行了什么操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p>底层创建了一个空的数组，伴随着初始值为10</p><p>当执行add方法后，如果超过了10，那么会进行扩容，扩容的大小为原值的一半，也就是5个，使用下列方法扩容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.copyOf(elementData, netCapacity)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="单线程环境下"><a href="#单线程环境下" class="headerlink" title="单线程环境下"></a>单线程环境下</h2><p>单线程环境的ArrayList是不会有问题的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayListNotSafeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;a&quot;);</span><br><span class="line">        list.add(&quot;b&quot;);</span><br><span class="line">        list.add(&quot;c&quot;);</span><br><span class="line"></span><br><span class="line">        for(String element : list) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程环境"><a href="#多线程环境" class="headerlink" title="多线程环境"></a>多线程环境</h2><p>为什么ArrayList是线程不安全的？因为在进行写操作的时候，方法上为了保证并发性，是没有添加synchronized修饰，所以并发写的时候，就会出现问题</p><p><img data-src="image-20200312202720715.png" alt="image1"></p><p>当我们同时启动30个线程去操作List的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 集合类线程不安全举例</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ArrayListNotSafeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(0, 8));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候出现了错误，也就是java.util.ConcurrentModificationException</p><p><img data-src="image-20200312205142763.png" alt="image2"></p><p>这个异常是 并发修改的异常</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一：Vector"><a href="#方案一：Vector" class="headerlink" title="方案一：Vector"></a>方案一：Vector</h3><p>第一种方法，就是不用ArrayList这种不安全的List实现类，而采用Vector，线程安全的</p><p>关于Vector如何实现线程安全的，而是在方法上加了锁，即synchronized</p><p><img data-src="image-20200312210401865.png" alt="image3"></p><p>这样就每次只能够一个线程进行操作，所以不会出现线程不安全的问题，但是因为加锁了，导致并发性基于下降</p><h3 id="方案二：Collections-synchronized"><a href="#方案二：Collections-synchronized" class="headerlink" title="方案二：Collections.synchronized()"></a>方案二：Collections.synchronized()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure><p>采用Collections集合工具类，在ArrayList外面包装一层 同步 机制</p><h3 id="方案三：采用JUC里面的方法"><a href="#方案三：采用JUC里面的方法" class="headerlink" title="方案三：采用JUC里面的方法"></a>方案三：采用JUC里面的方法</h3><p>CopyOnWriteArrayList：写时复制，主要是一种读写分离的思想</p><p>写时复制，CopyOnWrite容器即写时复制的容器，往一个容器中添加元素的时候，不直接往当前容器Object[]添加，而是先将Object[]进行copy，复制出一个新的容器object[] newElements，然后新的容器Object[] newElements里添加原始，添加元素完后，在将原容器的引用指向新的容器 setArray(newElements)；这样做的好处是可以对copyOnWrite容器进行并发的度，而不需要加锁，因为当前容器不需要添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器</p><p>就是写的时候，把ArrayList扩容一个出来，然后把值填写上去，在通知其他的线程，ArrayList的引用指向扩容后的</p><p>查看底层add方法源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements &#x3D; getArray();</span><br><span class="line">        int len &#x3D; elements.length;</span><br><span class="line">        Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] &#x3D; e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要加锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">lock.lock();</span><br></pre></td></tr></table></figure><p>然后在末尾扩容一个单位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] elements &#x3D; getArray();</span><br><span class="line">int len &#x3D; elements.length;</span><br><span class="line">Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);</span><br></pre></td></tr></table></figure><p>然后在把扩容后的空间，填写上需要add的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newElements[len] &#x3D; e;</span><br></pre></td></tr></table></figure><p>最后把内容set到Array中</p><h2 id="HashSet线程不安全"><a href="#HashSet线程不安全" class="headerlink" title="HashSet线程不安全"></a>HashSet线程不安全</h2><h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><p>底层还是使用CopyOnWriteArrayList进行实例化</p><p><img data-src="image-20200312221602095.png" alt="image4"></p><h3 id="HashSet底层结构"><a href="#HashSet底层结构" class="headerlink" title="HashSet底层结构"></a>HashSet底层结构</h3><p>同理HashSet的底层结构就是HashMap</p><p><img data-src="image-20200312221735178.png" alt="image5"></p><p>但是为什么我调用 HashSet.add()的方法，只需要传递一个元素，而HashMap是需要传递key-value键值对？</p><p>首先我们查看hashSet的add方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)&#x3D;&#x3D;null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们能发现但我们调用add的时候，存储一个值进入map中，只是作为key进行存储，而value存储的是一个Object类型的常量，也就是说HashSet只关心key，而不关心value</p><h2 id="HashMap线程不安全"><a href="#HashMap线程不安全" class="headerlink" title="HashMap线程不安全"></a>HashMap线程不安全</h2><p>同理HashMap在多线程环境下，也是不安全的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 8));</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>1、使用Collections.synchronizedMap(new HashMap&lt;&gt;());</p><p>2、使用 ConcurrentHashMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
            <tag> java </tag>
            
            <tag> Collection </tag>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原子类AtomicInteger的ABA问题</title>
      <link href="/2019/10/01/%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicInteger%E7%9A%84ABA%E9%97%AE%E9%A2%98/"/>
      <url>/2019/10/01/%E5%8E%9F%E5%AD%90%E7%B1%BBAtomicInteger%E7%9A%84ABA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="原子类AtomicInteger的ABA问题"><a href="#原子类AtomicInteger的ABA问题" class="headerlink" title="原子类AtomicInteger的ABA问题"></a>原子类AtomicInteger的ABA问题</h1><h2 id="连环问题"><a href="#连环问题" class="headerlink" title="连环问题"></a>连环问题</h2><p>从AtomicInteger引出下面的问题</p><p>CAS -&gt; Unsafe -&gt; CAS底层思想 -&gt; ABA -&gt; 原子引用更新 -&gt; 如何规避ABA问题</p><h2 id="ABA问题是什么"><a href="#ABA问题是什么" class="headerlink" title="ABA问题是什么"></a>ABA问题是什么</h2><a id="more"></a><p>可以理解成“狸猫”换“太子”</p><p><img data-src="image-20200311212442057.png" alt="image1"></p><p>假设现在有两个线程，分别是T1 和 T2，然后T1执行某个操作的时间为10秒，T2执行某个时间的操作是2秒，最开始AB两个线程，分别从主内存中获取A值，但是因为B的执行速度更快，他先把A的值改成B，然后在修改成A，然后执行完毕，T1线程在10秒后，执行完毕，判断内存中的值为A，并且和自己预期的值一样，它就认为没有人更改了主内存中的值，就快乐的修改成B，但是实际上 可能中间经历了 ABCDEFA 这个变换，也就是中间的值经历了狸猫换太子。</p><p>所以ABA问题就是，在进行获取主内存值的时候，该内存值在我们写入主内存的时候，已经被修改了N次，但是最终又改成原来的值了</p><h2 id="CAS导致ABA问题"><a href="#CAS导致ABA问题" class="headerlink" title="CAS导致ABA问题"></a>CAS导致ABA问题</h2><p>CAS算法实现了一个重要的前提，需要取出内存中某时刻的数据，并在当下时刻比较并替换，那么这个时间差会导致数据的变化。</p><p>比如说一个线程one从内存位置V中取出A，这时候另外一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功</p><p><code>尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的</code></p><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>CAS只管开头和结尾，也就是头和尾是一样，那就修改成功，中间的这个过程，可能会被人修改过</p><h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><p>原子引用其实和原子包装类是差不多的概念，就是将一个java类，用原子引用类进行包装起来，那么这个类就具备了原子性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 原子引用</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: </span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    String userName;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    public User(String userName, int age) &#123;</span><br><span class="line">        this.userName &#x3D; userName;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUserName() &#123;</span><br><span class="line">        return userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName &#x3D; userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;userName&#x3D;&#39;&quot; + userName + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, age&#x3D;&quot; + age +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class AtomicReferenceDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        User z3 &#x3D; new User(&quot;z3&quot;, 22);</span><br><span class="line"></span><br><span class="line">        User l4 &#x3D; new User(&quot;l4&quot;, 25);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建原子引用包装类</span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference &#x3D; new AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 现在主物理内存的共享变量，为z3</span><br><span class="line">        atomicReference.set(z3);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 比较并交换，如果现在主物理内存的值为z3，那么交换成l4</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + &quot;\t &quot; + atomicReference.get().toString());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 比较并交换，现在主物理内存的值是l4了，但是预期为z3，因此交换失败</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + &quot;\t &quot; + atomicReference.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于原子引用的ABA问题"><a href="#基于原子引用的ABA问题" class="headerlink" title="基于原子引用的ABA问题"></a>基于原子引用的ABA问题</h3><p>我们首先创建了两个线程，然后T1线程，执行一次ABA的操作，T2线程在一秒后修改主内存的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * ABA问题的解决，AtomicStampedReference</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ABADemo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 普通的原子引用包装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static AtomicReference&lt;Integer&gt; atomicReference &#x3D; new AtomicReference&lt;&gt;(100);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 把100 改成 101 然后在改成100，也就是ABA</span><br><span class="line">            atomicReference.compareAndSet(100, 101);</span><br><span class="line">            atomicReference.compareAndSet(101, 100);</span><br><span class="line">        &#125;, &quot;t1&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 睡眠一秒，保证t1线程，完成了ABA操作</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 把100 改成 101 然后在改成100，也就是ABA</span><br><span class="line">            System.out.println(atomicReference.compareAndSet(100, 2019) + &quot;\t&quot; + atomicReference.get());</span><br><span class="line"></span><br><span class="line">        &#125;, &quot;t2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，它能够成功的修改，这就是ABA问题</p><p><img data-src="image-20200312154752973.png" alt="image2"></p><h2 id="解决ABA问题"><a href="#解决ABA问题" class="headerlink" title="解决ABA问题"></a>解决ABA问题</h2><p>新增一种机制，也就是修改版本号，类似于时间戳的概念</p><p>T1：  100 1                      2019 2</p><p>T2：  100 1     101 2       100  3</p><p>如果T1修改的时候，版本号为2，落后于现在的版本号3，所以要重新获取最新值，这里就提出了一个使用时间戳版本号，来解决ABA问题的思路</p><h2 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h2><p>时间戳原子引用，来这里应用于版本号的更新，也就是每次更新的时候，需要比较期望值和当前值，以及期望版本号和当前版本号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * ABA问题的解决，AtomicStampedReference</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ABADemo &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 普通的原子引用包装类</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static AtomicReference&lt;Integer&gt; atomicReference &#x3D; new AtomicReference&lt;&gt;(100);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 传递两个值，一个是初始值，一个是初始版本号</span><br><span class="line">    static AtomicStampedReference&lt;Integer&gt; atomicStampedReference &#x3D; new AtomicStampedReference&lt;&gt;(100, 1);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;以下是ABA问题的产生&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 把100 改成 101 然后在改成100，也就是ABA</span><br><span class="line">            atomicReference.compareAndSet(100, 101);</span><br><span class="line">            atomicReference.compareAndSet(101, 100);</span><br><span class="line">        &#125;, &quot;t1&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 睡眠一秒，保证t1线程，完成了ABA操作</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 把100 改成 101 然后在改成100，也就是ABA</span><br><span class="line">            System.out.println(atomicReference.compareAndSet(100, 2019) + &quot;\t&quot; + atomicReference.get());</span><br><span class="line"></span><br><span class="line">        &#125;, &quot;t2&quot;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;以下是ABA问题的解决&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 获取版本号</span><br><span class="line">            int stamp &#x3D; atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 第一次版本号&quot; + stamp);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 暂停t3一秒钟</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 传入4个值，期望值，更新值，期望版本号，更新版本号</span><br><span class="line">            atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+1);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 第二次版本号&quot; + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+1);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 第三次版本号&quot; + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        &#125;, &quot;t3&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 获取版本号</span><br><span class="line">            int stamp &#x3D; atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 第一次版本号&quot; + stamp);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 暂停t4 3秒钟，保证t3线程也进行一次ABA问题</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            boolean result &#x3D; atomicStampedReference.compareAndSet(100, 2019, stamp, stamp+1);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 修改成功否：&quot; + result + &quot;\t 当前最新实际版本号：&quot; + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t 当前实际最新值&quot; + atomicStampedReference.getReference());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;, &quot;t4&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><p><img data-src="image-20200312200434776.png" alt="image3"></p><p>我们能够发现，线程t3，在进行ABA操作后，版本号变更成了3，而线程t4在进行操作的时候，就出现操作失败了，因为版本号和当初拿到的不一样</p><h2 id="LongAdder（CAS机制优化）"><a href="#LongAdder（CAS机制优化）" class="headerlink" title="LongAdder（CAS机制优化）"></a>LongAdder（CAS机制优化）</h2><p>LongAdder是java8为我们提供的新的类，跟AtomicLong有相同的效果。是对CAS机制的优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LongAdder：</span><br><span class="line">&#x2F;&#x2F;变量声明</span><br><span class="line">public static LongAdder count &#x3D; new LongAdder();</span><br><span class="line">&#x2F;&#x2F;变量操作</span><br><span class="line">count.increment();</span><br><span class="line">&#x2F;&#x2F;变量取值</span><br><span class="line">count</span><br></pre></td></tr></table></figure><h3 id="为什么有了AtomicLong还要新增一个LongAdder呢"><a href="#为什么有了AtomicLong还要新增一个LongAdder呢" class="headerlink" title="为什么有了AtomicLong还要新增一个LongAdder呢"></a>为什么有了AtomicLong还要新增一个LongAdder呢</h3><p>原因是：CAS底层实现是在一个死循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈的时候，修改成功率很高，否则失败率很高。在失败的时候，这些重复的原子性操作会耗费性能。（不停的<strong>自旋</strong>，进入一个无限重复的循环中）</p><p><img data-src="image-20200429085540554.png" alt="image4"></p><p><strong>核心思想：将热点数据分离。</strong></p><p>比如说它可以将AtomicLong内部的内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法映射到其中一个数字进行计数，而最终的计数结果则为这个数组的求和累加，其中热点数据value会被分离成多个单元的cell，每个cell独自维护内部的值。当前对象的实际值由所有的cell累计合成，这样热点就进行了有效地分离，并提高了并行度。这相当于将AtomicLong的单点的更新压力分担到各个节点上。在低并发的时候通过对base的直接更新，可以保障和AtomicLong的性能基本一致。而在高并发的时候通过分散提高了性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void increment() &#123;</span><br><span class="line">    add(1L);</span><br><span class="line">&#125;</span><br><span class="line">public void add(long x) &#123;</span><br><span class="line">    Cell[] as; long b, v; int m; Cell a;</span><br><span class="line">    if ((as &#x3D; cells) !&#x3D; null || !casBase(b &#x3D; base, b + x)) &#123;</span><br><span class="line">        boolean uncontended &#x3D; true;</span><br><span class="line">        if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||</span><br><span class="line">            (a &#x3D; as[getProbe() &amp; m]) &#x3D;&#x3D; null ||</span><br><span class="line">            !(uncontended &#x3D; a.cas(v &#x3D; a.value, v + x)))</span><br><span class="line">            longAccumulate(x, null, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个CAS有没有问题呢？肯定是有的。比如说大量的线程同时并发修改一个AtomicInteger，可能有<strong>很多线程会不停的自旋</strong>，进入一个无限重复的循环中。</p><p>这些线程不停地获取值，然后发起CAS操作，但是发现这个值被别人改过了，于是再次进入下一个循环，获取值，发起CAS操作又失败了，再次进入下一个循环。</p><p>在大量线程高并发更新AtomicInteger的时候，这种问题可能会比较明显，导致大量线程空循环，自旋转，性能和效率都不是特别好。</p><p>于是，当当当当，Java 8推出了一个新的类，<strong>LongAdder</strong>，他就是尝试使用分段CAS以及自动分段迁移的方式来大幅度提升多线程高并发执行CAS操作的性能！</p><p><img data-src="image-20200429085141487.png" alt="image5"></p><p>在LongAdder的底层实现中，首先有一个base值，刚开始多线程来不停的累加数值，都是对base进行累加的，比如刚开始累加成了base = 5。</p><p>接着如果发现并发更新的线程数量过多，在发生竞争的情况下，会有一个Cell数组用于将不同线程的操作离散到不同的节点上去 ==(会根据需要扩容，最大为CPU核）==就会开始施行<strong>分段CAS的机制</strong>，也就是内部会搞一个Cell数组，每个数组是一个数值分段。</p><p>这时，让大量的线程分别去对不同Cell内部的value值进行CAS累加操作，这样就把CAS计算压力分散到了不同的Cell分段数值中了！</p><p>这样就可以大幅度的降低多线程并发更新同一个数值时出现的无限循环的问题，大幅度提升了多线程并发更新数值的性能和效率！</p><p>而且他内部实现了<strong>自动分段迁移的机制</strong>，也就是如果某个Cell的value执行CAS失败了，那么就会自动去找另外一个Cell分段内的value值进行CAS操作。</p><p>这样也解决了线程空旋转、自旋不停等待执行CAS操作的问题，让一个线程过来执行CAS时可以尽快的完成这个操作。</p><p>最后，如果你要从LongAdder中获取当前累加的总值，就会把base值和所有Cell分段数值加起来返回给你。</p><p><img data-src="image-20200429085957778.png" alt="image6"></p><p>如上图所示，LongAdder则是内部维护多个Cell变量，每个Cell里面有一个初始值为0的long型变量，在同等并发量的情况下，争夺单个变量的线程会减少，这是变相的减少了争夺共享资源的并发量，另外多个线程在争夺同一个原子变量时候，</p><p>如果失败并不是自旋CAS重试，而是尝试获取其他原子变量的锁，最后当获取当前值时候是把所有变量的值累加后再加上base的值返回的。</p><p>LongAdder维护了要给延迟初始化的原子性更新数组和一个基值变量base数组的大小保持是2的N次方大小，数组表的下标使用每个线程的hashcode值的掩码表示，数组里面的变量实体是Cell类型。</p><p>Cell 类型是Atomic的一个改进，用来减少缓存的争用，对于大多数原子操作字节填充是浪费的，因为原子操作都是无规律的分散在内存中进行的，多个原子性操作彼此之间是没有接触的，但是原子性数组元素彼此相邻存放将能经常共享缓存行，也就是<strong>伪共享</strong>。所以这在性能上是一个提升。（补充：可以看到Cell类用Contended注解修饰，这里主要是解决false sharing(伪共享的问题)，不过个人认为伪共享翻译的不是很好，或者应该是错误的共享，比如两个volatile变量被分配到了同一个缓存行，但是这两个的更新在高并发下会竞争，比如线程A去更新变量a，线程B去更新变量b，但是这两个变量被分配到了同一个缓存行，因此会造成每个线程都去争抢缓存行的所有权，例如A获取了所有权然后执行更新这时由于volatile的语义会造成其刷新到主存，但是由于变量b也被缓存到同一个缓存行，因此就会造成cache miss，这样就会造成极大的性能损失）<br><strong>LongAdder的add操作图</strong></p><p><img data-src="image-20200429090249633.png" alt="image7"></p><p>可以看到，只有从未出现过并发冲突的时候，base基数才会使用到，一旦出现了并发冲突，之后所有的操作都只针对Cell[]数组中的单元Cell。<br>如果Cell[]数组未初始化，会调用父类的longAccumelate去初始化Cell[]，如果Cell[]已经初始化但是冲突发生在Cell单元内，则也调用父类的longAccumelate，此时可能就需要对Cell[]扩容了。<br><strong>另外由于Cells占用内存是相对比较大的，所以一开始并不创建，而是在需要时候再创建，也就是惰性加载，当一开始没有空间时候，所有的更新都是操作base变量。</strong></p><p><img data-src="image-20200429090556928.png" alt="image8"></p><p>如上图代码：<br>例如32、64位操作系统的缓存行大小不一样，因此JAVA8中就增加了一个注<code>@sun.misc.Contended</code>解用于解决这个问题,由JVM去插入这些变量，<a href="http://xn--openjdk-hc5k25at0ntqhnpa7548b.java.net/jeps/142" target="_blank" rel="noopener">具体可以参考openjdk.java.net/jeps/142</a> ，但是通常来说对象是不规则的分配到内存中的，但是数组由于是连续的内存，因此可能会共享缓存行，因此这里加一个Contended注解以防cells数组发生伪共享的情况。</p><p>为了降低高并发下多线程对一个变量CAS争夺失败后大量线程会自旋而造成降低并发性能问题，LongAdder内部通过根据并发请求量来维护多个Cell元素(一个动态的Cell数组)来分担对单个变量进行争夺资源。</p><p><img data-src="image-20200429090713078.png" alt="image9"></p><p>可以看到LongAdder继承自Striped64类，Striped64内部维护着三个变量，LongAdder的真实值其实就是base的值与Cell数组里面所有Cell元素值的累加，base是个基础值，默认是0，cellBusy用来实现自旋锁，当创建Cell元素或者扩容Cell数组时候用来进行线程间的同步。</p><p>在无竞争下直接更新base，类似AtomicLong高并发下，会将每个线程的操作hash到不同的cells数组中，从而将AtomicLong中更新一个value的行为优化之后，分散到多个value中<br>从而降低更新热点，而需要得到当前值的时候，直接 将所有cell中的value与base相加即可，但是跟AtomicLong(compare and change -&gt; xadd)的CAS不同，incrementAndGet操作及其变种可以返回更新后的值，而LongAdder返回的是void。</p><p>由于Cell相对来说比较占内存，因此这里采用懒加载的方式，在无竞争的情况下直接更新base域，在第一次发生竞争的时候(CAS失败)就会创建一个大小为2的cells数组，每次扩容都是加倍，只到达到CPU核数。同时我们知道扩容数组等行为需要只能有一个线程同时执行，因此需要一个锁，这里通过CAS更新cellsBusy来实现一个简单的spin lock。</p><p>数组访问索引是通过Thread里的threadLocalRandomProbe域取模实现的，这个域是ThreadLocalRandom更新的，cells的数组大小被限制为CPU的核数，因为即使有超过核数个线程去更新，但是每个线程也只会和一个CPU绑定，更新的时候顶多会有cpu核数个线程，因此我们只需要通过hash将不同线程的更新行为离散到不同的slot即可。<br>我们知道线程、线程池会被关闭或销毁，这个时候可能这个线程之前占用的slot就会变成没人用的，但我们也不能清除掉，因为一般web应用都是长时间运行的，线程通常也会动态创建、销毁，很可能一段时间后又会被其他线程占用，而对于短时间运行的，例如单元测试，清除掉有啥意义呢？</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java原子类 </tag>
            
            <tag> ABA问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS底层原理分析</title>
      <link href="/2019/10/01/CAS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2019/10/01/CAS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>CAS的全称是Compare-And-Swap，它是CPU并发原语</p><p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的</p><p>CAS并发原语体现在Java语言中就是sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作，再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致的问题，也就是说CAS是线程安全的。</p><a id="more"></a><h2 id="代码使用"><a href="#代码使用" class="headerlink" title="代码使用"></a>代码使用</h2><p>首先调用AtomicInteger创建了一个实例， 并初始化为5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个原子类</span><br><span class="line">AtomicInteger atomicInteger &#x3D; new AtomicInteger(5);</span><br></pre></td></tr></table></figure><p>然后调用CAS方法，企图更新成2019，这里有两个参数，一个是5，表示期望值，第二个就是我们要更新的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomicInteger.compareAndSet(5, 2019)</span><br></pre></td></tr></table></figure><p>然后再次使用了一个方法，同样将值改成1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomicInteger.compareAndSet(5, 1024)</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * CASDemo</span><br><span class="line"> *</span><br><span class="line"> * 比较并交换：compareAndSet</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CASDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建一个原子类</span><br><span class="line">        AtomicInteger atomicInteger &#x3D; new AtomicInteger(5);</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改</span><br><span class="line">         * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019</span><br><span class="line">         *&#x2F;</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(5, 2019) + &quot;\t current data: &quot; + atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(5, 1024) + &quot;\t current data: &quot; + atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的执行结果为</p><p><img data-src="image-20200310201327734.png" alt="image1"></p><p>这是因为我们执行第一个的时候，期望值和原本值是满足的，因此修改成功，但是第二次后，主内存的值已经修改成了2019，不满足期望值，因此返回了false，本次写入失败</p><p><img data-src="image-20200310201311367.png" alt="image2"></p><p>这个就类似于SVN或者Git的版本号，如果没有人更改过，就能够正常提交，否者需要先将代码pull下来，合并代码后，然后提交</p><h2 id="CAS底层原理-1"><a href="#CAS底层原理-1" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><p>首先我们先看看 atomicInteger.getAndIncrement()方法的源码</p><p><img data-src="image-20200310203030720.png" alt="image3"></p><p>从这里能够看到，底层又调用了一个unsafe类的getAndAddInt方法</p><h3 id="1、unsafe类"><a href="#1、unsafe类" class="headerlink" title="1、unsafe类"></a>1、unsafe类</h3><p><img data-src="image-20200310203350122.png" alt="image4"></p><p>Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（Native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定的内存数据。Unsafe类存在sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中的CAS操作的执行依赖于Unsafe类的方法。</p><p><code>注意Unsafe类的所有方法都是native修饰的，也就是说unsafe类中的方法都直接调用操作系统底层资源执行相应的任务</code></p><p>为什么Atomic修饰的包装类，能够保证原子性，依靠的就是底层的unsafe类</p><h3 id="2、变量valueOffset"><a href="#2、变量valueOffset" class="headerlink" title="2、变量valueOffset"></a>2、变量valueOffset</h3><p>表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。</p><p><img data-src="image-20200310203030720.png" alt="image5"></p><p>从这里我们能够看到，通过valueOffset，直接通过内存地址，获取到值，然后进行加1的操作</p><h3 id="3、变量value用volatile修饰"><a href="#3、变量value用volatile修饰" class="headerlink" title="3、变量value用volatile修饰"></a>3、变量value用volatile修饰</h3><p>保证了多线程之间的内存可见性</p><p><img data-src="image-20200310210701761.png" alt="image6"></p><p>var5：就是我们从主内存中拷贝到工作内存中的值</p><p>那么操作的时候，需要比较工作内存中的值，和主内存中的值进行比较</p><p>假设执行 compareAndSwapInt返回false，那么就一直执行 while方法，直到期望的值和真实值一样</p><ul><li>val1：AtomicInteger对象本身</li><li>var2：该对象值得引用地址</li><li>var4：需要变动的数量</li><li>var5：用var1和var2找到的内存中的真实值<ul><li>用该对象当前的值与var5比较</li><li>如果相同，更新var5 + var4 并返回true</li><li>如果不同，继续取值然后再比较，直到更新完成</li></ul></li></ul><p>这里没有用synchronized，而用CAS，这样提高了并发性，也能够实现一致性，是因为每个线程进来后，进入的do while循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作。</p><p>假设线程A和线程B同时执行getAndInt操作（分别跑在不同的CPU上）</p><ol><li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的 value 为3，根据JMM模型，线程A和线程B各自持有一份价值为3的副本，分别存储在各自的工作内存</li><li>线程A通过getIntVolatile(var1 , var2) 拿到value值3，这是线程A被挂起（该线程失去CPU执行权）</li><li>线程B也通过getIntVolatile(var1, var2)方法获取到value值也是3，此时刚好线程B没有被挂起，并执行了compareAndSwapInt方法，比较内存的值也是3，成功修改内存值为4，线程B打完收工，一切OK</li><li>这是线程A恢复，执行CAS方法，比较发现自己手里的数字3和主内存中的数字4不一致，说明该值已经被其它线程抢先一步修改过了，那么A线程本次修改失败，只能够重新读取后在来一遍了，也就是在执行do while</li><li>线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。</li></ol><p>Unsafe类 + CAS思想： 也就是自旋，自我旋转</p><h2 id="底层汇编"><a href="#底层汇编" class="headerlink" title="底层汇编"></a>底层汇编</h2><p>Unsafe类中的compareAndSwapInt是一个本地方法，该方法的实现位于unsafe.cpp中</p><ul><li>先想办法拿到变量value在内存中的地址</li><li>通过Atomic::cmpxchg实现比较替换，其中参数X是即将更新的值，参数e是原内存的值</li></ul><h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><p>CAS不加锁，保证一次性，但是需要多次比较</p><ul><li>循环时间长，开销大（因为执行的是do while，如果比较不成功一直在循环，最差的情况，就是某个线程一直取到的值和预期值都不一样，这样就会无限循环）</li><li>只能保证一个共享变量的原子操作<ul><li>当对一个共享变量执行操作时，我们可以通过循环CAS的方式来保证原子操作</li><li>但是对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候只能用锁来保证原子性</li></ul></li><li>引出来ABA问题？</li></ul><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>。。。。。。。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS是compareAndSwap，比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否者继续比较直到主内存和工作内存的值一致为止</p><h3 id="CAS应用"><a href="#CAS应用" class="headerlink" title="CAS应用"></a>CAS应用</h3><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否者什么都不做</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> Java </tag>
            
            <tag> 自旋锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volatile的应用（DCL单例模式）</title>
      <link href="/2019/09/30/Volatile%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88DCL%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%89/"/>
      <url>/2019/09/30/Volatile%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88DCL%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Volatile的应用"><a href="#Volatile的应用" class="headerlink" title="Volatile的应用"></a>Volatile的应用</h1><h2 id="单例模式DCL代码"><a href="#单例模式DCL代码" class="headerlink" title="单例模式DCL代码"></a>单例模式DCL代码</h2><p>首先回顾一下，单线程下的单例模式代码</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * SingletonDemo（单例模式）</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static SingletonDemo instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private SingletonDemo () &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t 我是构造方法SingletonDemo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonDemo getInstance() &#123;</span><br><span class="line">        if(instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">            instance &#x3D; new SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里的 &#x3D;&#x3D; 是比较内存地址</span><br><span class="line">        System.out.println(SingletonDemo.getInstance() &#x3D;&#x3D; SingletonDemo.getInstance());</span><br><span class="line">        System.out.println(SingletonDemo.getInstance() &#x3D;&#x3D; SingletonDemo.getInstance());</span><br><span class="line">        System.out.println(SingletonDemo.getInstance() &#x3D;&#x3D; SingletonDemo.getInstance());</span><br><span class="line">        System.out.println(SingletonDemo.getInstance() &#x3D;&#x3D; SingletonDemo.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出的结果</p><p><img data-src="image-20200310164513408.png" alt="image1"></p><p>但是在多线程的环境下，我们的单例模式是否还是同一个对象了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * SingletonDemo（单例模式）</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static SingletonDemo instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private SingletonDemo () &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t 我是构造方法SingletonDemo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonDemo getInstance() &#123;</span><br><span class="line">        if(instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">            instance &#x3D; new SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                SingletonDemo.getInstance();</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从下面的结果我们可以看出，我们通过SingletonDemo.getInstance() 获取到的对象，并不是同一个，而是被下面几个线程都进行了创建，那么在多线程环境下，单例模式如何保证呢？</p><p><img data-src="image-20200310164720940.png" alt="image2"></p><h3 id="解决方法1"><a href="#解决方法1" class="headerlink" title="解决方法1"></a>解决方法1</h3><p>引入synchronized关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public synchronized static SingletonDemo getInstance() &#123;</span><br><span class="line">    if(instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">        instance &#x3D; new SingletonDemo();</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img data-src="image-20200310164946940.png" alt="image3"></p><p>我们能够发现，通过引入Synchronized关键字，能够解决高并发环境下的单例模式问题</p><p>但是synchronized属于重量级的同步机制，它只允许一个线程同时访问获取实例的方法，但是为了保证数据一致性，而减低了并发性，因此采用的比较少</p><h3 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2"></a>解决方法2</h3><p>通过引入DCL   Double Check Lock   双端检锁机制</p><p>就是在进来和出去的时候，进行检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static SingletonDemo getInstance() &#123;</span><br><span class="line">    if(instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 同步代码段的时候，进行检测</span><br><span class="line">        synchronized (SingletonDemo.class) &#123;</span><br><span class="line">            if(instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                instance &#x3D; new SingletonDemo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出的结果为：</p><p><img data-src="image-20200310165703190.png" alt="image4"></p><p>从输出结果来看，确实能够保证单例模式的正确性，但是上面的方法还是存在问题的</p><p>DCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入volatile可以禁止指令重排</p><p>原因是在某一个线程执行到第一次检测的时候，读取到 instance 不为null，instance的引用对象可能没有完成实例化。因为 instance = new SingletonDemo()；可以分为以下三步进行完成：</p><ul><li>memory = allocate();   // 1、分配对象内存空间</li><li>instance(memory);   // 2、初始化对象</li><li>instance = memory;  // 3、设置instance指向刚刚分配的内存地址，此时instance != null</li></ul><p>但是我们通过上面的三个步骤，能够发现，步骤2 和 步骤3之间不存在 数据依赖关系，而且无论重排前 还是重排后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。</p><ul><li>memory = allocate();   // 1、分配对象内存空间</li><li>instance = memory;  // 3、设置instance指向刚刚分配的内存地址，此时instance != null，但是对象还没有初始化完成</li><li>instance(memory);   // 2、初始化对象</li></ul><p>这样就会造成什么问题呢？</p><p>也就是当我们执行到重排后的步骤2，试图获取instance的时候，会得到null，因为对象的初始化还没有完成，而是在重排后的步骤3才完成，因此执行单例模式的代码时候，就会重新在创建一个instance实例</p><p><code>指令重排只会保证串行语义的执行一致性（单线程），但并不会关系多线程间的语义一致性</code></p><p>所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，这就造成了线程安全的问题</p><p>所以需要引入volatile，来保证出现指令重排的问题，从而保证单例模式的线程安全性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static volatile SingletonDemo instance &#x3D; null;</span><br></pre></td></tr></table></figure><h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * SingletonDemo（单例模式）</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile SingletonDemo instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private SingletonDemo () &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t 我是构造方法SingletonDemo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonDemo getInstance() &#123;</span><br><span class="line">        if(instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; a 双重检查加锁多线程情况下会出现某个线程虽然这里已经为空，但是另外一个线程已经执行到d处</span><br><span class="line">            synchronized (SingletonDemo.class) &#x2F;&#x2F;b</span><br><span class="line">            &#123; </span><br><span class="line">           &#x2F;&#x2F;c不加volitale关键字的话有可能会出现尚未完全初始化就获取到的情况。原因是内存模型允许无序写入</span><br><span class="line">                if(instance &#x3D;&#x3D; null) &#123; </span><br><span class="line">                &#x2F;&#x2F; d 此时才开始初始化</span><br><span class="line">                    instance &#x3D; new SingletonDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F; 这里的 &#x3D;&#x3D; 是比较内存地址</span><br><span class="line">&#x2F;&#x2F;        System.out.println(SingletonDemo.getInstance() &#x3D;&#x3D; SingletonDemo.getInstance());</span><br><span class="line">&#x2F;&#x2F;        System.out.println(SingletonDemo.getInstance() &#x3D;&#x3D; SingletonDemo.getInstance());</span><br><span class="line">&#x2F;&#x2F;        System.out.println(SingletonDemo.getInstance() &#x3D;&#x3D; SingletonDemo.getInstance());</span><br><span class="line">&#x2F;&#x2F;        System.out.println(SingletonDemo.getInstance() &#x3D;&#x3D; SingletonDemo.getInstance());</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                SingletonDemo.getInstance();</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> JMM </tag>
            
            <tag> Volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Volatile禁止指令重排的分析</title>
      <link href="/2019/09/30/%E5%AF%B9Volatile%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2019/09/30/%E5%AF%B9Volatile%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Volatile禁止指令重排"><a href="#Volatile禁止指令重排" class="headerlink" title="Volatile禁止指令重排"></a>Volatile禁止指令重排</h1><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令重排，一般分为以下三种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt; 最终执行指令</span><br></pre></td></tr></table></figure><p>单线程环境里面确保最终执行结果和代码顺序的结果一致</p><p>处理器在进行重排序时，必须要考虑指令之间的<code>数据依赖性</code></p><p>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p><a id="more"></a><h2 id="指令重排-example-1"><a href="#指令重排-example-1" class="headerlink" title="指令重排 - example 1"></a>指令重排 - example 1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void mySort() &#123;</span><br><span class="line">int x &#x3D; 11;</span><br><span class="line">int y &#x3D; 12;</span><br><span class="line">x &#x3D; x + 5;</span><br><span class="line">y &#x3D; x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照正常单线程环境，执行顺序是 1 2 3 4</p><p>但是在多线程环境下，可能出现以下的顺序：</p><ul><li>2 1 3 4</li><li>1 3 2 4 </li></ul><p>上述的过程就可以当做是指令的重排，即内部执行顺序，和我们的代码顺序不一样</p><p>但是指令重排也是有限制的，即不会出现下面的顺序</p><ul><li>4 3 2 1</li></ul><p>因为处理器在进行重排时候，必须考虑到指令之间的数据依赖性</p><p>因为步骤 4：需要依赖于 y的申明，以及x的申明，故因为存在数据依赖，无法首先执行</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>int a,b,x,y = 0</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>x = a;</td><td>y = b;</td></tr><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td></td><td></td></tr><tr><td>x = 0;  y = 0</td><td></td></tr></tbody></table><p>因为上面的代码，不存在数据的依赖性，因此编译器可能对数据进行重排</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>b = 1;</td><td>a = 2;</td></tr><tr><td>x = a;</td><td>y = b;</td></tr><tr><td></td><td></td></tr><tr><td>x = 2;  y = 1</td><td></td></tr></tbody></table><p>这样造成的结果，和最开始的就不一致了，这就是导致重排后，结果和最开始的不一样，因此为了防止这种结果出现，volatile就规定禁止指令重排，为了保证数据的一致性</p><h2 id="指令重排-example-2"><a href="#指令重排-example-2" class="headerlink" title="指令重排 - example 2"></a>指令重排 - example 2</h2><p>比如下面这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * ResortSeqDemo</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> * @create: </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ResortSeqDemo &#123;</span><br><span class="line">    int a&#x3D; 0;</span><br><span class="line">    boolean flag &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public void method01() &#123;</span><br><span class="line">        a &#x3D; 1;</span><br><span class="line">        flag &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void method02() &#123;</span><br><span class="line">        if(flag) &#123;</span><br><span class="line">            a &#x3D; a + 5;</span><br><span class="line">            System.out.println(&quot;reValue:&quot; + a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们按照正常的顺序，分别调用method01()  和 method02() 那么，最终输出就是 a = 6</p><p>但是如果在多线程环境下，因为方法1 和 方法2，他们之间不能存在数据依赖的问题，因此原先的顺序可能是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 1;</span><br><span class="line">flag &#x3D; true;</span><br><span class="line"></span><br><span class="line">a &#x3D; a + 5;</span><br><span class="line">System.out.println(&quot;reValue:&quot; + a);</span><br></pre></td></tr></table></figure><p>但是在经过编译器，指令，或者内存的重排后，可能会出现这样的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flag &#x3D; true;</span><br><span class="line"></span><br><span class="line">a &#x3D; a + 5;</span><br><span class="line">System.out.println(&quot;reValue:&quot; + a);</span><br><span class="line"></span><br><span class="line">a &#x3D; 1;</span><br></pre></td></tr></table></figure><p>也就是先执行 flag = true后，另外一个线程马上调用方法2，满足 flag的判断，最终让a + 5，结果为5，这样同样出现了数据不一致的问题</p><p>为什么会出现这个结果：多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。</p><p>这样就需要通过volatile来修饰，来保证线程安全性</p><h2 id="Volatile针对指令重排做了啥"><a href="#Volatile针对指令重排做了啥" class="headerlink" title="Volatile针对指令重排做了啥"></a>Volatile针对指令重排做了啥</h2><p>Volatile实现禁止指令重排优化，从而避免了多线程环境下程序出现乱序执行的现象</p><p>首先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：</p><ul><li>保证特定操作的顺序</li><li>保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）</li></ul><p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说 <code>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</code>。 内存屏障另外一个作用是刷新出各种CPU的缓存数，因此任何CPU上的线程都能读取到这些数据的最新版本。</p><p><img data-src="image1.png" alt="image1"></p><p>也就是过在Volatile的写 和 读的时候，加入屏障，防止出现指令重排的</p><h2 id="线程安全获得保证"><a href="#线程安全获得保证" class="headerlink" title="线程安全获得保证"></a>线程安全获得保证</h2><p>工作内存与主内存同步延迟现象导致的可见性问题</p><ul><li>可通过synchronized或volatile关键字解决，他们都可以使一个线程修改后的变量立即对其它线程可见</li></ul><p>对于指令重排导致的可见性问题和有序性问题</p><ul><li>可以使用volatile关键字解决，因为volatile关键字的另一个作用就是禁止重排序优化</li></ul><h2 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h2>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> JMM </tag>
            
            <tag> Volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Volatile不保证原子性进行分析</title>
      <link href="/2019/09/29/%E5%AF%B9Volatile%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90/"/>
      <url>/2019/09/29/%E5%AF%B9Volatile%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Volatile不保证原子性"><a href="#Volatile不保证原子性" class="headerlink" title="Volatile不保证原子性"></a>Volatile不保证原子性</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过前面对JMM的介绍，我们知道，各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作后在写回到主内存中的。</p><p>这就可能存在一个线程AAA修改了共享变量X的值，但是还未写入主内存时，另外一个线程BBB又对主内存中同一共享变量X进行操作，但此时A线程工作内存中共享变量X对线程B来说是不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题。</p><a id="more"></a><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>不可分割，完整性，也就是说某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要具体完成，要么同时成功，要么同时失败。</p><p>数据库也经常提到事务具备原子性</p><h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><p>为了测试volatile是否保证原子性，我们创建了20个线程，然后每个线程分别循环1000次，来调用number++的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyData myData &#x3D; new MyData();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建10个线程，线程里面进行1000次循环</span><br><span class="line">for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 里面</span><br><span class="line">        for (int j &#x3D; 0; j &lt; 1000; j++) &#123;</span><br><span class="line">            myData.addPlusPlus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过 Thread.activeCount()，来感知20个线程是否执行完毕，这里判断线程数是否大于2，为什么是2？因为默认是有两个线程的，一个main线程，一个gc线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 需要等待上面20个线程都计算完成后，在用main线程取得最终的结果值</span><br><span class="line">while(Thread.activeCount() &gt; 2) &#123;</span><br><span class="line">    &#x2F;&#x2F; yield表示不执行</span><br><span class="line">    Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在线程执行完毕后，我们在查看number的值，假设volatile保证原子性的话，那么最后输出的值应该是</p><p>20 * 1000 = 20000,</p><p>完整代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Volatile Java虚拟机提供的轻量级同步机制</span><br><span class="line"> *</span><br><span class="line"> * 可见性（及时通知）</span><br><span class="line"> * 不保证原子性</span><br><span class="line"> * 禁止指令重排</span><br><span class="line"> *</span><br><span class="line"> * @author: ylyang</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 假设是主物理内存</span><br><span class="line"> *&#x2F;</span><br><span class="line">class MyData &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * volatile 修饰的关键字，是为了增加 主线程和线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知</span><br><span class="line">     *&#x2F;</span><br><span class="line">    volatile int number &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public void addTo60() &#123;</span><br><span class="line">        this.number &#x3D; 60;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 注意，此时number 前面是加了volatile修饰</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void addPlusPlus() &#123;</span><br><span class="line">        number ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 验证volatile的可见性</span><br><span class="line"> * 1、 假设int number &#x3D; 0， number变量之前没有添加volatile关键字修饰</span><br><span class="line"> * 2、添加了volatile，可以解决可见性问题</span><br><span class="line"> *</span><br><span class="line"> * 验证volatile不保证原子性</span><br><span class="line"> * 1、原子性指的是什么意思？</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class VolatileDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args []) &#123;</span><br><span class="line"></span><br><span class="line">        MyData myData &#x3D; new MyData();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建10个线程，线程里面进行1000次循环</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                &#x2F;&#x2F; 里面</span><br><span class="line">                for (int j &#x3D; 0; j &lt; 1000; j++) &#123;</span><br><span class="line">                    myData.addPlusPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 需要等待上面20个线程都计算完成后，在用main线程取得最终的结果值</span><br><span class="line">        &#x2F;&#x2F; 这里判断线程数是否大于2，为什么是2？因为默认是有两个线程的，一个main线程，一个gc线程</span><br><span class="line">        while(Thread.activeCount() &gt; 2) &#123;</span><br><span class="line">            &#x2F;&#x2F; yield表示不执行</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 查看最终的值</span><br><span class="line">        &#x2F;&#x2F; 假设volatile保证原子性，那么输出的值应该为：  20 * 1000 &#x3D; 20000</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t finally number value: &quot; + myData.number);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终结果我们会发现，number输出的值并没有20000，而且是每次运行的结果都不一致的，这说明了volatile修饰的变量不保证原子性</p><p>第一次：</p><p><img data-src="image-20200309172900462.png" alt="image1"></p><p>第二次：</p><p><img data-src="image-20200309172919295.png" alt="image2"></p><p>第三次：</p><p><img data-src="image-20200309172929820.png" alt="image3"></p><h2 id="为什么出现数值丢失"><a href="#为什么出现数值丢失" class="headerlink" title="为什么出现数值丢失"></a>为什么出现数值丢失</h2><p><img data-src="image-20200309174220675.png" alt="image4"></p><p>各自线程在写入主内存的时候，出现了数据的丢失，而引起的数值缺失的问题</p><p>下面我们将一个简单的number++操作，转换为字节码文件一探究竟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class T1 &#123;</span><br><span class="line">    volatile int n &#x3D; 0;</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的字节码文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class com.moxi.interview.study.thread.T1 &#123;</span><br><span class="line">  volatile int n;</span><br><span class="line"></span><br><span class="line">  public com.moxi.interview.study.thread.T1();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: aload_0</span><br><span class="line">       5: iconst_0</span><br><span class="line">       6: putfield      #2                  &#x2F;&#x2F; Field n:I</span><br><span class="line">       9: return</span><br><span class="line"></span><br><span class="line">  public void add();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: dup</span><br><span class="line">       2: getfield      #2                  &#x2F;&#x2F; Field n:I</span><br><span class="line">       5: iconst_1</span><br><span class="line">       6: iadd</span><br><span class="line">       7: putfield      #2                  &#x2F;&#x2F; Field n:I</span><br><span class="line">      10: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里查看字节码的操作，是用到了IDEA的javap命令</p><p>我们首先，使用IDEA提供的External Tools，来扩展javap命令</p><p><img data-src="image-20200309183026329.png" alt="image5"></p><p>完成上述操作后，我们在需要查看字节码的文件下，右键选择 External Tools即可</p><p><img data-src="image-20200309183115613.png" alt="image8"></p><p>如果出现了找不到指定类，那是因为我们创建的是spring boot的maven项目，我们之前需要执行mvn package命令，进行打包操作，将其编译成class文件</p><p>移动到底部，有一份字节码指令对照表，方便我们进行阅读</p><p>下面我们就针对 add() 这个方法的字节码文件进行分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void add();</span><br><span class="line">  Code:</span><br><span class="line">     0: aload_0</span><br><span class="line">     1: dup</span><br><span class="line">     2: getfield      #2    &#x2F;&#x2F; Field n:I</span><br><span class="line">     5: iconst_1</span><br><span class="line">     6: iadd</span><br><span class="line">     7: putfield      #2    &#x2F;&#x2F; Field n:I</span><br><span class="line">    10: return</span><br></pre></td></tr></table></figure><p>我们能够发现 n++这条命令，被拆分成了3个指令</p><ul><li>执行<code>getfield</code> 从主内存拿到原始n</li><li>执行<code>iadd</code> 进行加1操作</li><li>执行<code>putfileld</code> 把累加后的值写回主内存 </li></ul><p>假设我们没有加 <code>synchronized</code>那么第一步就可能存在着，三个线程同时通过getfield命令，拿到主存中的 n值，然后三个线程，各自在自己的工作内存中进行加1操作，但他们并发进行  <code>iadd</code> 命令的时候，因为只能一个进行写，所以其它操作会被挂起，假设1线程，先进行了写操作，在写完后，volatile的可见性，应该需要告诉其它两个线程，主内存的值已经被修改了，但是因为太快了，其它两个线程，陆续执行 <code>iadd</code>命令，进行写入操作，这就造成了其他线程没有接受到主内存n的改变，从而覆盖了原来的值，出现写丢失，这样也就让最终的结果少于20000</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>因此这也说明，在多线程环境下 number ++ 在多线程环境下是非线程安全的，解决的方法有哪些呢？</p><ul><li>在方法上加入 synchronized</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void addPlusPlus() &#123;</span><br><span class="line">    number ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img data-src="image-20200309173315294.png" alt="image6"></p><p>我们能够发现引入synchronized关键字后，保证了该方法每次只能够一个线程进行访问和操作，最终输出的结果也就为20000</p><h2 id="其它解决方法"><a href="#其它解决方法" class="headerlink" title="其它解决方法"></a>其它解决方法</h2><p>上面的方法引入synchronized，虽然能够保证原子性，但是为了解决number++，而引入重量级的同步机制，有种 杀鸡焉用牛刀</p><p>除了引用synchronized关键字外，还可以使用JUC下面的原子包装类，即刚刚的int类型的number，可以使用AtomicInteger来代替</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  创建一个原子Integer包装类，默认为0</span><br><span class="line">  *&#x2F;</span><br><span class="line">AtomicInteger atomicInteger &#x3D; new AtomicInteger();</span><br><span class="line"></span><br><span class="line">public void addAtomic() &#123;</span><br><span class="line">    &#x2F;&#x2F; 相当于 atomicInter ++</span><br><span class="line">    atomicInteger.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后同理，继续刚刚的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建10个线程，线程里面进行1000次循环</span><br><span class="line">for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 里面</span><br><span class="line">        for (int j &#x3D; 0; j &lt; 1000; j++) &#123;</span><br><span class="line">            myData.addPlusPlus();</span><br><span class="line">            myData.addAtomic();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设volatile保证原子性，那么输出的值应该为：  20 * 1000 &#x3D; 20000</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;\t finally number value: &quot; + myData.number);</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;\t finally atomicNumber value: &quot; + myData.atomicInteger);</span><br></pre></td></tr></table></figure><p>下面的结果，一个是引入synchronized，一个是使用了原子包装类AtomicInteger</p><p><img data-src="image-20200309205242622.png" alt="image7"></p><h2 id="字节码指令表"><a href="#字节码指令表" class="headerlink" title="字节码指令表"></a>字节码指令表</h2><p>为了方便阅读JVM字节码文件，我从网上找了一份字节码指令表</p><p>引用：<a href="https://segmentfault.com/a/1190000008722128" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008722128</a></p><table><thead><tr><th>字节码</th><th>助记符</th><th>指令含义</th></tr></thead><tbody><tr><td>0x00</td><td>nop</td><td>None</td></tr><tr><td>0x01</td><td>aconst_null</td><td>将null推送至栈顶</td></tr><tr><td>0x02</td><td>iconst_m1</td><td>将int型-1推送至栈顶</td></tr><tr><td>0x03</td><td>iconst_0</td><td>将int型0推送至栈顶</td></tr><tr><td>0x04</td><td>iconst_1</td><td>将int型1推送至栈顶</td></tr><tr><td>0x05</td><td>iconst_2</td><td>将int型2推送至栈顶</td></tr><tr><td>0x06</td><td>iconst_3</td><td>将int型3推送至栈顶</td></tr><tr><td>0x07</td><td>iconst_4</td><td>将int型4推送至栈顶</td></tr><tr><td>0x08</td><td>iconst_5</td><td>将int型5推送至栈顶</td></tr><tr><td>0x09</td><td>lconst_0</td><td>将long型0推送至栈顶</td></tr><tr><td>0x0a</td><td>lconst_1</td><td>将long型1推送至栈顶</td></tr><tr><td>0x0b</td><td>fconst_0</td><td>将float型0推送至栈顶</td></tr><tr><td>0x0c</td><td>fconst_1</td><td>将float型1推送至栈顶</td></tr><tr><td>0x0d</td><td>fconst_2</td><td>将float型2推送至栈顶</td></tr><tr><td>0x0e</td><td>dconst_0</td><td>将double型0推送至栈顶</td></tr><tr><td>0x0f</td><td>dconst_1</td><td>将double型1推送至栈顶</td></tr><tr><td>0x10</td><td>bipush</td><td>将单字节的常量值(-128~127)推送至栈顶</td></tr><tr><td>0x11</td><td>sipush</td><td>将一个短整型常量(-32768~32767)推送至栈顶</td></tr><tr><td>0x12</td><td>ldc</td><td>将int,float或String型常量值从常量池中推送至栈顶</td></tr><tr><td>0x13</td><td>ldc_w</td><td>将int,float或String型常量值从常量池中推送至栈顶(宽索引)</td></tr><tr><td>0x14</td><td>ldc2_w</td><td>将long或double型常量值从常量池中推送至栈顶(宽索引)</td></tr><tr><td>0x15</td><td>iload</td><td>将指定的int型本地变量推送至栈顶</td></tr><tr><td>0x16</td><td>lload</td><td>将指定的long型本地变量推送至栈顶</td></tr><tr><td>0x17</td><td>fload</td><td>将指定的float型本地变量推送至栈顶</td></tr><tr><td>0x18</td><td>dload</td><td>将指定的double型本地变量推送至栈顶</td></tr><tr><td>0x19</td><td>aload</td><td>将指定的引用类型本地变量推送至栈顶</td></tr><tr><td>0x1a</td><td>iload_0</td><td>将第一个int型本地变量推送至栈顶</td></tr><tr><td>0x1b</td><td>iload_1</td><td>将第二个int型本地变量推送至栈顶</td></tr><tr><td>0x1c</td><td>iload_2</td><td>将第三个int型本地变量推送至栈顶</td></tr><tr><td>0x1d</td><td>iload_3</td><td>将第四个int型本地变量推送至栈顶</td></tr><tr><td>0x1e</td><td>lload_0</td><td>将第一个long型本地变量推送至栈顶</td></tr><tr><td>0x1f</td><td>lload_1</td><td>将第二个long型本地变量推送至栈顶</td></tr><tr><td>0x20</td><td>lload_2</td><td>将第三个long型本地变量推送至栈顶</td></tr><tr><td>0x21</td><td>lload_3</td><td>将第四个long型本地变量推送至栈顶</td></tr><tr><td>0x22</td><td>fload_0</td><td>将第一个float型本地变量推送至栈顶</td></tr><tr><td>0x23</td><td>fload_1</td><td>将第二个float型本地变量推送至栈顶</td></tr><tr><td>0x24</td><td>fload_2</td><td>将第三个float型本地变量推送至栈顶</td></tr><tr><td>0x25</td><td>fload_3</td><td>将第四个float型本地变量推送至栈顶</td></tr><tr><td>0x26</td><td>dload_0</td><td>将第一个double型本地变量推送至栈顶</td></tr><tr><td>0x27</td><td>dload_1</td><td>将第二个double型本地变量推送至栈顶</td></tr><tr><td>0x28</td><td>dload_2</td><td>将第三个double型本地变量推送至栈顶</td></tr><tr><td>0x29</td><td>dload_3</td><td>将第四个double型本地变量推送至栈顶</td></tr><tr><td>0x2a</td><td>aload_0</td><td>将第一个引用类型本地变量推送至栈顶</td></tr><tr><td>0x2b</td><td>aload_1</td><td>将第二个引用类型本地变量推送至栈顶</td></tr><tr><td>0x2c</td><td>aload_2</td><td>将第三个引用类型本地变量推送至栈顶</td></tr><tr><td>0x2d</td><td>aload_3</td><td>将第四个引用类型本地变量推送至栈顶</td></tr><tr><td>0x2e</td><td>iaload</td><td>将int型数组指定索引的值推送至栈顶</td></tr><tr><td>0x2f</td><td>laload</td><td>将long型数组指定索引的值推送至栈顶</td></tr><tr><td>0x30</td><td>faload</td><td>将float型数组指定索引的值推送至栈顶</td></tr><tr><td>0x31</td><td>daload</td><td>将double型数组指定索引的值推送至栈顶</td></tr><tr><td>0x32</td><td>aaload</td><td>将引用类型数组指定索引的值推送至栈顶</td></tr><tr><td>0x33</td><td>baload</td><td>将boolean或byte型数组指定索引的值推送至栈顶</td></tr><tr><td>0x34</td><td>caload</td><td>将char型数组指定索引的值推送至栈顶</td></tr><tr><td>0x35</td><td>saload</td><td>将short型数组指定索引的值推送至栈顶</td></tr><tr><td>0x36</td><td>istore</td><td>将栈顶int型数值存入指定本地变量</td></tr><tr><td>0x37</td><td>lstore</td><td>将栈顶long型数值存入指定本地变量</td></tr><tr><td>0x38</td><td>fstore</td><td>将栈顶float型数值存入指定本地变量</td></tr><tr><td>0x39</td><td>dstore</td><td>将栈顶double型数值存入指定本地变量</td></tr><tr><td>0x3a</td><td>astore</td><td>将栈顶引用类型数值存入指定本地变量</td></tr><tr><td>0x3b</td><td>istore_0</td><td>将栈顶int型数值存入第一个本地变量</td></tr><tr><td>0x3c</td><td>istore_1</td><td>将栈顶int型数值存入第二个本地变量</td></tr><tr><td>0x3d</td><td>istore_2</td><td>将栈顶int型数值存入第三个本地变量</td></tr><tr><td>0x3e</td><td>istore_3</td><td>将栈顶int型数值存入第四个本地变量</td></tr><tr><td>0x3f</td><td>lstore_0</td><td>将栈顶long型数值存入第一个本地变量</td></tr><tr><td>0x40</td><td>lstore_1</td><td>将栈顶long型数值存入第二个本地变量</td></tr><tr><td>0x41</td><td>lstore_2</td><td>将栈顶long型数值存入第三个本地变量</td></tr><tr><td>0x42</td><td>lstore_3</td><td>将栈顶long型数值存入第四个本地变量</td></tr><tr><td>0x43</td><td>fstore_0</td><td>将栈顶float型数值存入第一个本地变量</td></tr><tr><td>0x44</td><td>fstore_1</td><td>将栈顶float型数值存入第二个本地变量</td></tr><tr><td>0x45</td><td>fstore_2</td><td>将栈顶float型数值存入第三个本地变量</td></tr><tr><td>0x46</td><td>fstore_3</td><td>将栈顶float型数值存入第四个本地变量</td></tr><tr><td>0x47</td><td>dstore_0</td><td>将栈顶double型数值存入第一个本地变量</td></tr><tr><td>0x48</td><td>dstore_1</td><td>将栈顶double型数值存入第二个本地变量</td></tr><tr><td>0x49</td><td>dstore_2</td><td>将栈顶double型数值存入第三个本地变量</td></tr><tr><td>0x4a</td><td>dstore_3</td><td>将栈顶double型数值存入第四个本地变量</td></tr><tr><td>0x4b</td><td>astore_0</td><td>将栈顶引用型数值存入第一个本地变量</td></tr><tr><td>0x4c</td><td>astore_1</td><td>将栈顶引用型数值存入第二个本地变量</td></tr><tr><td>0x4d</td><td>astore_2</td><td>将栈顶引用型数值存入第三个本地变量</td></tr><tr><td>0x4e</td><td>astore_3</td><td>将栈顶引用型数值存入第四个本地变量</td></tr><tr><td>0x4f</td><td>iastore</td><td>将栈顶int型数值存入指定数组的指定索引位置</td></tr><tr><td>0x50</td><td>lastore</td><td>将栈顶long型数值存入指定数组的指定索引位置</td></tr><tr><td>0x51</td><td>fastore</td><td>将栈顶float型数值存入指定数组的指定索引位置</td></tr><tr><td>0x52</td><td>dastore</td><td>将栈顶double型数值存入指定数组的指定索引位置</td></tr><tr><td>0x53</td><td>aastore</td><td>将栈顶引用型数值存入指定数组的指定索引位置</td></tr><tr><td>0x54</td><td>bastore</td><td>将栈顶boolean或byte型数值存入指定数组的指定索引位置</td></tr><tr><td>0x55</td><td>castore</td><td>将栈顶char型数值存入指定数组的指定索引位置</td></tr><tr><td>0x56</td><td>sastore</td><td>将栈顶short型数值存入指定数组的指定索引位置</td></tr><tr><td>0x57</td><td>pop</td><td>将栈顶数值弹出(数值不能是long或double类型的)</td></tr><tr><td>0x58</td><td>pop2</td><td>将栈顶的一个(对于非long或double类型)或两个数值(对于非long或double的其他类型)弹出</td></tr><tr><td>0x59</td><td>dup</td><td>复制栈顶数值并将复制值压入栈顶</td></tr><tr><td>0x5a</td><td>dup_x1</td><td>复制栈顶数值并将两个复制值压入栈顶</td></tr><tr><td>0x5b</td><td>dup_x2</td><td>复制栈顶数值并将三个(或两个)复制值压入栈顶</td></tr><tr><td>0x5c</td><td>dup2</td><td>复制栈顶一个(对于long或double类型)或两个(对于非long或double的其他类型)数值并将复制值压入栈顶</td></tr><tr><td>0x5d</td><td>dup2_x1</td><td>dup_x1指令的双倍版本</td></tr><tr><td>0x5e</td><td>dup2_x2</td><td>dup_x2指令的双倍版本</td></tr><tr><td>0x5f</td><td>swap</td><td>将栈顶最顶端的两个数值互换(数值不能是long或double类型)</td></tr><tr><td>0x60</td><td>iadd</td><td>将栈顶两int型数值相加并将结果压入栈顶</td></tr><tr><td>0x61</td><td>ladd</td><td>将栈顶两long型数值相加并将结果压入栈顶</td></tr><tr><td>0x62</td><td>fadd</td><td>将栈顶两float型数值相加并将结果压入栈顶</td></tr><tr><td>0x63</td><td>dadd</td><td>将栈顶两double型数值相加并将结果压入栈顶</td></tr><tr><td>0x64</td><td>isub</td><td>将栈顶两int型数值相减并将结果压入栈顶</td></tr><tr><td>0x65</td><td>lsub</td><td>将栈顶两long型数值相减并将结果压入栈顶</td></tr><tr><td>0x66</td><td>fsub</td><td>将栈顶两float型数值相减并将结果压入栈顶</td></tr><tr><td>0x67</td><td>dsub</td><td>将栈顶两double型数值相减并将结果压入栈顶</td></tr><tr><td>0x68</td><td>imul</td><td>将栈顶两int型数值相乘并将结果压入栈顶</td></tr><tr><td>0x69</td><td>lmul</td><td>将栈顶两long型数值相乘并将结果压入栈顶</td></tr><tr><td>0x6a</td><td>fmul</td><td>将栈顶两float型数值相乘并将结果压入栈顶</td></tr><tr><td>0x6b</td><td>dmul</td><td>将栈顶两double型数值相乘并将结果压入栈顶</td></tr><tr><td>0x6c</td><td>idiv</td><td>将栈顶两int型数值相除并将结果压入栈顶</td></tr><tr><td>0x6d</td><td>ldiv</td><td>将栈顶两long型数值相除并将结果压入栈顶</td></tr><tr><td>0x6e</td><td>fdiv</td><td>将栈顶两float型数值相除并将结果压入栈顶</td></tr><tr><td>0x6f</td><td>ddiv</td><td>将栈顶两double型数值相除并将结果压入栈顶</td></tr><tr><td>0x70</td><td>irem</td><td>将栈顶两int型数值作取模运算并将结果压入栈顶</td></tr><tr><td>0x71</td><td>lrem</td><td>将栈顶两long型数值作取模运算并将结果压入栈顶</td></tr><tr><td>0x72</td><td>frem</td><td>将栈顶两float型数值作取模运算并将结果压入栈顶</td></tr><tr><td>0x73</td><td>drem</td><td>将栈顶两double型数值作取模运算并将结果压入栈顶</td></tr><tr><td>0x74</td><td>ineg</td><td>将栈顶int型数值取负并将结果压入栈顶</td></tr><tr><td>0x75</td><td>lneg</td><td>将栈顶long型数值取负并将结果压入栈顶</td></tr><tr><td>0x76</td><td>fneg</td><td>将栈顶float型数值取负并将结果压入栈顶</td></tr><tr><td>0x77</td><td>dneg</td><td>将栈顶double型数值取负并将结果压入栈顶</td></tr><tr><td>0x78</td><td>ishl</td><td>将int型数值左移指定位数并将结果压入栈顶</td></tr><tr><td>0x79</td><td>lshl</td><td>将long型数值左移指定位数并将结果压入栈顶</td></tr><tr><td>0x7a</td><td>ishr</td><td>将int型数值右(带符号)移指定位数并将结果压入栈顶</td></tr><tr><td>0x7b</td><td>lshr</td><td>将long型数值右(带符号)移指定位数并将结果压入栈顶</td></tr><tr><td>0x7c</td><td>iushr</td><td>将int型数值右(无符号)移指定位数并将结果压入栈顶</td></tr><tr><td>0x7d</td><td>lushr</td><td>将long型数值右(无符号)移指定位数并将结果压入栈顶</td></tr><tr><td>0x7e</td><td>iand</td><td>将栈顶两int型数值”按位与”并将结果压入栈顶</td></tr><tr><td>0x7f</td><td>land</td><td>将栈顶两long型数值”按位与”并将结果压入栈顶</td></tr><tr><td>0x80</td><td>ior</td><td>将栈顶两int型数值”按位或”并将结果压入栈顶</td></tr><tr><td>0x81</td><td>lor</td><td>将栈顶两long型数值”按位或”并将结果压入栈顶</td></tr><tr><td>0x82</td><td>ixor</td><td>将栈顶两int型数值”按位异或”并将结果压入栈顶</td></tr><tr><td>0x83</td><td>lxor</td><td>将栈顶两long型数值”按位异或”并将结果压入栈顶</td></tr><tr><td>0x84</td><td>iinc</td><td>将指定int型变量增加指定值(如i++, i–, i+=2等)</td></tr><tr><td>0x85</td><td>i2l</td><td>将栈顶int型数值强制转换为long型数值并将结果压入栈顶</td></tr><tr><td>0x86</td><td>i2f</td><td>将栈顶int型数值强制转换为float型数值并将结果压入栈顶</td></tr><tr><td>0x87</td><td>i2d</td><td>将栈顶int型数值强制转换为double型数值并将结果压入栈顶</td></tr><tr><td>0x88</td><td>l2i</td><td>将栈顶long型数值强制转换为int型数值并将结果压入栈顶</td></tr><tr><td>0x89</td><td>l2f</td><td>将栈顶long型数值强制转换为float型数值并将结果压入栈顶</td></tr><tr><td>0x8a</td><td>l2d</td><td>将栈顶long型数值强制转换为double型数值并将结果压入栈顶</td></tr><tr><td>0x8b</td><td>f2i</td><td>将栈顶float型数值强制转换为int型数值并将结果压入栈顶</td></tr><tr><td>0x8c</td><td>f2l</td><td>将栈顶float型数值强制转换为long型数值并将结果压入栈顶</td></tr><tr><td>0x8d</td><td>f2d</td><td>将栈顶float型数值强制转换为double型数值并将结果压入栈顶</td></tr><tr><td>0x8e</td><td>d2i</td><td>将栈顶double型数值强制转换为int型数值并将结果压入栈顶</td></tr><tr><td>0x8f</td><td>d2l</td><td>将栈顶double型数值强制转换为long型数值并将结果压入栈顶</td></tr><tr><td>0x90</td><td>d2f</td><td>将栈顶double型数值强制转换为float型数值并将结果压入栈顶</td></tr><tr><td>0x91</td><td>i2b</td><td>将栈顶int型数值强制转换为byte型数值并将结果压入栈顶</td></tr><tr><td>0x92</td><td>i2c</td><td>将栈顶int型数值强制转换为char型数值并将结果压入栈顶</td></tr><tr><td>0x93</td><td>i2s</td><td>将栈顶int型数值强制转换为short型数值并将结果压入栈顶</td></tr><tr><td>0x94</td><td>lcmp</td><td>比较栈顶两long型数值大小, 并将结果(1, 0或-1)压入栈顶</td></tr><tr><td>0x95</td><td>fcmpl</td><td>比较栈顶两float型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为<code>NaN</code>时, 将-1压入栈顶</td></tr><tr><td>0x96</td><td>fcmpg</td><td>比较栈顶两float型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为<code>NaN</code>时, 将1压入栈顶</td></tr><tr><td>0x97</td><td>dcmpl</td><td>比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为<code>NaN</code>时, 将-1压入栈顶</td></tr><tr><td>0x98</td><td>dcmpg</td><td>比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为<code>NaN</code>时, 将1压入栈顶</td></tr><tr><td>0x99</td><td>ifeq</td><td>当栈顶int型数值等于0时跳转</td></tr><tr><td>0x9a</td><td>ifne</td><td>当栈顶int型数值不等于0时跳转</td></tr><tr><td>0x9b</td><td>iflt</td><td>当栈顶int型数值小于0时跳转</td></tr><tr><td>0x9c</td><td>ifge</td><td>当栈顶int型数值大于等于0时跳转</td></tr><tr><td>0x9d</td><td>ifgt</td><td>当栈顶int型数值大于0时跳转</td></tr><tr><td>0x9e</td><td>ifle</td><td>当栈顶int型数值小于等于0时跳转</td></tr><tr><td>0x9f</td><td>if_icmpeq</td><td>比较栈顶两int型数值大小, 当结果等于0时跳转</td></tr><tr><td>0xa0</td><td>if_icmpne</td><td>比较栈顶两int型数值大小, 当结果不等于0时跳转</td></tr><tr><td>0xa1</td><td>if_icmplt</td><td>比较栈顶两int型数值大小, 当结果小于0时跳转</td></tr><tr><td>0xa2</td><td>if_icmpge</td><td>比较栈顶两int型数值大小, 当结果大于等于0时跳转</td></tr><tr><td>0xa3</td><td>if_icmpgt</td><td>比较栈顶两int型数值大小, 当结果大于0时跳转</td></tr><tr><td>0xa4</td><td>if_icmple</td><td>比较栈顶两int型数值大小, 当结果小于等于0时跳转</td></tr><tr><td>0xa5</td><td>if_acmpeq</td><td>比较栈顶两引用型数值, 当结果相等时跳转</td></tr><tr><td>0xa6</td><td>if_acmpne</td><td>比较栈顶两引用型数值, 当结果不相等时跳转</td></tr><tr><td>0xa7</td><td>goto</td><td>无条件跳转</td></tr><tr><td>0xa8</td><td>jsr</td><td>跳转至指定的16位offset位置, 并将jsr的下一条指令地址压入栈顶</td></tr><tr><td>0xa9</td><td>ret</td><td>返回至本地变量指定的index的指令位置(一般与jsr或jsr_w联合使用)</td></tr><tr><td>0xaa</td><td>tableswitch</td><td>用于switch条件跳转, case值连续(可变长度指令)</td></tr><tr><td>0xab</td><td>lookupswitch</td><td>用于switch条件跳转, case值不连续(可变长度指令)</td></tr><tr><td>0xac</td><td>ireturn</td><td>从当前方法返回int</td></tr><tr><td>0xad</td><td>lreturn</td><td>从当前方法返回long</td></tr><tr><td>0xae</td><td>freturn</td><td>从当前方法返回float</td></tr><tr><td>0xaf</td><td>dreturn</td><td>从当前方法返回double</td></tr><tr><td>0xb0</td><td>areturn</td><td>从当前方法返回对象引用</td></tr><tr><td>0xb1</td><td>return</td><td>从当前方法返回void</td></tr><tr><td>0xb2</td><td>getstatic</td><td>获取指定类的静态域, 并将其压入栈顶</td></tr><tr><td>0xb3</td><td>putstatic</td><td>为指定类的静态域赋值</td></tr><tr><td>0xb4</td><td>getfield</td><td>获取指定类的实例域, 并将其压入栈顶</td></tr><tr><td>0xb5</td><td>putfield</td><td>为指定类的实例域赋值</td></tr><tr><td>0xb6</td><td>invokevirtual</td><td>调用实例方法</td></tr><tr><td>0xb7</td><td>invokespecial</td><td>调用超类构建方法, 实例初始化方法, 私有方法</td></tr><tr><td>0xb8</td><td>invokestatic</td><td>调用静态方法</td></tr><tr><td>0xb9</td><td>invokeinterface</td><td>调用接口方法</td></tr><tr><td>0xba</td><td>invokedynamic</td><td>调用动态方法</td></tr><tr><td>0xbb</td><td>new</td><td>创建一个对象, 并将其引用引用值压入栈顶</td></tr><tr><td>0xbc</td><td>newarray</td><td>创建一个指定的原始类型(如int, float, char等)的数组, 并将其引用值压入栈顶</td></tr><tr><td>0xbd</td><td>anewarray</td><td>创建一个引用型(如类, 接口, 数组)的数组, 并将其引用值压入栈顶</td></tr><tr><td>0xbe</td><td>arraylength</td><td>获取数组的长度值并压入栈顶</td></tr><tr><td>0xbf</td><td>athrow</td><td>将栈顶的异常抛出</td></tr><tr><td>0xc0</td><td>checkcast</td><td>检验类型转换, 检验未通过将抛出 ClassCastException</td></tr><tr><td>0xc1</td><td>instanceof</td><td>检验对象是否是指定类的实际, 如果是将1压入栈顶, 否则将0压入栈顶</td></tr><tr><td>0xc2</td><td>monitorenter</td><td>获得对象的锁, 用于同步方法或同步块</td></tr><tr><td>0xc3</td><td>monitorexit</td><td>释放对象的锁, 用于同步方法或同步块</td></tr><tr><td>0xc4</td><td>wide</td><td>扩展本地变量的宽度</td></tr><tr><td>0xc5</td><td>multianewarray</td><td>创建指定类型和指定维度的多维数组(执行该指令时, 操作栈中必须包含各维度的长度值), 并将其引用压入栈顶</td></tr><tr><td>0xc6</td><td>ifnull</td><td>为null时跳转</td></tr><tr><td>0xc7</td><td>ifnonnull</td><td>不为null时跳转</td></tr><tr><td>0xc8</td><td>goto_w</td><td>无条件跳转(宽索引)</td></tr><tr><td>0xc9</td><td>jsr_w</td><td>跳转至指定的32位offset位置, 并将jsr_w的下一条指令地址压入栈顶</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> JMM </tag>
            
            <tag> Volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volatile和JMM内存模型的可见性</title>
      <link href="/2019/09/28/Volatile%E5%92%8CJMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
      <url>/2019/09/28/Volatile%E5%92%8CJMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<ul><li>JUC（java.util.concurrent）<ul><li>进程和线程<ul><li>进程：后台运行的程序（我们打开的一个软件，就是进程）</li><li>线程：轻量级的进程，并且一个进程包含多个线程（同在一个软件内，同时运行窗口，就是线程）</li></ul></li><li>并发和并行<ul><li>并发：同时访问某个东西，就是并发</li><li>并行：一起做某些事情，就是并行</li></ul></li></ul></li><li>JUC下的三个包<ul><li>java.util.concurrent<ul><li>java.util.concurrent.atomic</li><li>java.util.concurrent.locks</li></ul></li></ul></li></ul><a id="more"></a><h2 id="谈谈对Volatile的理解"><a href="#谈谈对Volatile的理解" class="headerlink" title="谈谈对Volatile的理解"></a>谈谈对Volatile的理解</h2><p>Volatile在日常的单线程环境是应用不到的</p><ul><li>Volatile是Java虚拟机提供的<code>轻量级</code>的同步机制（三大特性）<ul><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ul></li></ul><h2 id="JMM是什么"><a href="#JMM是什么" class="headerlink" title="JMM是什么"></a>JMM是什么</h2><p>JMM是Java内存模型，也就是Java Memory Model，简称JMM，本身是一种抽象的概念，实际上并不存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式</p><p>JMM关于同步的规定：</p><ul><li>线程解锁前，必须把共享变量的值刷新回主内存</li><li>线程解锁前，必须读取主内存的最新值，到自己的工作内存</li><li>加锁和解锁是同一把锁</li></ul><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，<code>但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存</code>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程：</p><p><img data-src="image-20200309153225758.png" alt="image0"></p><p>数据传输速率：硬盘 &lt; 内存 &lt; &lt; cache &lt; CPU   </p><p>上面提到了两个概念：主内存  和 工作内存</p><ul><li><p>主内存：就是计算机的内存，也就是经常提到的8G内存，16G内存</p></li><li><p>工作内存：但我们实例化 new student，那么 age = 25 也是存储在主内存中</p><ul><li>当同时有三个线程同时访问 student中的age变量时，那么每个线程都会拷贝一份，到各自的工作内存，从而实现了变量的拷贝</li></ul><p><img data-src="image-20200309154435933.png" alt="image1"></p></li></ul><p>即：JMM内存模型的可见性，指的是当主内存区域中的值被某个线程写入更改后，其它线程会马上知晓更改后的值，并重新得到更改后的值。</p><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>为什么这里主线程中某个值被更改后，其它线程能马上知晓呢？其实这里是用到了总线嗅探技术</p><p>在说嗅探技术之前，首先谈谈缓存一致性的问题，就是当多个处理器运算任务都涉及到同一块主内存区域的时候，将可能导致各自的缓存数据不一。</p><p>为了解决缓存一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，这类协议主要有MSI、MESI等等。</p><h3 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h3><p>当CPU写数据时，如果发现操作的变量是共享变量，即在其它CPU中也存在该变量的副本，会发出信号通知其它CPU将该内存变量的缓存行设置为无效，因此当其它CPU读取这个变量的时，发现自己缓存该变量的缓存行是无效的，那么它就会从内存中重新读取。</p><h3 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h3><p>那么是如何发现数据是否失效呢？</p><p>这里是用到了总线嗅探技术，就是每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期了，当处理器发现自己的缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从内存中把数据读取到处理器缓存中。</p><h3 id="总线风暴"><a href="#总线风暴" class="headerlink" title="总线风暴"></a>总线风暴</h3><p>总线嗅探技术有哪些缺点？</p><p>由于Volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和CAS循环，无效的交互会导致总线带宽达到峰值。因此不要大量使用volatile关键字，至于什么时候使用volatile、什么时候用锁以及Syschonized都是需要根据实际场景的。</p><h2 id="JMM的特性"><a href="#JMM的特性" class="headerlink" title="JMM的特性"></a>JMM的特性</h2><p>JMM的三大特性，volatile只保证了两个，即可见性和有序性，不满足原子性</p><ul><li>可见性</li><li>原子性</li><li>有序性</li></ul><h2 id="可见性代码验证"><a href="#可见性代码验证" class="headerlink" title="可见性代码验证"></a>可见性代码验证</h2><p>但我们对于成员变量没有添加任何修饰时，是无法感知其它线程修改后的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package com.moxi.interview.study.thread;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Volatile Java虚拟机提供的轻量级同步机制</span><br><span class="line"> *</span><br><span class="line"> * 可见性（及时通知）</span><br><span class="line"> * 不保证原子性</span><br><span class="line"> * 禁止指令重排</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 假设是主物理内存</span><br><span class="line"> *&#x2F;</span><br><span class="line">class MyData &#123;</span><br><span class="line"></span><br><span class="line">    int number &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public void addTo60() &#123;</span><br><span class="line">        this.number &#x3D; 60;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 验证volatile的可见性</span><br><span class="line"> * 1. 假设int number &#x3D; 0， number变量之前没有添加volatile关键字修饰</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class VolatileDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args []) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 资源类</span><br><span class="line">        MyData myData &#x3D; new MyData();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; AAA线程 实现了Runnable接口的，lambda表达式</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t come in&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 线程睡眠3秒，假设在进行运算</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 修改number的值</span><br><span class="line">            myData.addTo60();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 输出修改后的值</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;\t update number value:&quot; + myData.number);</span><br><span class="line"></span><br><span class="line">        &#125;, &quot;AAA&quot;).start();</span><br><span class="line"></span><br><span class="line">        while(myData.number &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; main线程就一直在这里等待循环，直到number的值不等于零</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 按道理这个值是不可能打印出来的，因为主线程运行的时候，number的值为0，所以一直在循环</span><br><span class="line">        &#x2F;&#x2F; 如果能输出这句话，说明AAA线程在睡眠3秒后，更新的number的值，重新写入到主内存，并被main线程感知到了</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;\t mission is over&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 最后输出结果：</span><br><span class="line">         * AAA come in</span><br><span class="line">         * AAA update number value:60</span><br><span class="line">         * 最后线程没有停止，并行没有输出  mission is over 这句话，说明没有用volatile修饰的变量，是没有可见性</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><p><img data-src="image-20200309162154191.png" alt="image2">    </p><p>最后线程没有停止，并行没有输出  mission is over 这句话，说明没有用volatile修饰的变量，是没有可见性</p><p>当我们修改MyData类中的成员变量时，并且添加volatile关键字修饰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 假设是主物理内存</span><br><span class="line"> *&#x2F;</span><br><span class="line">class MyData &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * volatile 修饰的关键字，是为了增加 主线程和线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知</span><br><span class="line">     *&#x2F;</span><br><span class="line">    volatile int number &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public void addTo60() &#123;</span><br><span class="line">        this.number &#x3D; 60;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出的结果为：</p><p><img data-src="image-20200309162314054.png" alt="image-20200309162314054"></p><p>主线程也执行完毕了，说明volatile修饰的变量，是具备JVM轻量级同步机制的，能够感知其它线程的修改后的值。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> JMM </tag>
            
            <tag> Volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop - NameNode和SecondaryNameNode工作机制讲解</title>
      <link href="/2019/09/27/hadoop-NameNode%E5%92%8CSecondaryNameNode%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E8%AE%B2%E8%A7%A3/"/>
      <url>/2019/09/27/hadoop-NameNode%E5%92%8CSecondaryNameNode%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-流程图如下："><a href="#1-流程图如下：" class="headerlink" title="1. 流程图如下："></a>1. 流程图如下：</h2><p><img data-src="15108298-5f345cec02de9258.png" alt></p><h2 id="2-FSImage和Edits"><a href="#2-FSImage和Edits" class="headerlink" title="2. FSImage和Edits"></a>2. FSImage和Edits</h2><p>nodenode是HDFS的大脑,它维护着整个文件系统的目录树,以及目录树里所有的文件和目录,这些信息以俩种文件存储在文件系统:一种是命名空间镜像(也称为文件系统镜像,File System Image,FSImage),即HDFS元数据的完整快照,每次NameNode启动的时候,默认会加载最新的命名空间镜像,另一种是命令空间镜像的编辑日志(Edit log)。</p><a id="more"></a><p>FSImage文件其实是文件系统元数据的一个永久性检查点，但并非每一个写操作都会更新这个文件，因为FSImage是一个大型文件，如果频繁地执行写操作，会使系统运行极为缓慢。解决方案是NameNode只将改动内容预写日志，即写入命名空间镜像的编辑日志。随着时间的推移，编辑日志会变得越来越大，那么一旦发生故障，将会话费非常多的时间来回滚操作，所以就像传统的关系数据库一样，需要定期地合并FSImage和编辑日志。如果由NameNode来做合并操作，那么NameNode在为集群提供服务时可能无法提供足够的资源，为了彻底解决这一问题，SecondaryNameNode应允而生。</p><h2 id="3-第一阶段：namenode-启动"><a href="#3-第一阶段：namenode-启动" class="headerlink" title="3. 第一阶段：namenode 启动"></a>3. 第一阶段：namenode 启动</h2><p>（1）第一次启动 namenode 格式化后，创建 fsimage 和 edits 文件。如果不是第一次启动，直接加载编辑日志和镜像文件到内存。<br>（2）客户端对元数据进行增删改的请求。<br>（3）namenode 记录操作日志，更新滚动日志。<br>（4）namenode 在内存中对数据进行增删改查。</p><h2 id="4-第二阶段：SecondaryNameNode-工作"><a href="#4-第二阶段：SecondaryNameNode-工作" class="headerlink" title="4. 第二阶段：SecondaryNameNode 工作"></a>4. 第二阶段：SecondaryNameNode 工作</h2><p>（1）SecondaryNameNode 询问 namenode 是否需要 checkpoint。直接带回 namenode 是否检查结果。<br>（2）Secondary NameNode 请求执行 checkpoint。<br>（3）Secondary NameNode引导namenode 滚动更新编辑正在写的 edits 日志。<br>（4） Secondary NameNode载入FSImage文件,回放编辑日志，将其合并到FSImage，将新的FSImage文件压缩后写入磁盘。<br>（5）拷贝 fsimage到 namenode。<br>（6）namenode 将 fsimage重新命名成 fsimage。</p><p>默认情况下，该过程每小时发生一次,或者当NameNode的编辑日志文件到达默认的64MB也会触发。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop - 单独配置辅助名称节点(SecondaryNameNode)</title>
      <link href="/2019/09/26/hadoop-%E5%8D%95%E7%8B%AC%E9%85%8D%E7%BD%AE%E8%BE%85%E5%8A%A9%E5%90%8D%E7%A7%B0%E8%8A%82%E7%82%B9-SecondaryNameNode/"/>
      <url>/2019/09/26/hadoop-%E5%8D%95%E7%8B%AC%E9%85%8D%E7%BD%AE%E8%BE%85%E5%8A%A9%E5%90%8D%E7%A7%B0%E8%8A%82%E7%82%B9-SecondaryNameNode/</url>
      
        <content type="html"><![CDATA[<h2 id="1-修改hdfs-site-xml"><a href="#1-修改hdfs-site-xml" class="headerlink" title="1. 修改hdfs-site.xml"></a>1. 修改hdfs-site.xml</h2><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /software/hadoop/etc/hadoop/hdfs-site.xml</span><br></pre></td></tr></table></figure><p>在hdfs-site.xml中添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;s138:9868&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-修改core-site-xml"><a href="#2-修改core-site-xml" class="headerlink" title="2. 修改core-site.xml"></a>2. 修改core-site.xml</h2><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /software/hadoop/etc/hadoop/core-site.xml</span><br></pre></td></tr></table></figure><p>在core-site.xml中添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;fs.checkpoint.period&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;60&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;fs.checkpoint.size&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;67108864&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>即可设置s138为辅助名称节点(SecondaryNameNode).</p><p>注意：要先stop-all.sh以后再进行配置，否则会出现两个SecondaryNameNode，原因如下：<br>如果不先停止，NameNode和SecondaryNameNode均在s135机器上已经启动了；<br>此时修改了配置文件，将SecondaryNameNode修改为s138后执行stop-all.sh停止hadoop，此时s135机器上的SecondaryNameNode进程是依然存在的；<br>原因就是执行stop-all.sh时，因配置已经被修改导致，s135机器上SecondaryNameNode进程未被停止，一直存在。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop - 常用命令</title>
      <link href="/2019/09/25/hadoop-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/09/25/hadoop-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>启动NameNode<br>hadoop-daemon.sh start namenode<br>hdfs –daemon start namenode<br>关闭NameNode<br>hadoop-daemon.sh stop namenode<br>hdfs –daemon stop  namenode</p><a id="more"></a><p>启动DataNode<br>hadoop-daemons.sh start datanode<br>hdfs –workers –daemon start datanode<br>关闭DataNode<br>hadoop-daemons.sh stop datanode<br>hdfs –workers –daemon stop datanode</p><p>启动SecondaryNameNode<br>hadoop-daemon.sh start secondarynamenode<br>hdfs –daemon start secondarynamenode<br>关闭SecondaryNameNode<br>hadoop-daemon.sh stop secondarynamenode<br>hdfs –daemon stop secondarynamenode</p><p>启动ResourceManager<br>yarn-daemon.sh start resourcemanager<br>yarn –daemon start resourcemanager<br>关闭ResourceManager<br>yarn-daemon.sh stop resourcemanager<br>yarn –daemon stop resourcemanager</p><p>启动NodeManager<br>yarn-daemons.sh start nodemanager<br>yarn –workers –daemon start nodemanager<br>关闭NodeManager<br>yarn-daemons.sh start nodemanager<br>yarn –workers –daemon start nodemanager</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop - 节点的服役和退役（HDFS）</title>
      <link href="/2019/09/23/hadoop-%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%8D%E5%BD%B9%E5%92%8C%E9%80%80%E5%BD%B9%EF%BC%88HDFS%EF%BC%89/"/>
      <url>/2019/09/23/hadoop-%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%8D%E5%BD%B9%E5%92%8C%E9%80%80%E5%BD%B9%EF%BC%88HDFS%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1-首先需要克隆一台主机"><a href="#1-首先需要克隆一台主机" class="headerlink" title="1. 首先需要克隆一台主机"></a>1. 首先需要克隆一台主机</h2><p>现在我这里已经有五台虚拟机，要克隆的目标主机为CentOS7-1810_04：</p><a id="more"></a><p><img data-src="15108298-69633cdb6b6b3546.png" alt="当前状态"></p><p><img data-src="15108298-ff8b304683346a6f.png" alt></p><p>启动集群后webUI如下：</p><p><img data-src="15108298-35e43e0cc74216fb.png" alt></p><p><img data-src="15108298-202a912e93e344ac.png" alt></p><p>把要克隆的目标虚拟机关机，在VMware上选中目标主机 -&gt; 右键 -&gt; 管理 -&gt; 克隆：</p><p><img data-src="15108298-fc03f42105d46933.png" alt="右键 -&gt; 管理 -&gt; 克隆"></p><p>然后下一步，选择克隆自：虚拟机中的当前状态：</p><p><img data-src="15108298-a4a0c9f159c56224.png" alt="克隆自虚拟机中的当前状态"></p><p>继续下一步，克隆方法选择：创建完整克隆：</p><p><img data-src="15108298-da50bcf7d741e751.png" alt="创建完整克隆"></p><p>继续下一步，修改虚拟机名称和位置：</p><p><img data-src="15108298-8893efd52c0e8db2.png" alt="修改虚拟机名称和位置"></p><p>然后选择完成，很快就克隆完了：</p><p><img data-src="15108298-52efaffcb0c88935.png" alt="克隆中"></p><p><img data-src="15108298-398e66a74d055999.png" alt="克隆完成"></p><p>可以看到，现在有六台虚拟机了：</p><p><img data-src="15108298-395532d0b8272fcf.png" alt></p><h2 id="2-修改新主机的IP和主机名等信息"><a href="#2-修改新主机的IP和主机名等信息" class="headerlink" title="2.修改新主机的IP和主机名等信息"></a>2.修改新主机的IP和主机名等信息</h2><p>执行命令<code>sudo vi /etc/hostname</code><br>修改主机名为：s140</p><p>执行命令<code>sudo vi /etc/sysconfig/network-scripts/ifcfg-ens33</code><br>修改主机IP为：192.168.11.140</p><p>然后重启虚拟机<br>现在就可以用MobaXterm_Personal_11.1连接了。</p><h2 id="3-复制完全分布式文件夹full为高可用文件夹ha"><a href="#3-复制完全分布式文件夹full为高可用文件夹ha" class="headerlink" title="3. 复制完全分布式文件夹full为高可用文件夹ha"></a>3. 复制完全分布式文件夹full为高可用文件夹ha</h2><p>其实这里之所以扩展到六台主机是为了给后边的高可用做铺垫，所以需要在<code>/software/hadoop/etc/</code>目录下建一个指向ha文件夹的hadoop软链接。当前<code>/software/hadoop/etc/</code>目录下是这样的：</p><p><img data-src="15108298-413b0f77b718e628.png" alt></p><p>依次执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xcall.sh "cp -rf /software/hadoop/etc/full /software/hadoop/etc/ha"</span><br><span class="line">xcall.sh "rm /software/hadoop/etc/hadoop"</span><br><span class="line">xcall.sh "ln -s /software/hadoop/etc/ha /software/hadoop/etc/hadoop"</span><br><span class="line">xcall.sh "ls -al /software/hadoop/etc/"</span><br></pre></td></tr></table></figure><p>现在/software/hadoop/etc目录下是这样的：</p><p><img data-src="15108298-6c53da80d79b87ef.png" alt="/software/hadoop/etc目录"><br><img data-src="15108298-f007a0257a756049.png" alt></p><h2 id="4-新建服役节点"><a href="#4-新建服役节点" class="headerlink" title="4. 新建服役节点"></a>4. 新建服役节点</h2><p>连接建立成功了，现在开始把新节点服役到集群上，因为新主机是从以前的主机拷贝来的，所以能够进行绵密需要删除以前的信息，在s135上依次执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /tmp/*</span><br><span class="line">rm -rf /software/hadoop/logs/*</span><br><span class="line">rm -rf ~/hadoop/*</span><br></pre></td></tr></table></figure><p>这样主机就变成一个新的主机了，接下来开始配置节点服役：<br>在/software/hadoop/etc目录下新建白名单文件include.hosts<br>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi include.hosts</span><br></pre></td></tr></table></figure><p>白名单文件s201:/software/hadoop/etc/include.hosts内容为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s136</span><br><span class="line">s137</span><br><span class="line">s138</span><br><span class="line">s139</span><br><span class="line">s140  //新添加的</span><br></pre></td></tr></table></figure><p>在hdfs-site.xml文件中添加属性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.hosts&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;/soft/hadoop/etc/dfs.include.txt&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>在nn上刷新节点，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfsadmin -refreshNodes</span><br></pre></td></tr></table></figure><p><img data-src="15108298-95b3a0e8005c74b1.png" alt></p><p>在/software/hadoop/etc/hadoop/works文件中添加新节点ip(主机名)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s135</span><br><span class="line">s136</span><br><span class="line">s137</span><br><span class="line">s138</span><br><span class="line">s139</span><br><span class="line">s140   //新添加的</span><br></pre></td></tr></table></figure><p>分发一下hdfs-site.xml文件和works文件（保证每个主机上的配置文件一样）</p><p><img data-src="15108298-41ed6d3e2d23e8ef.png" alt></p><p>单独启动新的节点s140中的datanode和rm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop-daemon.sh start datanode</span><br></pre></td></tr></table></figure><p><img data-src="15108298-1a01ecca17e297b4.png" alt></p><p>刷新webUI，此时：</p><p><img data-src="15108298-2fc07581e979effc.png" alt></p><p>节点已经变成了五个，服役成功！</p><h2 id="5-节点的退役"><a href="#5-节点的退役" class="headerlink" title="5. 节点的退役"></a>5. 节点的退役</h2><p>这里要把s139和s140都退役，<br>添加退役节点的ip到黑名单software/hadoop/etc/exclude.hosts，不要更新白名单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s139</span><br><span class="line">s140</span><br></pre></td></tr></table></figure><p>配置hdfs-site.xml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.hosts.exclude&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;/soft/hadoop/etc/dfs.hosts.exclude.txt&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>刷新NN节点和NM节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfsadmin -refreshNodes</span><br><span class="line">yarn rmadmin -refreshNodes</span><br></pre></td></tr></table></figure><p><img data-src="15108298-fe14391298fc02c1.png" alt></p><p>查看webUI，节点状态在Decommisstioning</p><p><img data-src="15108298-2cb3d2bcdc56bde9.png" alt></p><p>继续刷新webUI，当显示为如下：</p><p><img data-src="15108298-741ede8a2b31c7b2.png" alt></p><p>说明s139和s140已经退役成功。<br>（此时如果想要他们重新服役，只需要在黑名单中删除并重新刷新hdfs和yarn即可）</p><p>然后从白名单s135:/software/hadoop/etc/include.hosts删除已经退役的节点，并再次刷新节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfsadmin -refreshNodes</span><br><span class="line">yarn rmadmin -refreshNodes</span><br></pre></td></tr></table></figure><p>最后从works文件中删除退役节点。<br>再刷新webUI，显示如下：</p><p><img data-src="15108298-f548f6d6ad8da0a5.png" alt></p><p>退役成功。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop - 配置完全分布式模式并运行WordCount程序</title>
      <link href="/2019/09/20/hadoop-%E9%85%8D%E7%BD%AE%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E6%A8%A1%E5%BC%8F%E5%B9%B6%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/09/20/hadoop-%E9%85%8D%E7%BD%AE%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E6%A8%A1%E5%BC%8F%E5%B9%B6%E8%BF%90%E8%A1%8CWordCount%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<ul><li><ol><li>Hadoop三种模式便捷切换以及让命令行提示符显式完整路径<br> （1）Hadoop三种模式便捷切换<br> 首先执行如下命令：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[yylin@big etc]$ cp -r hadoop local</span><br><span class="line">[yylin@big etc]$ cp -r hadoop pseudo</span><br><span class="line">[yylin@big etc]$ cp -r hadoop full</span><br><span class="line">[yylin@big etc]$ rm -rf hadoop</span><br><span class="line">[yylin@big etc]$ ln -s pseudo hadoop</span><br></pre></td></tr></table></figure><a id="more"></a></li></ol><p>上面几条命令的结果是，将原有的hadoop文件夹复制三份，分别命名为local、pseudo和full，代表本地模式、伪分布式模式以及完全分布式模式，然后删除原有的hadoop文件夹，再创建hadoop符号链接指向pseudo文件夹。<br>这样做的好处是，如果想在这三种模式中切换的话，只需要修改hadoop符号链接指向不同的文件夹就好了。</p></li></ul><p>（2）让命令行提示符显式完整路径<br>（a）编辑/etc目录下的profile文件，添加环境变量PS1<br>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PS1='[\u@\h `pwd`]\$'</span><br></pre></td></tr></table></figure><br>（b）生效，执行命令<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><ul><li><ol start="2"><li>配置Hadoop伪分布式模式</li></ol></li></ul><p>（1）进入${HADOOP_HOME}/etc/hadoop目录，在该目录下有好多文件，主要需要配置的是四个文件，分别是core-site.xml、hdfs-site.xml、mapred-site.xml和yarn-site.xml。<br><img data-src="15108298-bd34ae87a6a25fc1.png" alt><br>从图中看到，没有mapred-site.xml，有个mapred-site.xml.template，复制并重命名为mapred-site.xml即可。<br>（2）编辑core-site.xml：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://s135/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）编辑hdfs-site.xml，可以看到副本数为3：<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置hadoop.tmp.dir目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/yylin/hadoop<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><br>（4）编辑mapred-site.xml：<br>注意:cp mapred-site.xml.template mapred-site.xml<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.app.mapreduce.am.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><br>（5）编辑yarn-site.xml：<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>s135<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li><ol start="3"><li>配置SSH</li></ol></li></ul><p>（1）检查是否安装了ssh相关软件包(openssh-server + openssh-clients + openssh)<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[yylin@big hadoop]$ yum <span class="built_in">list</span> installed | grep ssh</span><br></pre></td></tr></table></figure><br><img data-src="15108298-72d2dda241584a36.png" alt><br>（2）检查是否启动了sshd进程</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[yylin@big hadoop]$ ps -Af | grep sshd</span><br></pre></td></tr></table></figure><p><img data-src="15108298-b3c4d50f7ab94f73.png" alt></p><p>（3）在client侧生成公私秘钥对。<br>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[yylin@big ~]$ ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><br><img data-src="15108298-680b37d97a122282.png" alt></p><p>（4）生成~/.ssh文件夹，里面有id_rsa(私钥) + id_rsa.pub(公钥)<br><img data-src="15108298-984f5579f7349a84.png" alt></p><p>（5）追加公钥到~/.ssh/authorized_keys文件中(文件名、位置固定)<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[yylin@big ~]$ cd ~/.ssh</span><br><span class="line">[yylin@big .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure><br><img data-src="15108298-d251817e0b891f38.png" alt></p><p>（6）修改authorized_keys的权限为644.<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[yylin@big .ssh]$ chmod <span class="number">644</span> authorized_keys</span><br></pre></td></tr></table></figure><br><img data-src="15108298-f5d2eeb48ce436a6.png" alt></p><p>（7）测试<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[yylin@big .ssh]$ ssh localhost</span><br></pre></td></tr></table></figure><br><img data-src="15108298-7a2de01e6b3a7791.png" alt><br><img data-src="15108298-e41e5f8db9255bcc.png" alt></p><p>（8）格式化名称节点<br>运行命令：<code>hdfs namenode -format</code></p><blockquote><p>到此为止，完全分布模式配置成功。</p></blockquote><p>（9）启动Hadoop服务<br>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure><p>启动namenodes、datanodes、secondary namenodes</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure><p>启动resourcemanager、nodemanagers<br>（10）浏览器访问namenode节点<br><code>http://s135:9870</code><br>可以看到hadoop的信息<br><img data-src="15108298-d6d24af8437191c0.png" alt></p><ul><li><ol start="4"><li>运行WordCount入门程序</li></ol></li></ul><p>（1）WordCount程序介绍<br>WordCount是hadoop学习的helloword级别的练习程序，可以统计英文单词的数目，在hadoop中有此示例程序，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.hadoop.examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.GenericOptionsParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> </span></span><br><span class="line"><span class="class">       <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> IntWritable one = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> Text word = <span class="keyword">new</span> Text();</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context</span></span></span><br><span class="line"><span class="function"><span class="params">                    )</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">      StringTokenizer itr = <span class="keyword">new</span> StringTokenizer(value.toString());</span><br><span class="line">      <span class="keyword">while</span> (itr.hasMoreTokens()) &#123;</span><br><span class="line">        word.set(itr.nextToken());</span><br><span class="line">        context.write(word, one);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span> </span></span><br><span class="line"><span class="class">       <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">IntWritable</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IntWritable result = <span class="keyword">new</span> IntWritable();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, </span></span></span><br><span class="line"><span class="function"><span class="params">                       Context context</span></span></span><br><span class="line"><span class="function"><span class="params">                       )</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (IntWritable val : values) &#123;</span><br><span class="line">        sum += val.get();</span><br><span class="line">      &#125;</span><br><span class="line">      result.set(sum);</span><br><span class="line">      context.write(key, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">    String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">    <span class="keyword">if</span> (otherArgs.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      System.err.println(<span class="string">"Usage: wordcount &lt;in&gt; [&lt;in&gt;...] &lt;out&gt;"</span>);</span><br><span class="line">      System.exit(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Job job = Job.getInstance(conf, <span class="string">"word count"</span>);</span><br><span class="line">    job.setJarByClass(WordCount<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    job.setMapperClass(TokenizerMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    job.setCombinerClass(IntSumReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    job.setReducerClass(IntSumReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    job.setOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; otherArgs.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">      FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(otherArgs[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    FileOutputFormat.setOutputPath(job,</span><br><span class="line">      <span class="keyword">new</span> Path(otherArgs[otherArgs.length - <span class="number">1</span>]));</span><br><span class="line">    System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将代码拷入工程中。<br>接下来用Maven构建工程，用idea导出jar包。<br>idea的pom.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>nwpu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>WordCount<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-hdfs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--注意，此处必须是main()方法对应类的完整路径  --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>org.apache.hadoop.examples.WordCountAPP<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>assembly<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后导出jar包<br><img data-src="15108298-9c8dda6ceb0d4f96.png" alt><br>依次点击idea右侧栏的maven-&gt;WordCount-&gt;Lifecycle-&gt;(clean compile package install)，即可生成jar包，目录如下：<br><img data-src="15108298-34dbe6924561f855.png" alt><br>jar包导入服务器上，hello.txt文件put到hdfs文件系统上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -put input &#x2F;user&#x2F;yylin&#x2F;</span><br></pre></td></tr></table></figure><p>运行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar WordCount-1.0-SNAPSHOT.jar &#x2F;user&#x2F;yylin&#x2F;input &#x2F;user&#x2F;yylin&#x2F;output</span><br></pre></td></tr></table></figure><p><img data-src="15108298-d40c16dbb8cd20c8.png" alt><br><img data-src="15108298-b5da3afcfb2f240a.png" alt><br><img data-src="15108298-f087230b866e3c07.png" alt></p><blockquote><p>成功了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Linux </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop - MR计算模型</title>
      <link href="/2019/09/17/MR%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/09/17/MR%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="从一个MapReduce实例开始"><a href="#从一个MapReduce实例开始" class="headerlink" title="从一个MapReduce实例开始"></a>从一个MapReduce实例开始</h2><ul><li>mapreduce介绍</li></ul><p>​    MapReduce作为hadoop的核心价值之一，实现数据的分析和处理。相比于关系型数据库地持续更新，mr更适合批处理需要分析的数据集，一次写入，多次读取。</p><a id="more"></a><p>​    MapReduce分为两个处理阶段，map阶段和reduce阶段。编写一个mr实例，共需要三个部分:</p><ol><li>map函数：进行数据读取，排序；map输出对应的reduce的输入(类型一致)</li><li>reduce函数：实现逻辑处理</li><li>job配置：控制整个作业的运行</li></ol><h3 id="实例介绍"><a href="#实例介绍" class="headerlink" title="实例介绍"></a>实例介绍</h3><p>​    官方的说明中，以wordcount作为示例。这里我们稍作改变，来统计一篇文章中指定的符号的数据量,类似于sql中where条件下的计数。如下引入的包都是以org.apache.hadoop开头的，包名误入会导致错误，注意，不同的版本对应的包名也存在差别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable pos, Text content, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        String javaContent = content.toString();</span><br><span class="line">        Long count = Arrays.asList(javaContent.split(<span class="string">""</span>)).stream().filter(x -&gt; x.equals(<span class="string">"。"</span>)).count();</span><br><span class="line">        context.write(<span class="keyword">new</span> Text(<span class="string">"。"</span>), <span class="keyword">new</span> IntWritable(count.intValue()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text outKey, Iterable&lt;IntWritable&gt; cnt, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        Integer tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (IntWritable perCount : cnt) &#123;</span><br><span class="line">            tot += perCount.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(outKey, <span class="keyword">new</span> IntWritable(tot));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CLassName</span> ArticleCommaCount</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> yylin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleCommaCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"一个统计文章中有多少句号的示例！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, IllegalStateException,ClassNotFoundException,InterruptedException </span>&#123;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line"></span><br><span class="line">        job.setMapperClass(ArticleMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(ArticleReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setJobName(args[<span class="number">0</span>]);</span><br><span class="line">        job.setJarByClass(ArticleCommaCount<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">        System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的pom.xml文件的dependency</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-hdfs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-mapreduce-client-jobclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-mapreduce-client-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-mapreduce-client-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="运行实例"><a href="#运行实例" class="headerlink" title="运行实例"></a>运行实例</h3><ul><li><p>通过hadoop jar命令：hadoop jar mrtest-1.0-SNAPSHOT.jar ArticleCommaCount /user/sunhj/input /user/sunhj/output</p></li><li><p>注意事项</p><ol><li><p>ArticleCommaCount: args[0] ,设置为jobName,args[1]是输入文件,args[2]是输出文件</p></li><li><p>打包的jar文件需要放到hadoop集群的机器上，不要放到hdfs文件系统中</p></li></ol></li></ul><h3 id="运行日志"><a href="#运行日志" class="headerlink" title="运行日志"></a>运行日志</h3><p>​    作业运行过程中，将mr进度输出至控制台，过程中的一些重要信息都可以从日志中进行查看。也方便进行优化分析。</p><p>​    由于日志在控制台上查阅的不便，hadoop也提供了相关的http页面访问。namenode内嵌的web服务器提供了相关服务。包含端口: 50070(目录服务)；8088(执行scheduler)；19888(执行历史)</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line"><span class="number">19</span>/<span class="number">11</span>/<span class="number">09</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">31</span> INFO mapred<span class="variable">.MapTask</span>: mapreduce<span class="variable">.task</span><span class="variable">.io</span><span class="variable">.sort</span><span class="variable">.mb</span>: <span class="number">100</span></span><br><span class="line"><span class="number">19</span>/<span class="number">11</span>/<span class="number">09</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">31</span> INFO mapred<span class="variable">.MapTask</span>: <span class="keyword">soft</span> limit at <span class="number">83886080</span></span><br><span class="line"><span class="number">19</span>/<span class="number">11</span>/<span class="number">09</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">31</span> INFO mapred<span class="variable">.MapTask</span>: bufstart = <span class="number">0</span>; bufvoid = <span class="number">104857600</span></span><br><span class="line"><span class="number">19</span>/<span class="number">11</span>/<span class="number">09</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">31</span> INFO mapred<span class="variable">.MapTask</span>: kvstart = <span class="number">26214396</span>; length = <span class="number">6553600</span></span><br><span class="line"><span class="number">19</span>/<span class="number">11</span>/<span class="number">09</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">31</span> INFO mapred<span class="variable">.MapTask</span>: Map <span class="keyword">output</span> collector <span class="keyword">class</span> = org<span class="variable">.apache</span><span class="variable">.hadoop</span><span class="variable">.mapred</span><span class="variable">.MapTask</span>$MapOutputBuffer</span><br><span class="line"><span class="number">19</span>/<span class="number">11</span>/<span class="number">09</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">31</span> INFO mapred<span class="variable">.LocalJobRunner</span>: </span><br><span class="line"><span class="number">19</span>/<span class="number">11</span>/<span class="number">09</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">31</span> INFO mapred<span class="variable">.MapTask</span>: Starting flush of map <span class="keyword">output</span></span><br><span class="line"><span class="number">19</span>/<span class="number">11</span>/<span class="number">09</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">31</span> INFO mapred<span class="variable">.MapTask</span>: Spilling map <span class="keyword">output</span></span><br><span class="line"><span class="number">19</span>/<span class="number">11</span>/<span class="number">09</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">31</span> INFO mapred<span class="variable">.MapTask</span>: bufstart = <span class="number">0</span>; bufend = <span class="number">392</span>; bufvoid = <span class="number">104857600</span></span><br><span class="line"><span class="number">19</span>/<span class="number">11</span>/<span class="number">09</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">31</span> INFO mapred<span class="variable">.MapTask</span>: kvstart = <span class="number">26214396</span>(<span class="number">104857584</span>); kvend = <span class="number">26214204</span>(<span class="number">104856816</span>); length = <span class="number">193</span>/<span class="number">6553600</span></span><br><span class="line"><span class="number">19</span>/<span class="number">11</span>/<span class="number">09</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">31</span> INFO mapred<span class="variable">.MapTask</span>: Finished spill <span class="number">0</span></span><br><span class="line"><span class="number">19</span>/<span class="number">11</span>/<span class="number">09</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">31</span> INFO mapred<span class="variable">.Task</span>: Task:attempt_local1667141322_0001_m_000000_0 is done. And is in the process of committing</span><br><span class="line"><span class="number">19</span>/<span class="number">11</span>/<span class="number">09</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">31</span> INFO mapred<span class="variable">.LocalJobRunner</span>: map</span><br><span class="line"><span class="number">19</span>/<span class="number">11</span>/<span class="number">09</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">31</span> INFO mapred<span class="variable">.Task</span>: Task 'attempt_local1667141322_0001_m_000000_0' done.</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><h3 id="job运行过程"><a href="#job运行过程" class="headerlink" title="job运行过程"></a>job运行过程</h3><p>当前的hadoop基本都运行在yarn上，由yarn进行资源管理。权威指南对MapReduce的工作机制有过详细的描述</p><p><img data-src="17319977-9c3ce4d579428747.webp" alt="img"></p><p>hd权威-mr机制.png</p><p>图中大体描述了mr-job的整个过程。我在网上也找到了其他的一些更为详细的图形描述：</p><p><img data-src="17319977-5ffed77c01558541.webp" alt="img"></p><p>yarn-工作机制.png</p><p>（0）Mr程序提交到客户端所在的节点</p><p>（1）Yarnrunner向Resourcemanager申请一个Application。</p><p>（2）rm将该应用程序的资源路径返回给yarnrunner</p><p>（3）该程序将运行所需资源提交到HDFS上</p><p>（4）程序资源提交完毕后，申请运行mrAppMaster</p><p>（5）RM将用户的请求初始化成一个task</p><p>（6）其中一个NodeManager领取到task任务。</p><p>（7）该NodeManager创建容器Container，并产生MRAppmaster</p><p>（8）Container从HDFS上拷贝资源到本地</p><p>（9）MRAppmaster向RM 申请运行maptask容器</p><p>（10）RM将运行maptask任务分配给另外两个NodeManager，另两个NodeManager分别领取任务并创建容器。</p><p>（11）MR向两个接收到任务的NodeManager发送程序启动脚本，这两个NodeManager分别启动maptask，maptask对数据分区排序。</p><p>（12）MRAppmaster向RM申请2个容器，运行reduce task。</p><p>（13）reduce task向maptask获取相应分区的数据。</p><p>（14）程序运行完毕后，MR会向RM注销自己。</p><h3 id="MR运行过程"><a href="#MR运行过程" class="headerlink" title="MR运行过程"></a>MR运行过程</h3><p><img data-src="17319977-bb0a3efce2aad038.webp" alt="img"></p><p>hadoop-mr.png</p><p>整个流程可以分为 split，map，shuffle，reduce，output 五个阶段</p><ol><li><p>split过程</p><p>split 阶段会把需要处理的数据划分为不同的切片，切片的过程由对应的inputfile类来处理；把个切片交给不同 map 程序进行处理；切片后数据会被解析为 kv 对输入到 map 进行处理（默认是一行调用一次map函数）</p></li><li><p>map函数</p><p>对输入的 kv 对进行处理并以 kv 对的形式输出，这个阶段适合数据过滤、清洗。</p></li><li><p>shuffle过程</p><p>shuffle是整个mr的核心，让map输出结果到reduce的输入都是按键排序的。系统执行排序的过程称为shuffle(混洗 -&gt; 洗得有序)</p></li><li><p>reduce函数</p><p>对输入的 kv 对进行处理并以 kv 对的形式输出，一个reduce对应的一个文件。该阶段适合进行逻辑处理加工处理</p></li><li><p>output过程</p><p>输出到指定的hdfs目录下</p></li></ol><h2 id="关于shuffle"><a href="#关于shuffle" class="headerlink" title="关于shuffle"></a>关于shuffle</h2><p>   shuffle是MapReduce的”心脏”,是奇迹发生的地方。shuffle过程分成两个阶段，一个在map端，一个在reduce端。</p><p><img data-src="17319977-282ebbb8c6acdd9b.webp" alt="img"></p><p>mr-shuffle.png</p><ol><li><p>map端</p><p>map阶段产生的输出并不是简单的写到磁盘，而是有一个缓存溢写的过程。每个map都有一个环形缓冲区(io.sort.mb=100 io.sort.spill.percent=0.8 默认)，当缓冲内容超过阈值，将会写入磁盘。写入磁盘之前会对写入数据根据要传的reduce进行分区(partition)，每个分区按键排序【如果有combiner，会对写的数据进行合并，数据更紧凑，减少到reduce的网络传输；】；每次缓冲区达到阈值就会溢写文件，溢写的文件会进行merge(一次合并多少文件 io.sort.factor=10 默认 )；这时，往往会对最后的数据进行压缩，以减少数据传输过程中的网络消耗(设置map.compress.map.output为true)</p></li><li><p>reduce端</p><p>reduce的输入是map阶段的输出，reduce将来自各个map任务的输出【partitions】copy过来。map阶段的输出都在对应的tasktracker本地磁盘上。由于map阶段耗时存在差异，但只要有一个map完成，reduce任务就开始复制其输出。复制过程也是一个溢写(mapred.job.shuffle.input.buffer.percent)，当超过reduce任务jvm内存阈值时，会写入磁盘。随着磁盘中文件数越来越多，便会进行merge。</p></li></ol><h2 id="MR的优化方向"><a href="#MR的优化方向" class="headerlink" title="MR的优化方向"></a>MR的优化方向</h2><p>mr的优化，往往考验着对mapreduce的理解程度。决定mr计算的效率因素比较多，比如机器性能、sql编写习惯、参数调优等。工作中，主要会考虑几个方面：</p><ol><li><p>join过程中是否有数据倾斜</p><p>join过程中，关联的key会作为map阶段的partition，进而会导致reduce阶段数据倾斜。考虑</p><p>a.设置更大的reduce数(比较粗暴);</p><p>b. 将倾斜的key单独拿出来计算(比较笨拙)</p><p>c. 不影响业务情况下，对倾斜的key进行发散(随机值方式，推荐)</p><p>d. 设置倾斜参数(set hive.groupby.skewindata=true;set hive.map.aggr = true; 懒汉模式)</p></li><li><p>合理map和reduce数</p><p>​    一般情况下建议map完成时间在1min左右，map数太多(分片太小)会导致map启动耗时和资源争抢，太少又不能很好的发挥mr的优势，task等待。实际情况中，建议和block大小保持一致；另外，小文件会产生大量map数</p><p>​    规避使用reduce，避免产生大量的网络消耗；在大表join过程中，shuffle过程往往是整个过程的瓶颈，尽量在map端进行combine，减少读写磁盘。</p></li><li><p>常用优化参数</p><table><thead><tr><th>配置参数</th><th>参数说明</th></tr></thead><tbody><tr><td>mapreduce.map.memory.mb</td><td>一个Map Task可使用的资源上限（单位:MB），默认为1024。如果Map Task实际使用的资源量超过该值，则会被强制杀死。</td></tr><tr><td>mapreduce.reduce.memory.mb</td><td>一个Reduce Task可使用的资源上限（单位:MB），默认为1024。如果Reduce Task实际使用的资源量超过该值，则会被强制杀死。</td></tr><tr><td>mapreduce.map.cpu.vcores</td><td>每个Map task可使用的最多cpu core数目，默认值: 1</td></tr><tr><td>mapreduce.reduce.cpu.vcores</td><td>每个Reduce task可使用的最多cpu core数目，默认值: 1</td></tr><tr><td>mapreduce.reduce.shuffle.parallelcopies</td><td>每个reduce去map中拿数据的并行数。默认值是5</td></tr><tr><td>mapreduce.reduce.shuffle.merge.percent</td><td>buffer中的数据达到多少比例开始写入磁盘。默认值0.66</td></tr><tr><td>mapreduce.reduce.shuffle.input.buffer.percent</td><td>buffer大小占reduce可用内存的比例。默认值0.7</td></tr><tr><td>mapreduce.reduce.input.buffer.percent</td><td>指定多少比例的内存用来存放buffer中的数据，默认值是0.0</td></tr></tbody></table></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Linux </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop - 环境搭建（安装JDK+安装hadoop+配置本地模式）</title>
      <link href="/2019/09/15/hadoop-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88%E5%AE%89%E8%A3%85JDK-%E5%AE%89%E8%A3%85hadoop-%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E6%A8%A1%E5%BC%8F%EF%BC%89/"/>
      <url>/2019/09/15/hadoop-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88%E5%AE%89%E8%A3%85JDK-%E5%AE%89%E8%A3%85hadoop-%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E6%A8%A1%E5%BC%8F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h1><h2 id="a-下载jdk-8u65-linux-x64-tar-gz"><a href="#a-下载jdk-8u65-linux-x64-tar-gz" class="headerlink" title="a) 下载jdk-8u65-linux-x64.tar.gz"></a>a) 下载jdk-8u65-linux-x64.tar.gz</h2><h2 id="b-上传并tar开"><a href="#b-上传并tar开" class="headerlink" title="b)上传并tar开"></a>b)上传并tar开</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ mkdir downloads</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="c-利用FileZilla把jdk-8u65-linux-x64-tar-gz上传到-downloads-目录下"><a href="#c-利用FileZilla把jdk-8u65-linux-x64-tar-gz上传到-downloads-目录下" class="headerlink" title="c)利用FileZilla把jdk-8u65-linux-x64.tar.gz上传到~/downloads/目录下"></a>c)利用FileZilla把<code>jdk-8u65-linux-x64.tar.gz</code>上传到~/downloads/目录下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;downloads&#x2F;</span><br><span class="line">$ cd ls</span><br></pre></td></tr></table></figure><p><img data-src="15108298-720a949c4030a0b6.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf jdk-8u65-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p><img data-src="15108298-a785cd1842531953.png" alt></p><h2 id="d-创建-soft文件夹"><a href="#d-创建-soft文件夹" class="headerlink" title="d)创建/soft文件夹"></a>d)创建/soft文件夹</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir &#x2F;soft</span><br></pre></td></tr></table></figure><p>  <img data-src="15108298-acd1c2b91be3e01a.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown yylin:yylin &#x2F;soft</span><br></pre></td></tr></table></figure><p>  <img data-src="15108298-3affa1cf0d2e7557.png" alt></p><h2 id="e-移动tar开的文件到-soft下"><a href="#e-移动tar开的文件到-soft下" class="headerlink" title="e)移动tar开的文件到/soft下"></a>e)移动tar开的文件到/soft下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv ~&#x2F;downloads&#x2F;jdk1.8.0_65 &#x2F;soft&#x2F;</span><br></pre></td></tr></table></figure><p>  <img data-src="15108298-72e51ebd3bbcfe79.png" alt></p><h2 id="f-创建符号连接"><a href="#f-创建符号连接" class="headerlink" title="f)创建符号连接"></a>f)创建符号连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s &#x2F;soft&#x2F;jdk1.8.0_65 &#x2F;soft&#x2F;jdk</span><br></pre></td></tr></table></figure><p>  <img data-src="15108298-cf7c7d295e853364.png" alt></p><h2 id="g-验证jdk安装是否成功"><a href="#g-验证jdk安装是否成功" class="headerlink" title="g)验证jdk安装是否成功"></a>g)验证jdk安装是否成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;soft&#x2F;jdk&#x2F;bin</span><br><span class="line">$ .&#x2F;java -version</span><br></pre></td></tr></table></figure><p>  <img data-src="15108298-124d0fc1c1aa25f3.png" alt><br>  出现java版本信息，说明安装成功，接下来配置环境变量。</p><h2 id="h-配置java环境变量"><a href="#h-配置java环境变量" class="headerlink" title="h)配置java环境变量"></a>h)配置java环境变量</h2><h3 id="（1）编辑-etc-profile"><a href="#（1）编辑-etc-profile" class="headerlink" title="（1）编辑/etc/profile"></a>（1）编辑/etc/profile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>  在profile文件最后加上下面两行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">export</span> JAVA_HOME=/soft/jdk</span><br><span class="line">exprot PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><h3 id="（2）使环境变量即刻生效"><a href="#（2）使环境变量即刻生效" class="headerlink" title="（2）使环境变量即刻生效"></a>（2）使环境变量即刻生效</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><h3 id="（3）进入任意目录下-测试是否ok"><a href="#（3）进入任意目录下-测试是否ok" class="headerlink" title="（3）进入任意目录下,测试是否ok"></a>（3）进入任意目录下,测试是否ok</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ java -version</span><br></pre></td></tr></table></figure><p><img data-src="15108298-537f42cc39035543.png" alt><br>  出现java版本信息，说明JDK环境变量配置成功。</p><h1 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h1><h2 id="（1）安装hadoop"><a href="#（1）安装hadoop" class="headerlink" title="（1）安装hadoop"></a>（1）安装hadoop</h2><h3 id="a-下载-hadoop-2-7-7-tar-gz"><a href="#a-下载-hadoop-2-7-7-tar-gz" class="headerlink" title="a)下载 hadoop-2.7.7.tar.gz"></a>a)下载 <a href="https://www-eu.apache.org/dist/hadoop/common/hadoop-2.7.7/hadoop-2.7.7.tar.gz" target="_blank" rel="noopener">hadoop-2.7.7.tar.gz</a></h3><h3 id="b-上传并tar开-1"><a href="#b-上传并tar开-1" class="headerlink" title="b)上传并tar开"></a>b)上传并tar开</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[yylin@big ~]$ cd ~/downloads/</span><br><span class="line">[yylin@big downloads]$ ll</span><br><span class="line">total <span class="number">390612</span></span><br><span class="line">-rw-rw-r--. <span class="number">1</span> yylin yylin <span class="number">218720521</span> May  <span class="number">7</span> <span class="number">17</span>:<span class="number">36</span> hadoop<span class="number">-2.7</span><span class="number">.7</span>.tar.gz</span><br><span class="line">-rw-rw-r--. <span class="number">1</span> yylin yylin <span class="number">181260798</span> May  <span class="number">3</span> <span class="number">19</span>:<span class="number">32</span> jdk<span class="number">-8u</span>65-linux-x64.tar.gz</span><br><span class="line">[yylin@big downloads]$ tar -zxvf hadoop<span class="number">-2.7</span><span class="number">.7</span></span><br><span class="line">......</span><br><span class="line">[yylin@big downloads]$ ll</span><br><span class="line">total <span class="number">390612</span></span><br><span class="line">drwxr-xr-x. <span class="number">9</span> yylin yylin       <span class="number">149</span> Jul <span class="number">19</span>  <span class="number">2018</span> hadoop<span class="number">-2.7</span><span class="number">.7</span></span><br><span class="line">-rw-rw-r--. <span class="number">1</span> yylin yylin <span class="number">218720521</span> May  <span class="number">7</span> <span class="number">17</span>:<span class="number">36</span> hadoop<span class="number">-2.7</span><span class="number">.7</span>.tar.gz</span><br><span class="line">-rw-rw-r--. <span class="number">1</span> yylin yylin <span class="number">181260798</span> May  <span class="number">3</span> <span class="number">19</span>:<span class="number">32</span> jdk<span class="number">-8u</span>65-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="c-移动tar开的文件到-soft下，并创建符号连接"><a href="#c-移动tar开的文件到-soft下，并创建符号连接" class="headerlink" title="c)移动tar开的文件到/soft下，并创建符号连接"></a>c)移动tar开的文件到/soft下，并创建符号连接</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[yylin@big downloads]$ mv ~/downloads/hadoop<span class="number">-2.7</span><span class="number">.7</span> /soft/</span><br><span class="line">[yylin@big downloads]$ cd /soft/</span><br><span class="line">[yylin@big soft]$ ll</span><br><span class="line">total <span class="number">0</span></span><br><span class="line">drwxr-xr-x. <span class="number">9</span> yylin yylin <span class="number">149</span> Jul <span class="number">19</span>  <span class="number">2018</span> hadoop<span class="number">-2.7</span><span class="number">.7</span></span><br><span class="line">lrwxrwxrwx. <span class="number">1</span> yylin yylin  <span class="number">18</span> May  <span class="number">6</span> <span class="number">21</span>:<span class="number">31</span> jdk -&gt; /soft/jdk1<span class="number">.8</span><span class="number">.0</span>_65/</span><br><span class="line">drwxr-xr-x. <span class="number">8</span> yylin yylin <span class="number">255</span> Oct  <span class="number">7</span>  <span class="number">2015</span> jdk1<span class="number">.8</span><span class="number">.0</span>_65</span><br><span class="line">[yylin@big soft]$ ln -s /soft/hadoop<span class="number">-2.7</span><span class="number">.7</span> /soft/hadoop</span><br><span class="line">[yylin@big soft]$ ll</span><br><span class="line">total <span class="number">0</span></span><br><span class="line">lrwxrwxrwx. <span class="number">1</span> yylin yylin  <span class="number">18</span> May  <span class="number">7</span> <span class="number">17</span>:<span class="number">45</span> hadoop -&gt; /soft/hadoop<span class="number">-2.7</span><span class="number">.7</span></span><br><span class="line">drwxr-xr-x. <span class="number">9</span> yylin yylin <span class="number">149</span> Jul <span class="number">19</span>  <span class="number">2018</span> hadoop<span class="number">-2.7</span><span class="number">.7</span></span><br><span class="line">lrwxrwxrwx. <span class="number">1</span> yylin yylin  <span class="number">18</span> May  <span class="number">6</span> <span class="number">21</span>:<span class="number">31</span> jdk -&gt; /soft/jdk1<span class="number">.8</span><span class="number">.0</span>_65/</span><br><span class="line">drwxr-xr-x. <span class="number">8</span> yylin yylin <span class="number">255</span> Oct  <span class="number">7</span>  <span class="number">2015</span> jdk1<span class="number">.8</span><span class="number">.0</span>_65</span><br></pre></td></tr></table></figure><h3 id="d-验证jdk安装是否成功（出现版本信息，说明安装成功）"><a href="#d-验证jdk安装是否成功（出现版本信息，说明安装成功）" class="headerlink" title="d)验证jdk安装是否成功（出现版本信息，说明安装成功）"></a>d)验证jdk安装是否成功（出现版本信息，说明安装成功）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[yylin@big hadoop]$ cd /soft/hadoop/bin/</span><br><span class="line">[yylin@big bin]$ ls</span><br><span class="line">container-executor  hadoop.cmd  hdfs.cmd  mapred.cmd  test-container-executor  yarn.cmd hadoop hdfs mapred rcc yarn</span><br><span class="line">[yylin@big bin]$ ./hadoop version</span><br><span class="line">Hadoop <span class="number">2.7</span><span class="number">.7</span></span><br><span class="line">Subversion Unknown -r c1aad84bd27cd79c3d1a7dd58202a8c3ee1ed3ac</span><br><span class="line">Compiled by stevel on <span class="number">2018</span><span class="number">-07</span><span class="number">-18</span>T22:<span class="number">47</span>Z</span><br><span class="line">Compiled with protoc <span class="number">2.5</span><span class="number">.0</span></span><br><span class="line">From source with checksum <span class="number">792e15</span>d20b12c74bd6f19a1fb886490</span><br><span class="line">This command was <span class="built_in">run</span> <span class="keyword">using</span> /soft/hadoop<span class="number">-2.7</span><span class="number">.7</span>/share/hadoop/common/hadoop-common<span class="number">-2.7</span><span class="number">.7</span>.jar</span><br></pre></td></tr></table></figure><h2 id="（2）配置hadoop环境变量"><a href="#（2）配置hadoop环境变量" class="headerlink" title="（2）配置hadoop环境变量"></a>（2）配置hadoop环境变量</h2><p>编辑/etc/profile文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[yylin@big bin]$ sudo vi /etc/profile</span><br></pre></td></tr></table></figure><p>在profile文件最后加上下面两行<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">export</span> HADOOP_HOME=/soft/hadoop</span><br><span class="line"><span class="keyword">export</span> PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure></p><h2 id="（3）生效并测试"><a href="#（3）生效并测试" class="headerlink" title="（3）生效并测试"></a>（3）生效并测试</h2>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[yylin@big bin]$ source /etc/profile</span><br><span class="line">[yylin@big bin]$ cd ~</span><br><span class="line">[yylin@big ~]$ hadoop version</span><br><span class="line">Hadoop <span class="number">2.7</span><span class="number">.7</span></span><br><span class="line">Subversion Unknown -r c1aad84bd27cd79c3d1a7dd58202a8c3ee1ed3ac</span><br><span class="line">Compiled by stevel on <span class="number">2018</span><span class="number">-07</span><span class="number">-18</span>T22:<span class="number">47</span>Z</span><br><span class="line">Compiled with protoc <span class="number">2.5</span><span class="number">.0</span></span><br><span class="line">From source with checksum <span class="number">792e15</span>d20b12c74bd6f19a1fb886490</span><br><span class="line">This command was <span class="built_in">run</span> <span class="keyword">using</span> /soft/hadoop<span class="number">-2.7</span><span class="number">.7</span>/share/hadoop/common/hadoop-common<span class="number">-2.7</span><span class="number">.7</span>.jar</span><br></pre></td></tr></table></figure><p>经过上述操作就搭建好了hadoop环境，到目前为止是本地模式（单机模式），接下来配置完全分布式模式。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Linux </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Hadoop </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划算法</title>
      <link href="/2019/08/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划问题"><a href="#动态规划问题" class="headerlink" title="动态规划问题"></a>动态规划问题</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>背包问题：有个背包，初始容量为4磅，现有如下物品</p><p>0 - 1背包问题，转入的商品不能重复</p><table><thead><tr><th>物品</th><th>重量</th><th>价格</th></tr></thead><tbody><tr><td>吉他</td><td>1</td><td>1500</td></tr><tr><td>音箱</td><td>4</td><td>3000</td></tr><tr><td>电脑</td><td>3</td><td>2000</td></tr></tbody></table><a id="more"></a><p>1）要求达到的目标为装入的背包的总价值最大，并且重量不能超过</p><p>2）要求装入物品不能重复</p><h2 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>动态规划（DynamicProgramming）算法的核心思想是：将大问题划分成小问题进行解决，从而一步步获取最优解的处理算法</li><li>动态规划算法与分治法类似，其基本思想也是将带求解问题，分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</li><li>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的，（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步求解）</li><li>动态规划可以通过填表的方式来逐步推进，得到最优解</li></ul><h3 id="求解-0-1背包问题"><a href="#求解-0-1背包问题" class="headerlink" title="求解 0-1背包问题"></a>求解 0-1背包问题</h3><ul><li>背包问题主要指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使得物品价值最大，其中又分为01背包和完全背包（完全背包指的是：每个物品都是无限件可用）</li><li>这里的问题属于01背包问题，即每个物品最多放一个，而无限背包可以转回成01背包问题</li></ul><h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>算法的主要思想，利用动态规划来解决，每次遍历到第i个物品，根据 w[i] 和 v[i] 来确定是否需要将该物品放入背包中，即对于给定的n个物品，设v[i] 、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i] [j] 表示前i个物品中能够装入容量为j的背包中的最大价值，则我们有下面的结果。</p><ul><li>v[i] [0] = v[0] [j] = 0</li><li>当w[i] &gt; j 时：v[i] [j] = v[i - 1] [j] </li><li>当 j &gt;= w[i]时：v[i] [j]  = max {v[i - 1] [j] , v[i - 1] [j - w[i]] + v[i]}</li></ul><h3 id="思路推导图"><a href="#思路推导图" class="headerlink" title="思路推导图"></a>思路推导图</h3><p>使用填表法</p><p>解决类似的问题可以分解成一个个的小问题进行解决，假设存在背包容量大小为1,2,3,4 的各种容量的背包（分配容量的规则为最小重量的整数倍）</p><ul><li>假设现在只有吉他（G），这时候不管背包容量有多大，只能放一个吉他 1500（G）</li><li>假设现在有 吉他 和 音箱S，那么在 0 - 3 磅的时候，只能放吉他，当为4磅的时候，能放入音箱</li><li></li></ul><table><thead><tr><th>物品</th><th>0磅</th><th>1磅</th><th>2磅</th><th>3磅</th><th>4磅</th></tr></thead><tbody><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>吉他G（重量1, 价值1500）</td><td>0</td><td>1500(G)</td><td>1500(G)</td><td>1500(G)</td><td>1500(G)</td></tr><tr><td>音箱S（重量4, 价值3000）</td><td>0</td><td>1500(G)</td><td>1500(G)</td><td>1500(G)</td><td>3000(S)</td></tr><tr><td>电脑L（重量3, 价值2000）</td><td>0</td><td>1500(G)</td><td>1500(G)</td><td>2000（L）</td><td>3500（G，L）</td></tr></tbody></table><p>这个时候，就得到了公式</p><ul><li>v[i] [0] = v[0] [j] = 0<ul><li>表示第一行和第一列为0</li></ul></li><li>当w[i] &gt; j 时：v[i] [j] = v[i - 1] [j] <ul><li>当我们装入新增的商品，它的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略</li></ul></li><li>当 j &gt;= w[i]时：v[i] [j]  = max {v[i - 1] [j] ,  v[i] + v[i - 1] [j - w[i]] }<ul><li>当准备新增的商品的容量小于等于当前背包的容量，装入的方式，应该是求一个最大值</li><li>v[i-1] [j]：表示上一个单元格的装入的最大值</li><li>v[i]：表示当前商品的价值</li><li>v[i -1] [j - w[i]]：装入i-1商品，到剩余空间的最大值</li></ul></li></ul><p>验证公式1</p><ul><li>v[i] [j]  = 1500</li><li>i = 1, j = 1</li><li>w[i]  = w[1] = 1</li><li>j &gt;= w[i] ，满足第三个条件</li><li>v[i] [j] = max { v[0] [1], val[1]+ v[0] [0] } = max { 0 , 1500 + 0}  = 1500</li></ul><p>验证公式2</p><ul><li>v[3] [4] = 3500</li><li>i = 3, j = 4</li><li>w[i] = w[3] = 3 </li><li>j = 4 &gt;= w[i] ， max { v[2] [4],  v[3] + v[2] [1] } = max {3000 , 2000 + 1500 }  = 3500</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态规划</span></span><br><span class="line"><span class="comment"> * 解决 0-1背包问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author: ylyang</span></span><br><span class="line"><span class="comment"> * @time: 2019-08-15-07:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProgramming</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 物品的重量</span></span><br><span class="line">        <span class="keyword">int</span> w [] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 物品的价值</span></span><br><span class="line">        <span class="keyword">int</span> val [] = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 背包的容量</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 物品的个数</span></span><br><span class="line">        <span class="keyword">int</span> n = val.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建二维数组  v[i][j] 表示在前i个物品中，可以装入容量为j的背包中的商品最大值</span></span><br><span class="line">        <span class="keyword">int</span> [][] v = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了记录放入商品的情况，我们定义一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span> [][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一行  和 第一列，这里在本程序中可以不去处理，因为数组默认就是0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;v.length; i++) &#123;</span><br><span class="line">            v[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;v[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            v[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据前面的公式，来进行动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;v.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 不处理第一行 和 第一列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;v[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">// 公式</span></span><br><span class="line">                <span class="keyword">if</span>(w[i<span class="number">-1</span>] &gt; j) &#123;</span><br><span class="line">                    v[i][j] = v[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 因为我们的i从1开始的，因此公式需要调整成 i -&gt; i-1</span></span><br><span class="line"><span class="comment">//                     v[i][j] = Math.max(v[i-1][j], val[i-1] + v[i-1][j - w[i -1]]);</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 为了记录商品存放的背包的情况，我们不能直接的使用上面的公式，需要使用if else来体现公式</span></span><br><span class="line">                    <span class="keyword">if</span>(v[i<span class="number">-1</span>][j] &lt; (val[i<span class="number">-1</span>] + v[i<span class="number">-1</span>][j - w[i <span class="number">-1</span>]])) &#123;</span><br><span class="line">                        v[i][j] = (val[i<span class="number">-1</span>] + v[i<span class="number">-1</span>][j - w[i <span class="number">-1</span>]]);</span><br><span class="line">                        <span class="comment">// 把当前的情况记录到path</span></span><br><span class="line">                        path[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        v[i][j] = v[i<span class="number">-1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出一下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; v.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;v[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.<span class="built_in">print</span>(v[i][j] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最后我们是放入的那些商品</span></span><br><span class="line">        <span class="comment">// 这样遍历，会把所有放入情况都用到，其实我们只需要最后的放入情况</span></span><br><span class="line"><span class="comment">//        for(int i = 0; i&lt; path.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            for(int j = 0; j&lt;path[0].length; j++) &#123;</span></span><br><span class="line"><span class="comment">//                if(path[i][j] == 1) &#123;</span></span><br><span class="line"><span class="comment">//                    System.out.print(i + " ");</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求出最后的一个点</span></span><br><span class="line">        <span class="keyword">int</span> i = path.length <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = path[<span class="number">0</span>].length <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 从path的最后开始查找</span></span><br><span class="line">        <span class="keyword">while</span> (i&gt; <span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.<span class="built_in">print</span>(i + <span class="string">" "</span>);</span><br><span class="line">                j -= w[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到一个 i需要减1</span></span><br><span class="line">            i --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 </span><br><span class="line">0 1500 1500 1500 1500 </span><br><span class="line">0 1500 1500 1500 3000 </span><br><span class="line">0 1500 1500 2000 3500 </span><br><span class="line">3 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小的K个数</title>
      <link href="/2019/07/11/%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/07/11/%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>最大堆和最小堆是二叉堆的两种形式。</p><p>最大堆：根结点的键值是所有堆结点键值中最大者，且每个结点的值都比其孩子的值大。</p><p>最小堆：根结点的键值是所有堆结点键值中最小者，且每个结点的值都比其孩子的值小</p><p><img data-src="image-20200531214512859.png" alt="img"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我们首先需要用一个长度为K的数组，来记录最小值，并且这个数组是排序的，首先需要初始化K数组的值，我们设置为最大，然后遍历每次查找的时候，需要从里面的数组进行比较，然后如果大小超过了K，那么把最大的数给剔除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        array = []</span><br><span class="line">        <span class="keyword">if</span> k &gt; len(tinput):</span><br><span class="line">            <span class="keyword">return</span> array</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            array.append(<span class="number">1000000</span>)</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> tinput:</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> range(len(array)):</span><br><span class="line">                <span class="keyword">if</span> key &lt; array[index]:</span><br><span class="line">                    array.insert(index, key)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> len(array) &gt; k:</span><br><span class="line">                <span class="keyword">del</span> array[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树与双向链表</title>
      <link href="/2019/07/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/07/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Convert(self, pRootOfTree):</span><br><span class="line">        # write code here</span><br><span class="line">        if pRootOfTree &#x3D;&#x3D; None:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        def find_right(node):</span><br><span class="line">            while node.right:</span><br><span class="line">                node &#x3D; node.right</span><br><span class="line">            return node</span><br><span class="line"></span><br><span class="line">        leftNode &#x3D; self.Convert(pRootOfTree.left)</span><br><span class="line">        rightNode &#x3D; self.Convert(pRootOfTree.right)</span><br><span class="line"></span><br><span class="line">        retNode &#x3D; leftNode</span><br><span class="line"></span><br><span class="line">        if leftNode:</span><br><span class="line">            leftNode &#x3D; find_right(leftNode)</span><br><span class="line">        else:</span><br><span class="line">            retNode &#x3D; pRootOfTree</span><br><span class="line"></span><br><span class="line">        pRootOfTree.left &#x3D; leftNode</span><br><span class="line">        pRootOfTree.right &#x3D; rightNode</span><br><span class="line"></span><br><span class="line">        if leftNode !&#x3D; None:</span><br><span class="line">            leftNode.right &#x3D; pRootOfTree</span><br><span class="line">        if rightNode !&#x3D; None:</span><br><span class="line">            rightNode.left &#x3D; pRootOfTree</span><br><span class="line"></span><br><span class="line">        return retNode</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树中和为某一值的路径</title>
      <link href="/2019/07/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/07/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>假设现在我们需要找出和为23的路径，那么就需要采用广度优先搜索进行遍历，层层进行叠加，最后找到叶子节点</p><p><img data-src="image-20200531205621259.png" alt="image"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="comment"># 用于存放路径</span></span><br><span class="line">        supportArrayList = [[root.val]]</span><br><span class="line">        <span class="comment"># 存放中间节点，把root节点放入</span></span><br><span class="line">        support = [root]</span><br><span class="line">        <span class="comment"># 广度优先遍历</span></span><br><span class="line">        <span class="keyword">while</span> support:</span><br><span class="line">            temp = support[<span class="number">0</span>]</span><br><span class="line">            tempArrayList = supportArrayList[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># 判断是否是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> temp.left == <span class="literal">None</span> <span class="keyword">and</span> temp.right == <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 判断路径中的值，是否等于expectNum，往该条数组中插入</span></span><br><span class="line">                <span class="keyword">if</span> sum(tempArrayList) == expectNumber:</span><br><span class="line">                    ret.insert(<span class="number">0</span>, tempArrayList)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> temp.left:</span><br><span class="line">                support.append(temp.left)</span><br><span class="line">                newTempArrayList = copy.copy(tempArrayList)</span><br><span class="line">                newTempArrayList.append(temp.left.val)</span><br><span class="line">                supportArrayList.append(newTempArrayList)</span><br><span class="line">            <span class="keyword">if</span> temp.right:</span><br><span class="line">                support.append(temp.right)</span><br><span class="line">                newTempArrayList = copy.copy(tempArrayList)</span><br><span class="line">                newTempArrayList.append(temp.right.val)</span><br><span class="line">                supportArrayList.append(newTempArrayList)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">del</span> support[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">del</span> tempArrayList[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树的后序遍历序列</title>
      <link href="/2019/07/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
      <url>/2019/07/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><a id="more"></a><h2 id="什么是二叉搜索树"><a href="#什么是二叉搜索树" class="headerlink" title="什么是二叉搜索树"></a>什么是二叉搜索树</h2><p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的<a href="https://baike.baidu.com/item/二叉树/1602879" target="_blank" rel="noopener">二叉树</a>： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为<a href="https://baike.baidu.com/item/二叉排序树/10905079" target="_blank" rel="noopener">二叉排序树</a>。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作</p><p><img data-src="image-20200531202449227.png" alt="image"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>给定一个二叉树，后序遍历的结果如下所示</p><p><img data-src="image-20200531203027879.png" alt="image"></p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def VerifySquenceOfBST(self, sequence):</span><br><span class="line">        if sequence &#x3D;&#x3D; []:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        # 找ROOT节点，也就是最后一个</span><br><span class="line">        root &#x3D; sequence[-1]</span><br><span class="line">        # 删除队列中的末尾节点</span><br><span class="line">        del sequence[-1]</span><br><span class="line">        # 寻找出划分的节点</span><br><span class="line">        index &#x3D; None</span><br><span class="line">        for i in range(len(sequence)):</span><br><span class="line">            # 只寻找一次，就不进入了</span><br><span class="line">            if index &#x3D;&#x3D; None and sequence[i] &gt; root:</span><br><span class="line">                index &#x3D; i</span><br><span class="line">            # 当我们找到一个大的数，然后往后又找到一个更小的数，那么就无法组成二叉搜索树</span><br><span class="line">            if index !&#x3D; None and sequence[i] &lt; root:</span><br><span class="line">                return False</span><br><span class="line"></span><br><span class="line">        if sequence[:index] &#x3D;&#x3D; []:</span><br><span class="line">            left &#x3D; True</span><br><span class="line">        else:</span><br><span class="line">            # 寻找左子树和右子树</span><br><span class="line">            left &#x3D; self.VerifySquenceOfBST(sequence[:index])</span><br><span class="line">        if sequence[index:] &#x3D;&#x3D; []:</span><br><span class="line">            right &#x3D; True</span><br><span class="line">        else:</span><br><span class="line">            right &#x3D; self.VerifySquenceOfBST(sequence[index:])</span><br><span class="line">        # 返回结果</span><br><span class="line">        return left and right</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从上往下打印二叉树</title>
      <link href="/2019/07/02/%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/07/02/%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line">class Solution:</span><br><span class="line">    # 返回从上到下每个节点值列表，例：[1,2,3]</span><br><span class="line">    def PrintFromTopToBottom(self, root):</span><br><span class="line">        if root &#x3D;&#x3D; None:</span><br><span class="line">            return []</span><br><span class="line">        # 将输入的节点存入support中</span><br><span class="line">        support &#x3D; [root]</span><br><span class="line">        ret &#x3D; []</span><br><span class="line">        while support:</span><br><span class="line">            tempNode &#x3D; support[0]</span><br><span class="line">            ret.append(tempNode.val)</span><br><span class="line">            if tempNode.left:</span><br><span class="line">                support.append(tempNode.left)</span><br><span class="line">            if tempNode.right:</span><br><span class="line">                support.append(tempNode.right)</span><br><span class="line">            # 删除已经输出的节点</span><br><span class="line">            del support[0]</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的镜像</title>
      <link href="/2019/07/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
      <url>/2019/07/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><a id="more"></a><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">        8</span><br><span class="line">       &#x2F;  \</span><br><span class="line">      6   10</span><br><span class="line">     &#x2F; \  &#x2F; \</span><br><span class="line">    5  7 9 11</span><br><span class="line">    镜像二叉树</span><br><span class="line">        8</span><br><span class="line">       &#x2F;  \</span><br><span class="line">      10   6</span><br><span class="line">     &#x2F; \  &#x2F; \</span><br><span class="line">    11 9 7  5</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们就对每个节点的左右子树进行交换即可，也就是需要使用一个temp变量来存储交换的节点。然后在重复它的左子树和右子树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 处理左子树</span></span><br><span class="line">        temp = root.left</span><br><span class="line">        root.left = root.right</span><br><span class="line">        root.right = temp</span><br><span class="line">        self.Mirror(root.left)</span><br><span class="line">        self.Mirror(root.right)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的子结构</title>
      <link href="/2019/06/28/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
      <url>/2019/06/28/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先我们需要考虑的是，什么才是子结构，如下图所示，rootB就是rootA的子结构</p><p><img data-src="image-20200529153030088.png" alt="image"></p><p>遍历过程如下，首先先遍历rootB的根节点，然后rootA的根节点比较，如果一样，就继续遍历rootB的左右子树，不一样，我们就换个其他节点进行遍历，但我们遍历到rootA的2节点时候，发现和rootB的根节点一样，那么这个时候，就在遍历RootB的左子树，发现也和rootA的一样，在遍历右子树，也相等，这个时候，在rootB全部遍历完成后，我们就能够确定，rootB为rootA的子结构了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pRoot1 == <span class="literal">None</span> <span class="keyword">or</span> pRoot2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">hasEqual</span><span class="params">(pRoot1, pRoot2)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> pRoot2 == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> pRoot1 == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> pRoot1.val == pRoot2.val:</span><br><span class="line">                <span class="keyword">if</span> pRoot2.left == <span class="literal">None</span>:</span><br><span class="line">                    leftEqual = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    leftEqual = hasEqual(pRoot1.left, pRoot2.left)</span><br><span class="line">                <span class="keyword">if</span> pRoot2.right == <span class="literal">None</span>:</span><br><span class="line">                    rightEqual = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    rightEqual = hasEqual(pRoot1.right, pRoot2.right)</span><br><span class="line">                <span class="comment"># 左边相等和右边相等的时候，才返回</span></span><br><span class="line">                <span class="keyword">return</span> leftEqual <span class="keyword">and</span> rightEqual</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        ret = hasEqual(pRoot1, pRoot2)</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        ret = self.HasSubtree(pRoot1.left, pRoot2)</span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        ret = self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">        <span class="keyword">return</span>  ret</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重建二叉树</title>
      <link href="/2019/06/26/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/06/26/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><a id="more"></a><h2 id="重建过程"><a href="#重建过程" class="headerlink" title="重建过程"></a>重建过程</h2><p>先找到根节点，也就是先序遍历的第一个节点，即1为根节点</p><p>然后从中序遍历中寻找，在1左边的属于左子树（4,7,2），右边的属于右子树：（5,3,8,6）</p><p>然后在从先序遍历的第二个节点中寻找出2，作为根节点的左孩子，我们在寻找2节点的左孩子和右孩子，发现只有（4,7）为左节点，没有右节点，然后我们再从先序遍历中寻找出下一个节点，即为4，然后找出4节点的右孩子，即为7。到这里位置，左子树已经构建成功。</p><p>构建右子树时，我们需要从先序遍历中，再次输出一个节点3，作为根节点的右子树，然后在从刚刚分类好的中序遍历中，寻找到子树3的左孩子和右孩子，左孩子为（5），右孩子为（8,6），我们继续出列先序遍历，得到5，即3节点的左孩子，然后在出列得到6，也就是3的右孩子，然后在中序遍历中寻找到6的左孩子和右孩子，最后发现只剩下8在，6的左边，因此右孩子为8</p><p><img data-src="image-20200529144737938.png" alt="image"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># 取出pre的值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(pre) != len(tin):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = pre[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 新建立节点</span></span><br><span class="line">        rootNode = TreeNode(root)</span><br><span class="line">        <span class="comment"># 找出这个节点，在中序遍历对应的角标</span></span><br><span class="line">        pos = tin.index(root)</span><br><span class="line">        <span class="comment"># 取出中序遍历 左子树</span></span><br><span class="line">        tinLeft = tin[:pos]</span><br><span class="line">        <span class="comment"># 取出中序遍历 右子树</span></span><br><span class="line">        tinRight = tin[pos+<span class="number">1</span>:]</span><br><span class="line">        <span class="comment"># 取出先序遍历的 左子树</span></span><br><span class="line">        preLeft = pre[<span class="number">1</span>:pos+<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 取出先序遍历的 右子树</span></span><br><span class="line">        preRight = pre[pos+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        leftNode = self.reConstructBinaryTree(preLeft, tinLeft)</span><br><span class="line">        rightNode = self.reConstructBinaryTree(preRight, tinRight)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> leftNode:</span><br><span class="line">            rootNode.left = leftNode</span><br><span class="line">        <span class="keyword">if</span> rightNode:</span><br><span class="line">            rootNode.right = rightNode</span><br><span class="line">        <span class="keyword">return</span> rootNode</span><br></pre></td></tr></table></figure><p>代码的实现，使用了递归的方式，也就是采用了分治法，将要解决的问题一分为二，这里指的是先序遍历和中序遍历。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的遍历</title>
      <link href="/2019/06/25/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2019/06/25/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><h2 id="什么叫做树？"><a href="#什么叫做树？" class="headerlink" title="什么叫做树？"></a>什么叫做树？</h2><p><strong>树状图</strong>是一种<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450" target="_blank" rel="noopener">数据结构</a>，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的<a href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88" target="_blank" rel="noopener">集合</a>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><a id="more"></a><p>每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树；</p><p>叶节点没有子节点，根节点没有父节点。</p><h2 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h2><p>每个节点最多含有两个子树的树称为二叉树。下图就是一个二叉树。</p><p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p><p>一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2k-1个节点，至多有2k-1个节点</p><h2 id="构建一个二叉树"><a href="#构建一个二叉树" class="headerlink" title="构建一个二叉树"></a>构建一个二叉树</h2><p>如图所示，我们如果要构建下面的二叉树，应该是怎么定义的</p><p><img data-src="image-20200528223617759.png" alt="image"></p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode(object):</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    t1 &#x3D; TreeNode(1)</span><br><span class="line">    t2 &#x3D; TreeNode(2)</span><br><span class="line">    t3 &#x3D; TreeNode(3)</span><br><span class="line">    t4 &#x3D; TreeNode(4)</span><br><span class="line">    t5 &#x3D; TreeNode(5)</span><br><span class="line">    t6 &#x3D; TreeNode(6)</span><br><span class="line">    t7 &#x3D; TreeNode(7)</span><br><span class="line">    t8 &#x3D; TreeNode(8)</span><br><span class="line">    t1.left &#x3D; t2</span><br><span class="line">    t1.right &#x3D; t3</span><br><span class="line">    t2.left &#x3D; t4</span><br><span class="line">    t2.right &#x3D; t5</span><br><span class="line">    t3.left &#x3D; t6</span><br><span class="line">    t3.right &#x3D; t7</span><br><span class="line">    t6.right &#x3D; t8</span><br></pre></td></tr></table></figure><h2 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a>二叉树的遍历：</h2><p>遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，<a href="https://baike.baidu.com/item/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" target="_blank" rel="noopener">树的遍历</a>实质上是将二叉树的各个结点转换成为一个线性序列来表示。</p><p>设L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先根次序遍历），LDR（称为中根次序遍历），LRD （称为后根次序遍历）。</p><blockquote><p>针对上图，我们看看先序、中序、后序遍历</p><p>先序遍历：1 2 4 5 3 6 8 7</p><p>中序遍历：4 2 5 1 6 8 3 7</p><p>后序遍历：4 5 2 8 6 7 3 1 </p></blockquote><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preOrderRecusive</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    print(root.val, end=<span class="string">" "</span>)</span><br><span class="line">    preOrderRecusive(root.left)</span><br><span class="line">    preOrderRecusive(root.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">midOrderRecusive</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    midOrderRecusive(root.left)</span><br><span class="line">    print(root.val, end=<span class="string">" "</span>)</span><br><span class="line">    midOrderRecusive(root.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">latOrderRecusive</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    latOrderRecusive(root.left)</span><br><span class="line">    latOrderRecusive(root.right)</span><br><span class="line">    print(root.val, end=<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = TreeNode(<span class="number">1</span>)</span><br><span class="line">    t2 = TreeNode(<span class="number">2</span>)</span><br><span class="line">    t3 = TreeNode(<span class="number">3</span>)</span><br><span class="line">    t4 = TreeNode(<span class="number">4</span>)</span><br><span class="line">    t5 = TreeNode(<span class="number">5</span>)</span><br><span class="line">    t6 = TreeNode(<span class="number">6</span>)</span><br><span class="line">    t7 = TreeNode(<span class="number">7</span>)</span><br><span class="line">    t8 = TreeNode(<span class="number">8</span>)</span><br><span class="line">    t1.left = t2</span><br><span class="line">    t1.right = t3</span><br><span class="line">    t2.left = t4</span><br><span class="line">    t2.right = t5</span><br><span class="line">    t3.left = t6</span><br><span class="line">    t3.right = t7</span><br><span class="line">    t6.right = t8</span><br><span class="line"></span><br><span class="line">    preOrderRecusive(t1)</span><br><span class="line">    print()</span><br><span class="line">    midOrderRecusive(t1)</span><br><span class="line">    print()</span><br><span class="line">    latOrderRecusive(t1)</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 5 3 6 8 7 </span><br><span class="line">4 2 5 1 8 6 3 7 </span><br><span class="line">4 5 2 8 6 7 3 1</span><br></pre></td></tr></table></figure><h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><p>递归和循环是可以互相转换的，下面是非递归先序遍历，使用一个stack用于存储经过的节点，并且输出，但没有指针指向为空的时候，我们需要将stack中保存的节点，进行pop出栈，并把它的右节点，重新赋值给tempNode指针，直到所有节点都遍历完成为止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 非递归先序遍历</span><br><span class="line">def preOrder(root):</span><br><span class="line">    if root &#x3D;&#x3D; None:</span><br><span class="line">        return None</span><br><span class="line">    stack &#x3D; []</span><br><span class="line">    tempNode &#x3D; root</span><br><span class="line">    while tempNode !&#x3D; None or stack:</span><br><span class="line">        print(tempNode.val, end&#x3D;&quot; &quot;)</span><br><span class="line">        stack.append(tempNode)</span><br><span class="line">        tempNode &#x3D; tempNode.left</span><br><span class="line">        while tempNode &#x3D;&#x3D; None and stack !&#x3D; None:</span><br><span class="line">            tempNode &#x3D; stack.pop()</span><br><span class="line">            tempNode &#x3D; tempNode.right</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 非递归中序遍历</span><br><span class="line">def midOrder(root):</span><br><span class="line">    if root &#x3D;&#x3D; None:</span><br><span class="line">        return None</span><br><span class="line">    stack &#x3D; []</span><br><span class="line">    tempNode &#x3D; root</span><br><span class="line">    while tempNode !&#x3D; None or stack:</span><br><span class="line">        stack.append(tempNode)</span><br><span class="line">        tempNode &#x3D; tempNode.left</span><br><span class="line">        while tempNode &#x3D;&#x3D; None and stack !&#x3D; []:</span><br><span class="line">            tempNode &#x3D; stack.pop()</span><br><span class="line">            print(tempNode.val, end&#x3D;&quot; &quot;)</span><br><span class="line">            tempNode &#x3D; tempNode.right</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 非递归后序遍历</span><br><span class="line">def latOrder(root):</span><br><span class="line">    if root &#x3D;&#x3D; None:</span><br><span class="line">        return None</span><br><span class="line">    stack &#x3D; []</span><br><span class="line">    tempNode &#x3D; root</span><br><span class="line">    while tempNode !&#x3D; None or stack:</span><br><span class="line">        stack.append(tempNode)</span><br><span class="line">        tempNode &#x3D; tempNode.left</span><br><span class="line">        while tempNode &#x3D;&#x3D; None and stack !&#x3D; []:</span><br><span class="line">            # 后序遍历，pop的方式有变化，不能在右子树不为空的时候pop</span><br><span class="line">            node &#x3D; stack[-1] # 因此这里不出列</span><br><span class="line">            tempNode &#x3D; node.right</span><br><span class="line">            # 当右节点没有的时候，才能够pop</span><br><span class="line">            if node.right &#x3D;&#x3D; None:</span><br><span class="line">                print(node.val, end&#x3D;&quot; &quot;)</span><br><span class="line">                node &#x3D; stack.pop()</span><br><span class="line">                # 判断pop的节点，是否是上一个节点</span><br><span class="line">                while stack and node &#x3D;&#x3D; stack[-1].right:</span><br><span class="line">                    node &#x3D; stack.pop()</span><br><span class="line">                    print(node.val, end&#x3D;&quot; &quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中只出现一次的数字</title>
      <link href="/2019/06/21/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2019/06/21/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里我们需要做的就是，首先使用一个字典来进行存储，如果这个字典中原来有值了，那么我们就把这个字典删除，否则，按key为array[i]，然后值设置成1，当我们遍历完成后，就会让剩下的数留下来，那么我们就通过遍历将他们查询出来返回即可。时间复杂度为 O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</span><br><span class="line">class Solution:</span><br><span class="line">    # 返回[a,b] 其中ab是出现一次的两个数字</span><br><span class="line">    def FindNumsAppearOnce(self, array):</span><br><span class="line">        dict &#x3D; &#123;&#125;</span><br><span class="line">        for i in range(len(array)):</span><br><span class="line">            if dict.get(array[i]) !&#x3D; None:</span><br><span class="line">                del dict[array[i]]</span><br><span class="line">            else:</span><br><span class="line">                dict[array[i]] &#x3D; 1</span><br><span class="line">        if len(dict) &#x3D;&#x3D; 0:</span><br><span class="line">            return None</span><br><span class="line">        list &#x3D; []</span><br><span class="line">        for key in dict:</span><br><span class="line">            list.append(key)</span><br><span class="line">        return list[0], list[1]</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    array &#x3D; [2,4,3,6,3,2,5,5]</span><br><span class="line">    print(Solution().FindNumsAppearOnce(array))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数中1出现的个数</title>
      <link href="/2019/06/19/%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/06/19/%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="整数中1出现的个数"><a href="#整数中1出现的个数" class="headerlink" title="整数中1出现的个数"></a>整数中1出现的个数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求出1<del>13的整数中1出现的次数,并算出100</del>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img data-src="%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.png" alt="img"></p><p>如上图所示，如果那个数 是我们 的 1-n 中 n 这个数，那么这个数就是一个特别大的数，不能遍历计算每个数字的1 的个数， 那就只能去寻找1在数字中出现的规律来。</p><p>那么我们可以把 这个数字中 ，分段来 看 1 在这个数字片段中可能出现的情况都有多少。</p><p>*<em>若 以上 栗子 中的 十万位上的 0  那一位  为 数字1 的话，有多少种 可能？ *</em></p><p>​    首先  直接 为1 的话，这个数就会大于 我们的n 这个数，所以 它需要 向前一位借 一位，来计算 可能出现的 情况 有多少种，那么就是 一共 有</p><p><code>0-3458</code> 个数 那么就一共是 3459 中可能性。</p><p>​    <strong>那么十万位 后面 出现1 的情况有多少种 可能性 ？</strong></p><p>​    0 后面一共有5 位，每 一 位 的数字 可能的情况 是 0-9 共 十 个数字，也就是说  后面 为的可能性是 <code>10^5</code>. </p><p>那么就是说对于 十万位数字是0 来说，一共有3459*（10^5 )种 可能。</p><p>​    <strong>接下来我们在考虑一个 数字 那就是 万 位 上的数字，8，如果8 这一位为1 的话，有多少种可能性？</strong></p><p>如果8 为1 的话，那么就是我们前面的数字 有 1-34590，共<code>34591</code>种情况，后面 是一共 4 位，那么就有        <code>10^4</code>种情况。</p><p>那么就是说对于 万位数字是0 来说，一共有34591*(10^4) 种 可能。</p><p>​    <strong>我们再考虑另一个特殊的，那就是我们的百位上的 1 那一位，除了现在的n 的百位上是1，那么其他 这个一位为1 的情况，一共有多少种可能？</strong></p><p>如果说1 这个数字不变的话，那么1前面 的位数 可能为1 的可能性就是 0-3459082，后面的两位的 可能性为 0-90，不能大于90，如果大于的话，需要 跟 百位来借 一位了，我们先考虑这种不借位的可能性，那就是</p><p>3459083*91，如果借位的话，那么前面就是 0-3459081，后面就10^2-91 为9 种 情况，那么最后 一共有</p><p>3459083 x 91+3459082 x 9，最后推导为 3459082 x 91 + 91 + 3459082 x 9，最后为 3459082 *10^2 +91种 可能性。</p><p>分析了三种特殊的情况，那么我们可以用递归的方式来找，只不过因为递归的话 时间复杂度比较高，那么我们可以写一个 与递归等价的 while 循环来实现，递归和 while 循环是可以互相转换的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span>        </span><br><span class="line">        <span class="comment">#循环的出口是 highValue = 0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#我们从最低位开始一个位一个位的来寻找 1 的可能出现的 情况次数。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 一开始 精准度为1.高位低位中位 先赋值为1.</span></span><br><span class="line">        preceise = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 高位数</span></span><br><span class="line">        highValue = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 低位数</span></span><br><span class="line">        lowValue = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 中位数</span></span><br><span class="line">        midValue =<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#计数 后面的位数。</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment">#计数 1 的次数和</span></span><br><span class="line">        sumNum = <span class="number">0</span></span><br><span class="line">        <span class="comment">#循环的 出口是我们找不到最高位了，那么这个时候就说明，我们遍历到了 这个数字的最高位。</span></span><br><span class="line">        <span class="keyword">while</span> highValue != <span class="number">0</span>:</span><br><span class="line">            <span class="comment">#高位 先将这个数 除以10 得到高位</span></span><br><span class="line">            highValue = n // (preceise * <span class="number">10</span>)</span><br><span class="line">            <span class="comment">#中位 先将这个数  与 10 取余。</span></span><br><span class="line">            midValue = (n // preceise)%<span class="number">10</span></span><br><span class="line">            <span class="comment">#低位 先将这个数 除以 1 那么低位就是个位后面的，没有就是0.</span></span><br><span class="line">            lowValue = n % preceise</span><br><span class="line">            <span class="comment">#每遍历一次 向右移一位，那么就是说 精准度要乘以10.</span></span><br><span class="line">            preceise *= <span class="number">10</span></span><br><span class="line"><span class="comment">#如果这个数是0 的话，</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> midValue == <span class="number">0</span>:</span><br><span class="line">                <span class="comment">#那么它就是高位的值，乘以 10^后面的位数 次方，但是这个时候 对于中位 来说 它是个位，后面没有位，所以是0，</span></span><br><span class="line">                num = (highValue)* pow(<span class="number">10</span>,count)</span><br><span class="line">            <span class="comment">#如果这个数 大于1 的话，</span></span><br><span class="line">            <span class="keyword">elif</span> midValue &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="comment">#那么它 就是 最高位加1 乘以 10^后面的位数 次方，</span></span><br><span class="line">                num = (highValue+<span class="number">1</span>)*pow(<span class="number">10</span>,count)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#否则的话 它就是等于1 的情况了，对于等于1 的1情况，又是比较特殊的情况，它需要 最高位 * 它10 的后面位数个数的次方，然后要加上我们低位 的数值再加 1， 原因在上面的分析中已经给出。</span></span><br><span class="line">                num = highValue*pow(<span class="number">10</span>,count)+(lowValue+<span class="number">1</span>)</span><br><span class="line">            <span class="comment">#最后 我们1 出现的 次数 就是这 三个 num 的和，。</span></span><br><span class="line">            sumNum += num</span><br><span class="line">            <span class="comment">#没循环一次，这个三个就往左移一次吗，那么这个时候它们 后面的位数也就会 多一位。</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"><span class="comment">#最后返回这个  次数和。</span></span><br><span class="line">        <span class="keyword">return</span> sumNum</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中出现次数超过一半的数字</title>
      <link href="/2019/06/18/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2019/06/18/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><a id="more"></a><h2 id="常规代码"><a href="#常规代码" class="headerlink" title="常规代码"></a>常规代码</h2><p>使用一个字典，来记录每个数出现的次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#  数组中出现次数超过一半的数字</span><br><span class="line"># 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def MoreThanHalfNum_Solution(self, numbers):</span><br><span class="line">        numsCount &#x3D; &#123;&#125;</span><br><span class="line">        numLen &#x3D; len(numbers)</span><br><span class="line">        for num in numbers:</span><br><span class="line">            if num in numsCount:</span><br><span class="line">                numsCount[num] +&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                numsCount[num] &#x3D; 1</span><br><span class="line">            # 找出超过一半的数</span><br><span class="line">            if numsCount[num] &gt; numLen &gt;&gt; 1:</span><br><span class="line">                return num</span><br><span class="line">        return 0</span><br></pre></td></tr></table></figure><blockquote><p>上述代码的空间和时间复杂度都是：O(n) </p><p>如果我们要做到，空间复杂度为：O(1)，时间复杂O(n)</p></blockquote><h2 id="升级代码"><a href="#升级代码" class="headerlink" title="升级代码"></a>升级代码</h2><blockquote><p> 思路：抵消掉  遇到不相同的数字就相互抵消掉，最终剩下的数字就可能是出现次数大于数组长度一半的数字。首先我们来遍历数字，遍历的时候需要记录上次出现的数字是什么，进而判断 下次出现的数字是否与现在这个数字相等，如果不相等的话，那么就把两个数字抵消掉，到最后没有抵消掉的数字，就可能是出现的次数大于数组长度的一半。</p><p> 我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，另一个是次数；当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1，如果下一个数字和我们之前保存的数字不同，则凑数减1.如果次数为0 ，我们需要保存下一次出现的次数，然后把次数设置为1.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def MoreThanHalfNum_Solution(self, numbers):</span><br><span class="line">        #定义变量 上次出现的数字为0</span><br><span class="line">        last &#x3D; 0</span><br><span class="line">        #上次出现的数字的数量为0 </span><br><span class="line">        lastCount &#x3D; 0</span><br><span class="line">#遍历数组中的数字</span><br><span class="line">        for num in numbers:</span><br><span class="line">            #如果说这个数字出现的次数为0了。</span><br><span class="line">            if lastCount &#x3D;&#x3D; 0:</span><br><span class="line">                #那么就把上次出现的数字，变为需要保存的那个数字。</span><br><span class="line">                last &#x3D; num</span><br><span class="line">                #并把次数设置为1 次，出现了这一次。</span><br><span class="line">                lastCount &#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                #否则就判断，这个数字是不是与上次出现的次数相同，如果相同的话，那么我们这个数字出现的次数就加1.</span><br><span class="line">                if num &#x3D;&#x3D; last:</span><br><span class="line">                    lastCount +&#x3D; 1</span><br><span class="line">                #如果不同的话，那么我们就让这两个数字抵消掉，那么这个数字出现的次数需要减 1；</span><br><span class="line">                else:</span><br><span class="line">                    lastCount -&#x3D; 1</span><br><span class="line">#如果最后遍历完事之后 这个记录数字出现次数的 值为0 的话，那么就说明我们的这个数组里面的数刚好可以两两抵消掉</span><br><span class="line">        if lastCount &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line">        #否则的话，就说明 数组里面 留下了没有抵消掉的数</span><br><span class="line">        else:</span><br><span class="line">            #这种情况是last可能是大于一半的数字</span><br><span class="line">            #这个时候把 记录数字次数的变量 计数 为0 </span><br><span class="line">            lastCount &#x3D; 0</span><br><span class="line">            #遍历数组中的数</span><br><span class="line">            for num in numbers:</span><br><span class="line">                #如果这个数与我们记录的数相等的话</span><br><span class="line">                if num &#x3D;&#x3D; last:</span><br><span class="line">                    #让这个计数加1</span><br><span class="line">                    lastCount +&#x3D; 1</span><br><span class="line">#最后判断一下，这个数的计数次数，是不是大于 我们数组长度的一半，如果是的话，就返回这个数，如果不是就返回0.</span><br><span class="line">            if lastCount &gt; (len(numbers)&gt;&gt; 1):</span><br><span class="line">                return last</span><br><span class="line">        return 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不用加减乘除做加法</title>
      <link href="/2019/06/11/%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
      <url>/2019/06/11/%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>对于数字运算，如果说四则运算不能用的话，那么我们只能用位运算来做了。</p><p>我们以 5 + 17 为例 结果为 22，那么 22 的计算结果，我们可以分为三步 来进行：</p><p>​    第一步： 只做各位相加不进位  也就是说 没一位上的数字 相应的来相加 但是不进位，那么  5 + 7 为 12 </p><p>​    个位数 5 和 7 相加 不进位 是2  十位是0 和1  相加 为 1 </p><p>​    第二步： 5 + 7 中有进位，进位值 是10 ;</p><p>​    第三步： 把前面两个结果 加起来： 12 + 10 = 22</p><p>以上为我们用十进制计算的 策略，那么 我们用于位运算中是不是也合适，我们来举个栗子：</p><p>还是以 5 + 17 为例，那么 5 的二进制是101 ； 17 的二进制是 10001；</p><p>第一步：各位相加 但不进位： 101 + 10001 = 10110  不进位的话  结果为 10100 （最后一位两个数都是1，相加的结果需要进位，但是这一位不进位，意味着结果仍然是0）</p><p>第二步： 记下进位，它只在最后一位相加时产生了一个进位。</p><p>第三步： 把前面两个结果相加，得到的结果是 10110.</p><p><strong>那么现在我们把前面的 二进制的加法用位运算来替代的话</strong></p><p>第一步的 求 和 运算就是 不考虑 进位的话，对每一位来相加，0 和0 以及  1 和1 的结果都是0  , 0+1 或者 1+0 的结果 都是1；那么我们会看出它与我们学过的异或运算相同，就是相同为假，不同为真，所以叫 异  或  XOR 。</p><p>第二步： 对0 加 0、1加0、0加1 而言，都不会产生进位，只有1+1 的时候，会产生一个进位。此时 我们可以想象成两个数 先做了一个 位 与 &amp; 运算，然后再向 左移 一位。只有两个数是1 的时候，位与 &amp; 得到的结果是 1，其余的都是0。</p><p>第三步：把前面两个步骤的结果再相加，然后在继续判断是否有进位，直到没有进位为止，那么此时的相加的过程，依然是重复前面的两步，直到不产生进位为止。</p><p><img data-src="%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E6%B3%95%E7%AE%97%E5%92%8C%E8%BF%90%E7%AE%97.png" alt="img"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="comment">#第一种代码：循环。简洁但是原理相同，那么我们以下面第二段代码为例；来解析。</span></span><br><span class="line">        <span class="comment"># while (num2):</span></span><br><span class="line">        <span class="comment">#     num1, num2 = (num1 ^ num2) &amp; 0xFFFFFFFF, ((num1 &amp; num2) &lt;&lt; 1) &amp; 0xFFFFFFFF</span></span><br><span class="line">        <span class="comment"># return num1 if num1 &lt;= 0x7FFFFFFF else ~(num1 ^ 0xFFFFFFFF)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#第二种代码：</span></span><br><span class="line">        <span class="comment">#首先两个数做 一个 异或 运算^ 那就是 在不进位的情况下，让两个相加 求和。</span></span><br><span class="line">        xorNum = num1 ^ num2</span><br><span class="line">        <span class="comment">#让两个数 做 位与 操作，然后再向 左 移 一位，得到它 向前进位的值。</span></span><br><span class="line">        andNum = (num1 &amp; num2) &lt;&lt; <span class="number">1</span></span><br><span class="line"><span class="comment">#判断，当 进位 的值不等于0 的时候，说明 一直有进位，也就是 过程没有结束。</span></span><br><span class="line">        <span class="keyword">while</span> andNum != <span class="number">0</span>:</span><br><span class="line">            <span class="comment">#那么我们就继续上面的操作。但是这次的 数值 改为上次的两个结果，</span></span><br><span class="line">            <span class="comment">#一个 是异或的结果，一个是 与 操作 &amp; 以后 左移一位的 结果。</span></span><br><span class="line">            tmp1 = xorNum ^ andNum</span><br><span class="line">            tmp2 = (xorNum &amp; andNum) &lt;&lt; <span class="number">1</span></span><br><span class="line"><span class="comment">#因为如果这个数为负数的话，那么负数 左移 一位与正数 不同，负数 是数值变小，正数 数值变大</span></span><br><span class="line">            <span class="comment">#如果是正数的话那么这一步就 不变，如果是负数的话，这一步就对负数来起作用。</span></span><br><span class="line">            <span class="comment">#对于python来说  负数的 二进制 可能会有无数个1，我们用这个方法让它变成一个可数的数字长度。</span></span><br><span class="line">            tmp1 = tmp1 &amp; <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">            xorNum = tmp1</span><br><span class="line">            andNum = tmp2</span><br><span class="line">         <span class="comment">#一个负整数（或原码）与其补数（或补码）相加，和为模。 0xffffffff </span></span><br><span class="line"><span class="comment"># ~(xorNum ^ 0xFFFFFFFF)  这个是 异或数  与  模 来 异或，最后 按位 取反 来求得 负数的补码。</span></span><br><span class="line">        <span class="keyword">return</span> xorNum <span class="keyword">if</span> xorNum &lt;= <span class="number">0x7ffffff</span> <span class="keyword">else</span> ~(xorNum ^ <span class="number">0xFFFFFFFF</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制中1的个数</title>
      <link href="/2019/06/08/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/06/08/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="二进制中的1的个数"><a href="#二进制中的1的个数" class="headerlink" title="二进制中的1的个数"></a>二进制中的1的个数</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示</p><a id="more"></a><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><ul><li><p>正数不变，负数就是它的正数的反码 + 1</p></li><li><p>一个负整数（或原码）与其补数（或补码）相加，和为模。</p></li><li><p>对一个整数的补码再求补码，等于该整数自身。</p></li><li><p>补码的正零与负零表示方法相同</p></li></ul><blockquote><p>-2 的 补码：  </p><p>-2 的二进制为   1 0 0 0 0 …….0 0 0 1 0 ,</p><p>-2 的 反码为：  1 1 1 1 1 …….1 1 1 0 1</p><p>-2 的 补码为：  1 1 1 1 1 …….1 1 1 1 0 </p><p>对于任意一个数n：</p><p>n = n &amp; 0xFFFFFFFF </p></blockquote><h4 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反 ~"></a>按位取反 ~</h4><p>~，用法只有一个那就是按位取反，需要注意的是：</p><ul><li>~ 的按位取反，包括符号位</li><li>正数各位取反变为负数，显示时转化为其补码</li><li>负数本身需要先转换为补码（符号位不变，各位取反再加 1），再对其补码进行各位去反</li></ul><h5 id="1-5"><a href="#1-5" class="headerlink" title="1. ~5"></a>1. ~5</h5><p>5 的二进制为 0101，</p><p>~5</p><ul><li>（1）各位取反，1010</li><li>（2）变为负数，转化为其补码形式（符号位保持不变），各位取反 1（1101），再加1（1110），也即 -6</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ~<span class="number">5</span></span><br><span class="line">&gt;&gt; <span class="number">-6</span></span><br></pre></td></tr></table></figure><h5 id="2-5"><a href="#2-5" class="headerlink" title="2. ~(-5)"></a>2. ~(-5)</h5><p>-5 因为是负数，存储时存储的是其补码：</p><ul><li>-5 的补码是：1011，</li><li>~(-5)将其各位取反（包括符号位），也即 0100（4）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ~(<span class="number">-5</span>)</span><br><span class="line">&gt;&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># 这一步是求补码的</span></span><br><span class="line">        n = n &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> str(bin(n)):</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">"1"</span>:</span><br><span class="line">                count +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf2</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># 这一步是求补码的</span></span><br><span class="line">        n = n &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            mask = <span class="number">1</span> &lt;&lt; i</span><br><span class="line">            <span class="keyword">if</span> n &amp; mask != <span class="number">0</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>           </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#补码：正数不变，负数是它的正数的反码 + 1</span></span><br><span class="line">        <span class="comment"># -2 补码： -2 的 1 0000.。。000010，</span></span><br><span class="line">        <span class="comment">#                 1 1111.。。111101 + 1</span></span><br><span class="line">        <span class="comment">#-2 的补码就是    1 1111.。。111110</span></span><br><span class="line">        <span class="comment">#把输入的正数n转化为二进制的数，并把0b 替换掉，计算1的数量，如果输入的值不是正数的话</span></span><br><span class="line">        <span class="comment">#一个负整数（或原码）与其补数（或补码）相加，和为模。2 的32 次方 是模。</span></span><br><span class="line">        <span class="comment">#那么就是 2 的32 次方 然后 + n  这是在取一个负数的补码  就相当于  n &amp; 0xffffffff</span></span><br><span class="line">        <span class="comment">#然后计算 这个数里面 1 的 数量</span></span><br><span class="line">        <span class="keyword">return</span> bin(n).replace(<span class="string">"0b"</span>, <span class="string">""</span>).count(<span class="string">"1"</span>) <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> bin(<span class="number">2</span> ** <span class="number">32</span> + n).replace(<span class="string">"0b"</span>, <span class="string">""</span>).count(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">#第三种：</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 1 出现的次数为0 次</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment">#判断 这个数 n 是不是负数，如果是负数的话 求其补码：</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n = n &amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="comment">#如果这个数不是0 的话，那么它在二进制的表示中至少有一位是1，所以一开始我们赋值 count +=1.</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="comment">#把一个整数先减去1，再和原整数做与运算，会把该整数最右边的1 变从成0，那么一个二进制中有多少个1，就可以进行多少次这样的操作。</span></span><br><span class="line">            n = (n - <span class="number">1</span>) &amp; n</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    例如：一个二进制1100， 它的第二位 是从最右边数起的一个1，减去一个1后，第二位变成0，它后面的两位0变成1，而前面的1保持不变，因此结果是1011.</span></span><br><span class="line"><span class="string">    那把 这个整数 和它 减去1 的结果  做一个按位 与运算，相当于 把 最右边的 1 变成 0,。</span></span><br><span class="line"><span class="string">    1011 和 1100 做 按位与 运算  1100 &amp; 1011  结果为  1000，那么刚好是我们 要得到 将最右边的1 变成0 的结果   1000.</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表中环的入口结点</title>
      <link href="/2019/05/18/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/18/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><img data-src="image-20200426105846170.png" alt="image"></p><p><strong>如何确定是否有环</strong></p><ul><li>把所有出现的点，都放到list中</li><li>如果下次的节点，在list中出现，说明出现了环</li><li>但是这种时间复杂度比较高</li></ul><p><strong>第二种方式</strong></p><p>定义：两个 指针，一个是慢指针，一个是快指针</p><p>假设 slow 走了 L 步，那么 fast 就走了 2L 步。</p><p> 我们 链表的头部 到 链表的环的入口结点处 的距离是 S</p><p>那么 从入口结点 到 我们 快慢指针相遇的地点 的距离 为 d。 </p><p>链表的环中，慢指针走过的距离是d，那么没走过的距离是M。</p><p>我们不确定的是快指针在链表的环里走过了多少圈来与慢指针相遇，因此 将这个参数设置为n。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">那么 L &#x3D; s + d</span><br><span class="line">2L &#x3D; 2(s+d) &#x3D; n*(m + d) + d + s</span><br><span class="line">由上面公式 推导出 n(m+d) &#x3D; s + d</span><br><span class="line">得到：s &#x3D; n(m+d) -d；</span><br><span class="line">s &#x3D; nm + (n-1)(d)</span><br><span class="line">s &#x3D; m + (n-1)(m+d)</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line">class Solution:</span><br><span class="line">    def EntryNodeOfLoop(self, pHead):</span><br><span class="line">        # write code here</span><br><span class="line">        #首先需要定义两个指针，其中一个快，跳两步，一个慢跳一步。</span><br><span class="line">        #循环跳</span><br><span class="line">        #要么是快的指针 为 none（没有环），要么是快慢指针相等（有环）。</span><br><span class="line">        if pHead &#x3D;&#x3D; None:</span><br><span class="line">            return None </span><br><span class="line">#定义两个指针，一个快的一个慢的。</span><br><span class="line">        fastPointer &#x3D; pHead</span><br><span class="line">        slowPointer &#x3D; pHead</span><br><span class="line">#当快指针存在时，而且快指针的结点指向的下一个也存在</span><br><span class="line">        while fastPointer and fastPointer.next :</span><br><span class="line">            #那么让快指针走两步</span><br><span class="line">            fastPointer &#x3D; fastPointer.next.next</span><br><span class="line">            #让慢指针走一步</span><br><span class="line">            slowPointer &#x3D; slowPointer.next</span><br><span class="line">            #如果慢指针等于快指针时，那么就说明这个链表中有环。有环的话那么就跳出，break</span><br><span class="line">            if fastPointer &#x3D;&#x3D; slowPointer:</span><br><span class="line">                break</span><br><span class="line">        #如果说两个指针没有相等的时候，快指针就已经走到链表的尽头了，说明这个链表没有环。那么就返回None。</span><br><span class="line">        if fastPointer &#x3D;&#x3D; None or fastPointer.next &#x3D;&#x3D; None:</span><br><span class="line">            return None</span><br><span class="line">        #如果slow 走了 l 的长度 那么 fast 就走了 2l 的长度</span><br><span class="line">        #假设 从开始到入口点的长度是 s；slow 在环里面走的长度是 d</span><br><span class="line"></span><br><span class="line">        # 那么  L &#x3D; s + d</span><br><span class="line">        #假设 环内 slow 没走的 长度 是 m; fast 走的长度是多少</span><br><span class="line">        # fast 走的长度 就是 ( m + d ) * n + d + s &#x3D; 2 L</span><br><span class="line">        #带入 ( m + d ) * n + d + s &#x3D; 2 （s + d ）</span><br><span class="line">        # s &#x3D; m + (n-1)(m+d)</span><br><span class="line">#有环的话，那么就让快指针从头开始走，这次一次走一步，</span><br><span class="line">        fastPointer &#x3D; pHead</span><br><span class="line">#此时慢指针还在环里走着，没有走到结点</span><br><span class="line">        while fastPointer !&#x3D; slowPointer:</span><br><span class="line">            fastPointer &#x3D; fastPointer.next</span><br><span class="line">            slowPointer &#x3D; slowPointer.next</span><br><span class="line">        #当两个指针相等时，就会相遇，这时返回一个指针的值，就为 入口结点处。</span><br><span class="line">        return fastPointer</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孩子们的游戏-圆圈中最后剩下的数</title>
      <link href="/2019/05/06/%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/"/>
      <url>/2019/05/06/%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="孩子们的游戏-圆圈中最后剩下的数"><a href="#孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="孩子们的游戏(圆圈中最后剩下的数)"></a>孩子们的游戏(圆圈中最后剩下的数)</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>有个游戏是这样的:首先，让小朋友们围成一个大圈。然后，随机指定一个数m，让编号为0的小朋友开始报数。</p><a id="more"></a><p>每次喊到m-1的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续0…m-1报数….这样下去….直到剩下最后一个小朋友，可以不用表演，并且拿到名贵的“名侦探柯南”藏版(名额有限哦!!^_^)。</p><p>请你试着想下，哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p><p>如果没有小朋友，请返回-1</p><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>首先第一种方法就是，循环遍历整个链表，每次找到后，把该节点删除，首先我们需要构建一个链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>然后在开始移动报数，我们移动 m-1步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 我们找到小朋友</span><br><span class="line">leftHead &#x3D; None</span><br><span class="line">for i in range(m-1):</span><br><span class="line">    leftHead &#x3D; head</span><br><span class="line">    head &#x3D; head.next</span><br></pre></td></tr></table></figure><p>最后在把 m -1的那个节点移除链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leftHead.next &#x3D; head.next</span><br><span class="line">head &#x3D; head.next</span><br></pre></td></tr></table></figure><p>最后的输出条件，就是链表中只剩下一个结点了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 表示循环链表中，只剩下一个小朋友了</span><br><span class="line">if head &#x3D;&#x3D; head.next:</span><br><span class="line">return head.val</span><br></pre></td></tr></table></figure><p>完整的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  孩子们的游戏(圆圈中最后剩下的数)</span></span><br><span class="line"><span class="comment"># (注：小朋友的编号是从0到n-1)</span></span><br><span class="line"><span class="comment"># 如果没有小朋友，请返回-1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建一个循环链表</span></span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        tempHead = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            node = ListNode(i)</span><br><span class="line">            head.next = node</span><br><span class="line">            head = head.next</span><br><span class="line"></span><br><span class="line">        head.next = tempHead</span><br><span class="line">        head = tempHead</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="comment"># 我们找到小朋友</span></span><br><span class="line">            leftHead = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-1</span>):</span><br><span class="line">                leftHead = head</span><br><span class="line">                head = head.next</span><br><span class="line"></span><br><span class="line">            leftHead.next = head.next</span><br><span class="line">            head = head.next</span><br><span class="line"></span><br><span class="line">            <span class="comment"># bakTmp = leftHead.next</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="comment"># # while bakTmp.next != head:</span></span><br><span class="line">            <span class="comment"># #     bakTmp = bakTmp.next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 表示循环链表中，只剩下一个小朋友了</span></span><br><span class="line">            <span class="keyword">if</span> head == head.next:</span><br><span class="line">                <span class="keyword">return</span> head.val</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(Solution().LastRemaining_Solution(<span class="number">5</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p><img data-src="%E5%B0%8F%E6%9C%8B%E5%8F%8B%E7%9A%84%E6%B8%B8%E6%88%8F.png" alt="img"></p><p><img data-src="%E5%B0%8F%E6%9C%8B%E5%8F%8B%E7%9A%84%E6%B8%B8%E6%88%8F%E5%85%AC%E5%BC%8F.png" alt="img"></p><p>这个题一开始小朋友们每个人自己的编号是确定的，就相当于我们列表里面的索引是确定的一样，然后让编号为0。</p><p>链表1：也就是 列表里面的第一个数开始报数，上图第一个链表蓝色的0,开始报数。报到 m-1 的数的 i小朋友 出列，圈里就少了一个数。定义为 f(n).</p><p>链表2：这个时候 从 m-1 的下一个 m 开始 下一轮的循环，开始报数，也就是上图第二个链表的蓝色框。再次报到 m-1 的时候，这个ii小朋友会站出来。（但是这个时候 我们链表的 循环顺序  (m-(m-2)) 发生了变化，不再是从第一个数 【链表的表头  开始循环，而是m 这个数作为起始位置的】，与之前第一个 链表循环的时候的 顺序(0-n)不同了【起始位置为链表的表头】。此时表里少了一个小朋友。这个是题意，让我们这样来找的小朋友。所以定义为 f `(n-1).</p><p>这样的话，就出现了 上图中的 链表2 ，链表3. 这样的不同的情况，这两个 找出来的第  m-1 个 小朋友 是同一个小朋友，但是 两个顺序却不相同。</p><p>链表3：这个图 是 以 m  为起始位置 来寻找第 m-1 个值的，它 就是 f(n-1)</p><p>  如果说我们想由  链表3   得到 链表2 的话，那么 我们就需要把作为起始位置的m（下标为0） 移动到 下标为（m） 的位置，那么就是下标值 +  m 。如图，我们需要移动的是 每个数值所对应的 下标 index值。让 m 在一个链表中作为起始位置来开始 报数 找 第 m - 1 个iii小朋友。</p><p>但是又由于 我们这样直接加上一个m 以后，这个 index 值有可能会大于 这个链表的长度，如果大于这个链表的长度的话，那么就是说移动到了这个链表的前一部分，所以要对我们的 这个数 对 链表的长的的一个取余：</p><p>(iii+m)%n    我们一共是 n 个值，从0-(n-1);</p><p>f(n-1) = iii</p><p>所以 f(n) = f `(n-1) = (iii+m)%n</p><p>所以 f(n) = (f(n-1)+m)</p><p>那么这个通项表达式我们就找到了，再去编写代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining_Solution</span><span class="params">(self, n, m)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment">#通过推导公式可得 f(n) = (f(n-1)+m)%n</span></span><br><span class="line">        <span class="comment">#首先判断，当我们这个链表里没有小朋友的时候，或者找到的小朋友报的数小于1 的时候，这个时候返回一个-1，题中表示 如果测试的是0个小朋友，数0个站出来，那么返回的值应为-1.</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span> <span class="keyword">or</span> m &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment">#只有一个人的时候，说明要找的就是这一个人。那么就返回下标0 编号。</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        value = <span class="number">0</span></span><br><span class="line">        <span class="comment">#时间复杂度 o(n)</span></span><br><span class="line">        <span class="comment">#从 2 开始 一直到 n 个小朋友 来循环，n 个数，所以为 n+1 </span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment">#现在数到的 m-1 这个值 的索引。对应上上面的公式。</span></span><br><span class="line">            currentValue = (value+m) % index</span><br><span class="line">            <span class="comment">#把找到的这个下标值 赋值给 value</span></span><br><span class="line">            value = currentValue</span><br><span class="line">        <span class="comment">#返回编号</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的压入弹出序列</title>
      <link href="/2019/05/05/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
      <url>/2019/05/05/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="栈的压入弹出序列"><a href="#栈的压入弹出序列" class="headerlink" title="栈的压入弹出序列"></a>栈的压入弹出序列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p><a id="more"></a><p>（注意：这两个序列的长度是相等的）</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们以：1 2 3 4 5  进行压入，下面的：2 4 5 3 1 是弹出序列</p><p><img data-src="image-20200424111056735.png" alt="image"></p><ul><li>首先我们需要有一个栈，列表</li><li>按照pushV的方式压入栈</li><li>弹出的时候，需要循环判断是否需要弹出</li><li>判断是否需要弹出的时机，刚刚压入过后就弹</li><li>判断需要弹出的情况的条件，压入栈的顶部 和 弹出栈的顶部数据相等</li><li>然后我们还需要循环比较</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line"></span><br><span class="line">    def IsPopOrder(self, pushV, popV):</span><br><span class="line">        # 首先我们需要有一个栈</span><br><span class="line">        if pushV &#x3D;&#x3D; [] or len(pushV) !&#x3D; len(popV):</span><br><span class="line">            return None</span><br><span class="line">        stack &#x3D; []</span><br><span class="line">        index &#x3D; 0</span><br><span class="line">        for item in pushV:</span><br><span class="line">            # 压栈</span><br><span class="line">            stack.append(item)</span><br><span class="line">            # 判断是否需要弹出，也就是插入的值，等于popV的第一个。这里需要循环判断</span><br><span class="line">            while stack !&#x3D; [] and stack[-1] &#x3D;&#x3D; popV[index]:</span><br><span class="line">                stack.pop()</span><br><span class="line">                index +&#x3D; 1</span><br><span class="line">        # 判断 stack 中是否有元素，如果有，代表着False</span><br><span class="line">        return len(stack) &#x3D;&#x3D; 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组中的查找</title>
      <link href="/2019/05/04/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2019/05/04/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><a id="more"></a><h2 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h2><p>下面是这样一个规律的二维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 </span><br><span class="line">2 3 4 5 </span><br><span class="line">4 6 7 10</span><br><span class="line">9 11 13 15</span><br></pre></td></tr></table></figure><p>我们对每个数字进行遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def Find(self, target, array):</span><br><span class="line">        for i in range(len(array)):</span><br><span class="line">            for j in range(len(array)):</span><br><span class="line">                if target &#x3D;&#x3D; array[i][j]:</span><br><span class="line">                    return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h2 id="标准解法"><a href="#标准解法" class="headerlink" title="标准解法"></a>标准解法</h2><p>上面我们可以看到，题目是给定递增的顺序的，而我们使用暴力算法的时候，没有应用到它的有序的特征。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 </span><br><span class="line">2 3 4 5 </span><br><span class="line">4 6 7 10</span><br><span class="line">9 11 13 15</span><br></pre></td></tr></table></figure><p>我们在回到刚刚的规律这块，我们能够发现，给定一个 target，我们可以比较这个数的最后一列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure><p>如果这个数在比 某一个数小，那么它肯定处于该行中，进行查找。例如我们现在要查找 <code>7</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先比较的是 4，然后发现 4 &lt; 7 ，因此肯定不在第一行</span><br><span class="line">然后比较 5 ， 5 &lt; 7，那么也不在第二行</span><br><span class="line">然后比较 10， 10 &gt; 7，因此可能就在这一行，那么就开始在这一行进行遍历，最终找到了7</span><br></pre></td></tr></table></figure><p>代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # array 二维列表</span><br><span class="line">    def Find(self, target, array):</span><br><span class="line">    # 判断二维数组是否非空</span><br><span class="line">        if any(array) &#x3D;&#x3D; 0:</span><br><span class="line">            return False</span><br><span class="line">        for i in range(len(array)):</span><br><span class="line">            # 判断最后一位是否比target更大</span><br><span class="line">            if array[i][len(array) - 1] &gt;&#x3D; target:</span><br><span class="line">                for j in range(len(array)):</span><br><span class="line">                    if target &#x3D;&#x3D; array[i][j]:</span><br><span class="line">                        return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个链表的公共结点</title>
      <link href="/2019/05/03/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/"/>
      <url>/2019/05/03/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="两个链表的公共结点"><a href="#两个链表的公共结点" class="headerlink" title="两个链表的公共结点"></a>两个链表的公共结点</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>也就是说两个链表具有公共的部分</p><p><img data-src="image-20200426084449089.png" alt="image"></p><p>第一种方式就是遍历两个链表，找出公共的节点，并且时间复杂度为： <code>O(n^2)</code></p><p>第二种方式，只需要花费 <code>O(n)</code>的时间复杂度</p><p>首先我们需要准备两个指针，第一个指针指向第一个的头部，另一个指向第二个链表的头部，然后我们同时移动这两个指针，当有一个指针到头的时候，另一个指针还没有到头，我们记录到这个差值N</p><p>然后在再次这样指向，但是首先需要保证那个长的链表先执行 N步，然后这两个节点再一次走，直到两个节点相交的时候，就得到了第一个公共节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line"></span><br><span class="line">    # 第一个参数给比较短的链表，第二个参数给长链表的值</span><br><span class="line">    # def findEqual(self,):</span><br><span class="line"></span><br><span class="line">    def FindFirstCommonNode(self, pHead1, pHead2):</span><br><span class="line">        </span><br><span class="line">        # 假设输入的两个链表，是同一个链表</span><br><span class="line">        if pHead1 &#x3D;&#x3D; pHead2:</span><br><span class="line">            return pHead1</span><br><span class="line">        </span><br><span class="line">        pTmp1 &#x3D; pHead1</span><br><span class="line">        pTmp2 &#x3D; pHead2</span><br><span class="line"></span><br><span class="line">        # 我们通过循环，让其中一个节点走到最后</span><br><span class="line">        while pTmp1 and pTmp2:</span><br><span class="line">            pTmp1 &#x3D; pTmp1.next</span><br><span class="line">            pTmp2 &#x3D; pTmp2.next</span><br><span class="line"></span><br><span class="line">        # 判断哪个链表先走到最后</span><br><span class="line">        # 假设pTmp1，还没有走完，说明pTmp2是更短的</span><br><span class="line">        if pTmp1:</span><br><span class="line">            k &#x3D; 0</span><br><span class="line">            # 寻找链表长度之间的差值</span><br><span class="line">            while pTmp1:</span><br><span class="line">                pTmp1 &#x3D; pTmp1.next</span><br><span class="line">                k +&#x3D; 1</span><br><span class="line">            # 我们让pTmp1先跳N步</span><br><span class="line">            pTmp2 &#x3D; pHead2</span><br><span class="line">            pTmp1 &#x3D; pHead1</span><br><span class="line">            for i in range(k):</span><br><span class="line">                pTmp1 &#x3D; pTmp1.next</span><br><span class="line"></span><br><span class="line">            # 当找到节点相等的时候，也就是说明该节点是公共节点</span><br><span class="line">            while pTmp1 !&#x3D; pTmp2:</span><br><span class="line">                pTmp1 &#x3D; pTmp1.next</span><br><span class="line">                pTmp2 &#x3D; pTmp2.next</span><br><span class="line">            return pTmp1</span><br><span class="line"></span><br><span class="line">        # 假设pTmp2，还没有走完，说明pTmp1是更短的</span><br><span class="line">        if pTmp2:</span><br><span class="line">            k &#x3D; 0</span><br><span class="line">            while pTmp2:</span><br><span class="line">                pTmp2 &#x3D; pTmp2.next</span><br><span class="line">                k +&#x3D; 1</span><br><span class="line">            # 我们让pTmp2先跳N步</span><br><span class="line">            pTmp2 &#x3D; pHead2</span><br><span class="line">            pTmp1 &#x3D; pHead1</span><br><span class="line">            for i in range(k):</span><br><span class="line">                pTmp2 &#x3D; pTmp2.next</span><br><span class="line"></span><br><span class="line">            while pTmp1 !&#x3D; pTmp2:</span><br><span class="line">                pTmp1 &#x3D; pTmp1.next</span><br><span class="line">                pTmp2 &#x3D; pTmp2.next</span><br><span class="line">            return pTmp1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂链表的复制</title>
      <link href="/2019/05/02/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
      <url>/2019/05/02/%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>下图是复杂链表的数据结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 链表结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        self.random = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><img data-src="image-20200425214035668.png" alt="image"></p><p>最简单的思路是，使用python提供的深拷贝实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> copy.deepcopy(pHead)</span><br></pre></td></tr></table></figure><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>关于Random指针，因为我们不知道它是指向，因此我们每次都需要从头到尾进行遍历</p><p>我们要做的就是把上面的节点复制一份出来</p><p><img data-src="image-20200425215533799.png" alt="image9"></p><p>这样得到了： 11,22,33,44 的链表，就相当于在每个数的后面，同时又复制了一份，最后执行一下的方法</p><blockquote><p>A.next.random = a.random.next</p></blockquote><p>最后我们得到了两个链表</p><p><img data-src="image-20200425233303213.png" alt="image"></p><p>完整图</p><p><img data-src="image-20200426105420274.png" alt="image4"></p><p>完整代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复杂链表的复制</span></span><br><span class="line"><span class="comment"># 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），</span></span><br><span class="line"><span class="comment"># 请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链表结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        <span class="comment"># 复制一个一样的node，并且添加到之前的链表的每一个node后面</span></span><br><span class="line">        <span class="keyword">while</span> pTmp:</span><br><span class="line">            <span class="comment"># 创建一个和原来一样的node</span></span><br><span class="line">            node = RandomListNode(pTmp.laebl)</span><br><span class="line">            node.next = pTmp.next</span><br><span class="line">            <span class="comment"># 将原来的指向刚刚创建的节点</span></span><br><span class="line">            pTmp.next = node</span><br><span class="line">            <span class="comment"># 同时移动被复制的节点</span></span><br><span class="line">            pTmp = node.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实现新建node的random的指向</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            <span class="comment"># 将复制节点的random，指向 它Random的next</span></span><br><span class="line">            <span class="keyword">if</span> pTmp.random:</span><br><span class="line">                pTmp.next.random = pTmp.random.next</span><br><span class="line">            pTmp = pTmp.next.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 断开原来的node 和 新 node 之间的连接</span></span><br><span class="line">        pTmp = pHead</span><br><span class="line">        newHead = pHead.next</span><br><span class="line">        pNewTmp = pHead.next</span><br><span class="line">        <span class="keyword">while</span> pTmp:</span><br><span class="line">            pTmp.next = pTmp.next.next</span><br><span class="line">            <span class="keyword">if</span> pNewTmp.next:</span><br><span class="line">                pNewTmp.next = pNewTmp.next.next</span><br><span class="line">                pNewTmp = pNewTmp.next</span><br><span class="line">            pTmp = pTmp.next            </span><br><span class="line">        <span class="keyword">return</span> newHead</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个排序的链表</title>
      <link href="/2019/04/29/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/29/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>先有两个单调递增的链表</p><p><img data-src="image-20200425211851737.png" alt="image"></p><p>合并后</p><p><img data-src="image-20200425211958540.png" alt="image"></p><p>从上图发现，我们一共需要4个指针，第一个是头指针，第二个和第三个分别是控制两个链表的移动的指针，第四个指针是最小值的指针（前面的指针）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # 返回合并后列表</span><br><span class="line">    def Merge(self, pHead1, pHead2):</span><br><span class="line"></span><br><span class="line">        if pHead1 &#x3D;&#x3D; None:</span><br><span class="line">            return pHead2</span><br><span class="line">        if pHead2 &#x3D;&#x3D; None:</span><br><span class="line">            return pHead1</span><br><span class="line"></span><br><span class="line">        # 得到最小的一个头结点</span><br><span class="line">        newHead &#x3D; pHead1 if pHead1.val &lt; pHead2.val else pHead2</span><br><span class="line">        # 链表1上的指针 和 链表2上的指针</span><br><span class="line">        pTmp1 &#x3D; pHead1</span><br><span class="line">        pTmp2 &#x3D; pHead2</span><br><span class="line">        if newHead &#x3D;&#x3D; pTmp1:</span><br><span class="line">            pTmp1 &#x3D; pTmp1.next</span><br><span class="line">        if newHead &#x3D;&#x3D; pTmp2:</span><br><span class="line">            pTmp2 &#x3D; pTmp2.next</span><br><span class="line"></span><br><span class="line">        # 前面的指针</span><br><span class="line">        previousPointer &#x3D; newHead</span><br><span class="line"></span><br><span class="line">        # 链表1 和 链表2 都不为空的时候，开始合并</span><br><span class="line">        while pTmp1 and pTmp2:</span><br><span class="line">            # 找出最小值，放在previousPointer指针后面</span><br><span class="line">            if pTmp1.val &lt; pTmp2.val:</span><br><span class="line">                previousPointer.next &#x3D; pTmp1</span><br><span class="line">                previousPointer &#x3D; pTmp1</span><br><span class="line">                pTmp1 &#x3D; pTmp1.next</span><br><span class="line">            else:</span><br><span class="line">                previousPointer.next &#x3D; pTmp2</span><br><span class="line">                previousPointer &#x3D; pTmp2</span><br><span class="line">                pTmp2 &#x3D; pTmp2.next</span><br><span class="line"></span><br><span class="line">        if pTmp1 &#x3D;&#x3D; None:</span><br><span class="line">            previousPointer.next &#x3D; pTmp2</span><br><span class="line">        if pTmp2 &#x3D;&#x3D; None:</span><br><span class="line">            previousPointer.next &#x3D; pTmp1</span><br><span class="line"></span><br><span class="line">        return newHead</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表中倒数第K个节点</title>
      <link href="/2019/04/21/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>/2019/04/21/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="链表中倒数第K个节点"><a href="#链表中倒数第K个节点" class="headerlink" title="链表中倒数第K个节点"></a>链表中倒数第K个节点</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个解法是使用一个数组来存储每个节点，最后我们输出第 len(list) - K 个节点即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while node:</span><br><span class="line">    list.append(node)</span><br><span class="line">    node &#x3D; node.next</span><br><span class="line"></span><br><span class="line"># K比链表长度大</span><br><span class="line">if k &gt; len(list):</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">return list[len(list) - k]</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 链表中倒数第K个节点</span><br><span class="line"># 输入一个链表，输出该链表中倒数第k个结点。</span><br><span class="line"></span><br><span class="line"># 链表结构</span><br><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"># 打印链表</span><br><span class="line">def printChain(head):</span><br><span class="line">    node &#x3D; head</span><br><span class="line">    while node:</span><br><span class="line">        print(node.val)</span><br><span class="line">        node &#x3D; node.next</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def FindKthToTail(self, head, k):</span><br><span class="line">        if k &lt;&#x3D; 0 or head &#x3D;&#x3D; []:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        node &#x3D; head</span><br><span class="line">        list &#x3D; []</span><br><span class="line">        while node:</span><br><span class="line">            list.append(node)</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line"></span><br><span class="line">        # K比链表长度大</span><br><span class="line">        if k &gt; len(list):</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        return list[len(list) - k]</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # 创建链表</span><br><span class="line">    l1 &#x3D; ListNode(1)</span><br><span class="line">    l2 &#x3D; ListNode(2)</span><br><span class="line">    l3 &#x3D; ListNode(3)</span><br><span class="line">    l4 &#x3D; ListNode(4)</span><br><span class="line">    l5 &#x3D; ListNode(5)</span><br><span class="line"></span><br><span class="line">    l1.next &#x3D; l2</span><br><span class="line">    l2.next &#x3D; l3</span><br><span class="line">    l3.next &#x3D; l4</span><br><span class="line">    l4.next &#x3D; l5</span><br><span class="line"></span><br><span class="line">    print(Solution().FindKthToTail(l1, 1))</span><br></pre></td></tr></table></figure><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>第二种方式就是我们需要使用两个指针，第一个指针先走K步，然后两个指针在同时行走，最后当第一个指针到达终点的时候，第二个指针就是倒数第K个值。</p><p><img data-src="images/image-20200425103015322.png" alt="image"></p><p>完整代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line"></span><br><span class="line">    def FindKthToTail(self, head, k):</span><br><span class="line">        if k &lt;&#x3D; 0 or head &#x3D;&#x3D; []:</span><br><span class="line">            return None</span><br><span class="line">        list &#x3D; []</span><br><span class="line">        first &#x3D; head</span><br><span class="line">        second &#x3D; head</span><br><span class="line">        # 先让第一个节点走 K步</span><br><span class="line">        for i in range(0, k):</span><br><span class="line">        # 判断第一个是否走完</span><br><span class="line">            if first &#x3D;&#x3D; None:</span><br><span class="line">                return None</span><br><span class="line">            first &#x3D; first.next</span><br><span class="line"></span><br><span class="line">        # 然后两个节点在继续走，当first走到头的时候，second就是倒数第K个节点</span><br><span class="line">        while first:</span><br><span class="line">            first &#x3D; first.next</span><br><span class="line">            second &#x3D; second.next</span><br><span class="line">        return second</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/2019/04/15/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/15/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>反转前</p><p><img data-src="image-20200425104541126.png" alt="image"></p><p>反转后</p><p><img data-src="image-20200425104523244.png" alt="image"></p><p>步骤：</p><ul><li>将现有的头换成尾，尾部的next换成None</li><li>将从第二个指针node开始，循环将next指向前一个</li><li>需要一直有一个指针指向还没有反转的链表的头部</li></ul><p>我们需要有三个指针，一个是左指针，中指针，右指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># 反转链表</span><br><span class="line"># 输入一个链表，反转链表后，输出新链表的表头。</span><br><span class="line"></span><br><span class="line"># 链表结构</span><br><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"># 打印链表</span><br><span class="line">def printChain(head):</span><br><span class="line">    node &#x3D; head</span><br><span class="line">    while node:</span><br><span class="line">        print(node.val)</span><br><span class="line">        node &#x3D; node.next</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def ReverseList(self, pHead):</span><br><span class="line">        if pHead &#x3D;&#x3D; None:</span><br><span class="line">            return None</span><br><span class="line">        if pHead.next &#x3D;&#x3D; None:</span><br><span class="line">            return pHead</span><br><span class="line"></span><br><span class="line">        leftPointer &#x3D; pHead</span><br><span class="line">        middlePointer &#x3D; pHead.next</span><br><span class="line">        rightPointer &#x3D; pHead.next.next</span><br><span class="line">        leftPointer.next &#x3D; None</span><br><span class="line"></span><br><span class="line">        while rightPointer !&#x3D; None:</span><br><span class="line">            middlePointer.next &#x3D; leftPointer</span><br><span class="line">            leftPointer &#x3D; middlePointer</span><br><span class="line">            middlePointer &#x3D; rightPointer</span><br><span class="line">            rightPointer &#x3D; rightPointer.next</span><br><span class="line"></span><br><span class="line">        middlePointer.next &#x3D; leftPointer</span><br><span class="line"></span><br><span class="line">        return middlePointer</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # 创建链表</span><br><span class="line">    l1 &#x3D; ListNode(1)</span><br><span class="line">    l2 &#x3D; ListNode(2)</span><br><span class="line">    l3 &#x3D; ListNode(3)</span><br><span class="line">    l4 &#x3D; ListNode(4)</span><br><span class="line">    l5 &#x3D; ListNode(5)</span><br><span class="line"></span><br><span class="line">    l1.next &#x3D; l2</span><br><span class="line">    l2.next &#x3D; l3</span><br><span class="line">    l3.next &#x3D; l4</span><br><span class="line">    l4.next &#x3D; l5</span><br><span class="line"></span><br><span class="line">    print(Solution().ReverseList(l1))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从尾到头打印链表</title>
      <link href="/2019/04/10/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/04/10/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在python中定义链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 链表结构</span><br><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"># 打印链表</span><br><span class="line">def printChain(head):</span><br><span class="line">    node &#x3D; head</span><br><span class="line">    while node:</span><br><span class="line">        print(node.val)</span><br><span class="line">        node &#x3D; node.next</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # 创建链表</span><br><span class="line">    l1 &#x3D; ListNode(1)</span><br><span class="line">    l2 &#x3D; ListNode(2)</span><br><span class="line">    l3 &#x3D; ListNode(3)</span><br><span class="line">    l1.next &#x3D; l2</span><br><span class="line">    l2.next &#x3D; l3</span><br><span class="line">    printChain(l1)</span><br></pre></td></tr></table></figure><p>下面我们看题目是需要倒序输出，那么我们使用一个数组记录，每次插入到数组的前面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while node:</span><br><span class="line">    print(node.val)</span><br><span class="line">    list.insert(0, node.val)</span><br><span class="line">    node &#x3D; node.next</span><br></pre></td></tr></table></figure><p>完整代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 从头到尾打印链表</span><br><span class="line"># 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</span><br><span class="line"></span><br><span class="line"># 链表结构</span><br><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line"># 打印链表</span><br><span class="line">def printChain(head):</span><br><span class="line">    node &#x3D; head</span><br><span class="line">    while node:</span><br><span class="line">        print(node.val)</span><br><span class="line">        node &#x3D; node.next</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    # 返回从尾部到头部的列表值序列，例如[1,2,3]</span><br><span class="line">    def printListFromTailToHead(self, listNode):</span><br><span class="line">        node &#x3D; listNode</span><br><span class="line">        list &#x3D; []</span><br><span class="line">        while node:</span><br><span class="line">            print(node.val)</span><br><span class="line">            list.insert(0, node.val)</span><br><span class="line">            node &#x3D; node.next</span><br><span class="line">        return list</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # 创建链表</span><br><span class="line">    l1 &#x3D; ListNode(1)</span><br><span class="line">    l2 &#x3D; ListNode(2)</span><br><span class="line">    l3 &#x3D; ListNode(3)</span><br><span class="line">    l1.next &#x3D; l2</span><br><span class="line">    l2.next &#x3D; l3</span><br><span class="line">    Solution().printListFromTailToHead(l1)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包含min函数的栈</title>
      <link href="/2019/04/03/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
      <url>/2019/04/03/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><p>注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们需要维护一个最小值的数组，这个数组存储每次push元素时候的最小值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 压栈</span><br><span class="line">def push(self, node):</span><br><span class="line">    self.stack.append(node)</span><br><span class="line"></span><br><span class="line">    # 维护当前最小的数组</span><br><span class="line">    if self.minValue:</span><br><span class="line">        if self.minValue[-1] &gt; node:</span><br><span class="line">            self.minValue.append(node)</span><br><span class="line">        else:</span><br><span class="line">            self.minValue.append(self.minValue[-1])</span><br><span class="line">    else:</span><br><span class="line">        self.minValue.append(node)</span><br></pre></td></tr></table></figure><p>从上面的代码能看出，我们只需要比较  当前 最小值数组的，最小值和当前插入值比较，如果比最小值比当前的小，那么就还是插入本身，否则插入的是我们新的节点。</p><p><img data-src="image-20200424101759236.png" alt="image"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 包含min函数的栈</span><br><span class="line"># 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</span><br><span class="line"># 注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。</span><br><span class="line">class Solution:</span><br><span class="line"></span><br><span class="line">    # 初始化</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.stack &#x3D; []</span><br><span class="line">        # 存储最小元素</span><br><span class="line">        self.minValue &#x3D; []</span><br><span class="line"></span><br><span class="line">    # 压栈</span><br><span class="line">    def push(self, node):</span><br><span class="line">        self.stack.append(node)</span><br><span class="line"></span><br><span class="line">        # 维护当前最小的数组</span><br><span class="line">        if self.minValue:</span><br><span class="line">            if self.minValue[-1] &gt; node:</span><br><span class="line">                self.minValue.append(node)</span><br><span class="line">            else:</span><br><span class="line">                self.minValue.append(self.minValue[-1])</span><br><span class="line">        else:</span><br><span class="line">            self.minValue.append(node)</span><br><span class="line"></span><br><span class="line">    # 出栈</span><br><span class="line">    def pop(self):</span><br><span class="line">        if self.stack &#x3D;&#x3D; []:</span><br><span class="line">            return None</span><br><span class="line">        self.minValue.pop()</span><br><span class="line">        return self.stack.pop()</span><br><span class="line"></span><br><span class="line">    # 获取栈顶</span><br><span class="line">    def top(self):</span><br><span class="line">        if self.stack &#x3D;&#x3D; []:</span><br><span class="line">            return None</span><br><span class="line">        return self.stack[-1]</span><br><span class="line"></span><br><span class="line">    def min(self):</span><br><span class="line">        if self.minValue &#x3D;&#x3D; []:</span><br><span class="line">            return None</span><br><span class="line">        return self.minValue[-1]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调整数组顺序使奇数位于偶数前面</title>
      <link href="/2019/03/27/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
      <url>/2019/03/27/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>我们要做的就是下面的这种效果，把奇数提取出来，放在一个数组中，然后在把偶数放在另外一个数组中，最后将两个数组合并</p><p><img data-src="image-20200424093736886.png" alt="image"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 调整数组顺序使奇数位于偶数前面</span><br><span class="line"># 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，</span><br><span class="line"># 所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变</span><br><span class="line">class Solution:</span><br><span class="line">    def reOrderArray(self, array):</span><br><span class="line">        ret &#x3D; []</span><br><span class="line">        ret2 &#x3D; []</span><br><span class="line">        for i in range(0, len(array)):</span><br><span class="line">            # 判断是否偶数</span><br><span class="line">            if array[i] % 2 &#x3D;&#x3D; 0:</span><br><span class="line">                ret2.append(array[i])</span><br><span class="line">            else:</span><br><span class="line">                ret.append(array[i])</span><br><span class="line">        return ret + ret2</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(Solution().reOrderArray([3,4,5,2,3,6,7,8]))</span><br></pre></td></tr></table></figure><p>假设不用辅助数组来排序</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转数组的最小数字</title>
      <link href="/2019/03/21/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
      <url>/2019/03/21/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><a id="more"></a><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>第一种方法就是遍历全部的元素，然后找出最小的，时间复杂度为：<code>O(n)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minNumberInRotateArray(self, rotateArray):</span><br><span class="line">        minNum &#x3D; 0</span><br><span class="line">        # 第一种方法，就是遍历所以的元素，找出最小的</span><br><span class="line">        for i in range(0, len(rotateArray)):</span><br><span class="line">            minNum &#x3D; minNum if minNum &lt; rotateArray[i] and minNum !&#x3D; 0 else rotateArray[i]</span><br><span class="line">        return minNum</span><br></pre></td></tr></table></figure><h2 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h2><p>上面的暴力破解方法，没有用到题目的特性，就是非递减排序的数组，这个时候我们就可以使用二分查找法，来找出最小的元素。</p><p><img data-src="image-20200423120520734.png" alt="image"></p><p>首先这个数组局部有序的，假设我们查询一个数，如找出最小是1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一次比较的数为： 5，通过  3 &lt; 5, 2 &lt; 5，  |5 - 3| &lt; |5 - 2| ，所以从右边找</span><br><span class="line">第二次比较：  5 &gt; 1,  2 &gt; 1，这个时候，它两边的数都比它小，说明它就是最小值。</span><br></pre></td></tr></table></figure><p><img data-src="image-20200423121048934.png" alt="image"></p><p>这个时候，我们就需要将原来的 二分查找法变换一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|a[middle] - left| &lt; |a[middle] - right|</span><br><span class="line">如果成立，就往右边查找</span><br><span class="line">如果不成立，那就左边查找</span><br><span class="line"></span><br><span class="line">如果 middle &lt; left，middle &lt; right时，那么就说明这个数是最小值</span><br><span class="line">即比两边的数都更小</span><br></pre></td></tr></table></figure><p>给定一个二分查找法的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line"></span><br><span class="line">    # 二分查找法</span><br><span class="line">    # 有序的数组中使用</span><br><span class="line">    def bSearch(self, array, target):</span><br><span class="line">        left &#x3D; 0</span><br><span class="line">        right &#x3D; len(array) - 1</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            # 右移1位，相当于除以2</span><br><span class="line">            mid &#x3D; (left + right) &gt;&gt; 1</span><br><span class="line">            if target &#x3D;&#x3D; mid:</span><br><span class="line">                return mid</span><br><span class="line">            if target &gt; mid:</span><br><span class="line">                left &#x3D; mid + 1</span><br><span class="line">            else:</span><br><span class="line">                right &#x3D; mid - 1</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(Solution().bSearch([1,2,3,4,5,6,7,8,9,10], 8))</span><br></pre></td></tr></table></figure><p>下面我们需要改进一下代码，让其能够找出我们的最小值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    # 二分查找法</span><br><span class="line">    # 有序的数组中使用</span><br><span class="line">    def minNumberInRotateArray(self, rotateArray):</span><br><span class="line">        if not rotateArray:</span><br><span class="line">            return None</span><br><span class="line">        left &#x3D; 0</span><br><span class="line">        right &#x3D; len(rotateArray) - 1</span><br><span class="line">        while left &lt;&#x3D; right:</span><br><span class="line">            middle &#x3D; (left + right) &gt;&gt; 1</span><br><span class="line">            # middle 比两边的都小，说明是最小值</span><br><span class="line">            if rotateArray[middle] &lt; rotateArray[middle - 1]:</span><br><span class="line">                return rotateArray[middle]</span><br><span class="line">            elif rotateArray[middle] &lt; rotateArray[right]:</span><br><span class="line">                right &#x3D; middle - 1                </span><br><span class="line">            else:</span><br><span class="line">                left &#x3D; middle + 1</span><br><span class="line">        return 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个栈实现一个队列</title>
      <link href="/2019/03/12/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/"/>
      <url>/2019/03/12/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="两个栈实现一个队列"><a href="#两个栈实现一个队列" class="headerlink" title="两个栈实现一个队列"></a>两个栈实现一个队列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><a id="more"></a><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>栈：先进后出</p><p>队列：先进先出.</p><p><img data-src="image-20200423094525763.png" alt="image"></p><p>我们需要使用一个栈用于接收数据，并且一个栈用于输出数据</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 接收栈</span><br><span class="line">        self.acceptStack &#x3D; []</span><br><span class="line">        # 输出栈</span><br><span class="line">        self.outputStack &#x3D; []</span><br><span class="line"></span><br><span class="line">    def push(self, node):</span><br><span class="line">        # 把节点放到栈中</span><br><span class="line">        self.acceptStack.append(node)</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        # 从接收栈中获取元素，把它放入到 输出栈中</span><br><span class="line">        if self.outputStack &#x3D;&#x3D; []:</span><br><span class="line">            while self.acceptStack:</span><br><span class="line">                self.outputStack.append(self.acceptStack.pop())</span><br><span class="line"></span><br><span class="line">        # 判断输出栈中是否有元素，有，则输出最后一个</span><br><span class="line">        if self.outputStack !&#x3D; []:</span><br><span class="line">            return self.outputStack.pop()</span><br><span class="line">        else:</span><br><span class="line">            return None</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>替换空格</title>
      <link href="/2019/03/09/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>/2019/03/09/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><a id="more"></a><h2 id="调用方法实现"><a href="#调用方法实现" class="headerlink" title="调用方法实现"></a>调用方法实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # s 源字符串</span><br><span class="line">    def replaceSpace(self, s):</span><br><span class="line">        return s.replace(&#39; &#39;, &#39;%20&#39;)</span><br></pre></td></tr></table></figure><h2 id="自己写方法实现Replace"><a href="#自己写方法实现Replace" class="headerlink" title="自己写方法实现Replace"></a>自己写方法实现Replace</h2><p>我们将字符串存储在数组中，然后循环比较每个字符的值，当遇到空格的时候，替换即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def replaceSpace2(self, s):</span><br><span class="line">        strLen &#x3D; len(s)</span><br><span class="line">        aaa &#x3D; []</span><br><span class="line">        for i in range(0, strLen):</span><br><span class="line">            if s[i] &#x3D;&#x3D; &quot; &quot;:</span><br><span class="line">                aaa.append(&quot;%&quot;)</span><br><span class="line">                aaa.append(&quot;2&quot;)</span><br><span class="line">                aaa.append(&quot;0&quot;)</span><br><span class="line">            else:</span><br><span class="line">                aaa.append(s[i])</span><br><span class="line">        return &#39;&#39;.join(aaa)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(Solution().replaceSpace2(&#39;We Are Happy&#39;))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找出丑数</title>
      <link href="/2019/03/03/%E6%89%BE%E5%87%BA%E4%B8%91%E6%95%B0/"/>
      <url>/2019/03/03/%E6%89%BE%E5%87%BA%E4%B8%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="找出丑数"><a href="#找出丑数" class="headerlink" title="找出丑数"></a>找出丑数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><a id="more"></a><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>死循环，找丑数判断一个数是不是丑数，先循环除以2，直到不能整除，循环除以3 直到不能整除，循环除以5 直到不能整除这时如果剩余的值是1  我们就说它是丑数，其他情况就都不是丑数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def GetUglyNumber_Solution(self, index):</span><br><span class="line">        # write code here</span><br><span class="line">        if index &lt; 1:</span><br><span class="line">            return None</span><br><span class="line">        #死循环，找丑数</span><br><span class="line">        #判断一个数是不是丑数，先循环除以2，直到不能整除，</span><br><span class="line">        #循环除以3 直到不能整除，循环除以5 直到不能整除</span><br><span class="line">        #这时如果剩余的值是1  我们就说它是丑数</span><br><span class="line">        #其他情况就都不是丑数</span><br><span class="line">        def isUglyNumber(num):</span><br><span class="line">            while num % 2 &#x3D;&#x3D; 0:</span><br><span class="line">                num &#x3D; num &#x2F;&#x2F;2</span><br><span class="line">            while num % 3 &#x3D;&#x3D; 0:</span><br><span class="line">                num &#x3D; num &#x2F;&#x2F;3</span><br><span class="line">            while num % 5 &#x3D;&#x3D; 0:</span><br><span class="line">                num &#x3D; num &#x2F;&#x2F;5</span><br><span class="line">            if num &#x3D;&#x3D; 1:</span><br><span class="line">                return True</span><br><span class="line">            else:</span><br><span class="line">                return False</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        num &#x3D; 1</span><br><span class="line">        while True:</span><br><span class="line">            if isUglyNumber(num):</span><br><span class="line">                count +&#x3D; 1</span><br><span class="line">            if count &#x3D;&#x3D; index:</span><br><span class="line">                return num</span><br><span class="line">            num +&#x3D; 1</span><br></pre></td></tr></table></figure><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>我们可以保存已经找到的丑数，然后 用空间环时间 来 找出丑数。</p><p>如何用空间换时间？</p><p>我们找一种，只需要计算丑数的办法,根据上面丑数的定义，我们可以知道，丑数应该是另一个丑数 乘以 2,3，或者5 的结果（1除外）。因此我们 可以创建一个 列表，里面的数字是排好序的 丑数，每个丑数都是前面的丑数乘以2,3，或者5得到的。</p><p>那么我们就可以在一个列表中，给它第一个 丑数的值，然后根据 它 得到剩下的 丑数的值，第一个丑数为1，那么我们在这个列表的起始位置 设置三个指针，这三个指针代表的值  分别为2,3,5.又由于这个列表中的所有的丑数 是有序的，从小到大排列的，那么我们在每次 给一个丑数 乘以 2,3,5 以后要与前面的丑数比较大小，然后在根据大小值 来放入列表中。由于一开始第一个丑数是1，那么 1 * 2 得到的是2,1*3 得到的是3，1 乘以5 得到的是5，那么三个数中比较大小，最小的是 1 乘以2，那么 肯定第一个先放置的是2，然后是 2 乘以2 和 1乘3,1乘5 比较大小，最小的是3 那么就放置 3，下一个 是 2 乘以3 是6,6 与 5  和4 比较大小 最小的是4，以此类推，那么现在的到的丑数的顺序就是1,2,3,4.。。。。。</p><p><img data-src="image-20200527225225898.png" alt="image"></p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def nthUglyNumber(self, index):</span><br><span class="line">        #首先判断  要找的 丑数 是不是第0个 或者是负数，如果是的话，那么就返回0</span><br><span class="line">        if index &lt;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line">        #然后判断要找的丑数 是不是第一个，如果是第一个，那么就返回1.</span><br><span class="line">        if index &#x3D;&#x3D; 1:</span><br><span class="line">            return 1</span><br><span class="line">        #在丑数 这个列表中 给出第一个丑数是1</span><br><span class="line">        numbers &#x3D; [1]</span><br><span class="line">        #在列表的 一开始  设置三个 指针，也就是 三个指针的 索引位置是0，</span><br><span class="line">        two, three, five &#x3D; 0, 0, 0</span><br><span class="line">        #丑数的个数 起始为 1</span><br><span class="line">        count &#x3D; 1</span><br><span class="line">        #循环 当丑数的个数不等于我们要找到 那第 index 个 丑数时，就循环，等于的时候就跳出循环。</span><br><span class="line">        while count !&#x3D; index :</span><br><span class="line">            #给列表中的 2,3,5 这三个指针所在位置的 丑数 分别 乘以2,3,5</span><br><span class="line">            n2, n3, n5 &#x3D; numbers[two] * 2, numbers[three] * 3, numbers[five] * 5</span><br><span class="line">            #比较这三个丑数的大小</span><br><span class="line">            minValue &#x3D; min(n2, n3, n5)</span><br><span class="line">            #在丑数列表中，把三个中最小的那个 放进去。</span><br><span class="line">            numbers.append(minValue)</span><br><span class="line">            #每放进去一个，丑数的数量就加1</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line">            #这个是指针移位的，如果说我们比较出来的 三个数中最小的丑数是 2 指针的话，那么2 指针就往前移动一位</span><br><span class="line">            if minValue &#x3D;&#x3D; n2:</span><br><span class="line">                two +&#x3D; 1</span><br><span class="line">            #如果是 3 那个指针的话，那么3 这个指针就移一位。</span><br><span class="line">            if minValue &#x3D;&#x3D; n3:</span><br><span class="line">                three +&#x3D; 1</span><br><span class="line">            #如果是 5 那个指针的话，那么5这个指针就移一位。</span><br><span class="line">            if minValue &#x3D;&#x3D; n5:</span><br><span class="line">                five +&#x3D; 1</span><br><span class="line">        #最后输出这个丑数列表中的 最后一位，那么就是我们的计数的丑数的个数 -1，就是最后一个丑数的索引值。</span><br><span class="line">        return numbers[count-1]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青蛙跳台阶</title>
      <link href="/2019/02/28/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2019/02/28/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a>青蛙跳台阶</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）</p><a id="more"></a><h2 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h2><p><img data-src="image-20200422221734432.png" alt="image"></p><p>代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def JumpFloor(self, n):</span><br><span class="line">        if n &#x3D;&#x3D; 0:</span><br><span class="line">            return 0;</span><br><span class="line">        if n &#x3D;&#x3D; 1:</span><br><span class="line">            return 1;</span><br><span class="line">        if n &#x3D;&#x3D; 2:</span><br><span class="line">            return 2;</span><br><span class="line"></span><br><span class="line">        ret &#x3D; 0</span><br><span class="line">        a &#x3D; 1</span><br><span class="line">        b &#x3D; 2</span><br><span class="line">        for i in range(3, n + 1):</span><br><span class="line">            ret &#x3D; a + b</span><br><span class="line">            a &#x3D; b</span><br><span class="line">            b &#x3D; ret</span><br><span class="line">        return ret</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(Solution().JumpFloor(10))</span><br></pre></td></tr></table></figure><h1 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h2 id="找规律-1"><a href="#找规律-1" class="headerlink" title="找规律"></a>找规律</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当 n &#x3D; 1   1</span><br><span class="line">当 n &#x3D; 2   2</span><br><span class="line">当 n &#x3D; 3   4</span><br><span class="line">当 n &#x3D; 4   8</span><br><span class="line">当 n &#x3D; n   2^(n-1)</span><br></pre></td></tr></table></figure><p>通过找规律的方法解题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def jumpFloorII(self, number):</span><br><span class="line">        return pow(2, number -1)</span><br></pre></td></tr></table></figure><p>找出通项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(n) &#x3D; f(n-1) + f(n-2) + ..... + f(1)</span><br><span class="line">f(n-1) &#x3D; f(n-2) + ..... + f(1)</span><br><span class="line"># 我们结合上面的式子，移项可得</span><br><span class="line">f(n) &#x3D; 2f(n-1)，n &gt; 1</span><br><span class="line">f(1) &#x3D; 1</span><br></pre></td></tr></table></figure><p>解法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def JumpFloorII(self, n):</span><br><span class="line">        if n &#x3D;&#x3D; 1:</span><br><span class="line">            return 1;</span><br><span class="line">        ret &#x3D; 0</span><br><span class="line">        a &#x3D; 1</span><br><span class="line">        for i in range(2, n + 1):</span><br><span class="line">            ret &#x3D; 2 * a</span><br><span class="line">            a &#x3D; ret</span><br><span class="line">        return ret</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    print(Solution().JumpFloorII(10))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契数列</title>
      <link href="/2019/02/25/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
      <url>/2019/02/25/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p><p>n&lt;=39</p><a id="more"></a><h2 id="菲波那切数列是什么"><a href="#菲波那切数列是什么" class="headerlink" title="菲波那切数列是什么"></a>菲波那切数列是什么</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0 1 1 2 3 5 8 13</span><br><span class="line"></span><br><span class="line">n &#x3D; 0, num &#x3D; 0</span><br><span class="line">n &#x3D; 1, num &#x3D; 1</span><br><span class="line">n &#x3D; 2, num &#x3D; 1</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">当 n &#x3D; k(n&gt;1),f(k) &#x3D; f(k-1) + f(k-2)</span><br><span class="line">当 n &#x3D; 1, f(1) &#x3D; 1</span><br><span class="line">当 n &#x3D; 0, f(0) &#x3D; 0</span><br></pre></td></tr></table></figure><h2 id="递归方法实现"><a href="#递归方法实现" class="headerlink" title="递归方法实现"></a>递归方法实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）  n&lt;=39</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.Fibonacci(n - <span class="number">1</span>) + self.Fibonacci(n <span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(Solution().Fibonacci(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><p>但是这样存在问题，随着n提升，时间复杂度不断增加</p><p><img data-src="image-20200422211936865.png" alt="image"></p><p>我们发现对于某个值，我们重复计算了很多遍</p><h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><p>我们继续查看刚刚的规律</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当 n &#x3D; 2的时候， h &#x3D; f(1) + f(0) &#x3D; 1 + 0 &#x3D; 1</span><br><span class="line">当 n &#x3D; 3的时候， h &#x3D; f(2) + f(1) &#x3D; 1 + 1 &#x3D; 2</span><br><span class="line">当 n &#x3D; 4的时候， h &#x3D; f(3) + f(2) &#x3D; 3 + 1 &#x3D; 4</span><br></pre></td></tr></table></figure><p>我们可以从n = 2，一直循环，直到我们计算出我们输入的值为n的时候</p><p>我们只需要从最小的开始计算，每次保留中间结果，最后得出我们的第n个的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）  n&lt;=39</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 非递归实现</span></span><br><span class="line">    <span class="comment"># 当 n = 2的时候， h = f(1) + f(0) = 1 + 0 = 1</span></span><br><span class="line">    <span class="comment"># 当 n = 3的时候， h = f(2) + f(1) = 1 + 1 = 2</span></span><br><span class="line">    <span class="comment"># 当 n = 4的时候， h = f(3) + f(2) = 3 + 1 = 4</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci2</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line">        b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n<span class="number">-1</span>):</span><br><span class="line">            ret = a + b</span><br><span class="line">            b = a</span><br><span class="line">            a = ret</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(Solution().Fibonacci2(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令总结</title>
      <link href="/2019/01/19/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/19/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>1.ls [选项] [目录名 | 列出相关目录下的所有目录和文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-a  列出包括.a开头的隐藏文件的所有文件</span><br><span class="line">-A  通-a，但不列出&quot;.&quot;和&quot;..&quot;</span><br><span class="line">-l  列出文件的详细信息</span><br><span class="line">-c  根据ctime排序显示</span><br><span class="line">-t  根据文件修改时间排序</span><br><span class="line">---color[&#x3D;WHEN] 用色彩辨别文件类型 WHEN 可以是&#39;never&#39;、&#39;always&#39;或&#39;auto&#39;其中之一</span><br><span class="line">   白色：表示普通文件</span><br><span class="line">   蓝色：表示目录</span><br><span class="line">   绿色：表示可执行文件</span><br><span class="line">   红色：表示压缩文件</span><br><span class="line">   浅蓝色：链接文件</span><br><span class="line">   红色闪烁：表示链接的文件有问题</span><br><span class="line">   黄色：表示设备文件</span><br><span class="line">   灰色：表示其它文件</span><br></pre></td></tr></table></figure><a id="more"></a><p>2.mv [选项] 源文件或目录 目录或多个源文件 | 移动或重命名文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-b  覆盖前做备份</span><br><span class="line">-f  如存在不询问而强制覆盖</span><br><span class="line">-i  如存在则询问是否覆盖</span><br><span class="line">-u  较新才覆盖</span><br><span class="line">-t  将多个源文件移动到统一目录下，目录参数在前，文件参数在后</span><br><span class="line">eg:</span><br><span class="line">   mv a &#x2F;tmp&#x2F; 将文件a移动到 &#x2F;tmp目录下</span><br><span class="line">   mv a b 将a命名为b</span><br><span class="line">   mv &#x2F;home&#x2F;zenghao test1.txt test2.txt test3.txt</span><br></pre></td></tr></table></figure><p>3.cp [选项] 源文件或目录 目录或多个源文件 | 将源文件复制至目标文件，或将多个源文件复制至目标目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-r -R 递归复制该目录及其子目录内容</span><br><span class="line">-p  连同档案属性一起复制过去</span><br><span class="line">-f  不询问而强制复制</span><br><span class="line">-s  生成快捷方式</span><br><span class="line">-a  将档案的所有特性都一起复制</span><br></pre></td></tr></table></figure><p>4.scp [参数] [原路径] [目标路径] | 在Linux服务器之间复制文件和目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-v  详细显示输出的具体情况</span><br><span class="line">-r  递归复制整个目录</span><br><span class="line">(1) 复制文件：  </span><br><span class="line">命令格式：  </span><br><span class="line">scp local_file remote_username@remote_ip:remote_folder  </span><br><span class="line">或者  </span><br><span class="line">scp local_file remote_username@remote_ip:remote_file  </span><br><span class="line">或者  </span><br><span class="line">scp local_file remote_ip:remote_folder  </span><br><span class="line">或者  </span><br><span class="line">scp local_file remote_ip:remote_file  </span><br><span class="line">第1,2个指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名  </span><br><span class="line">第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名   </span><br><span class="line">(2) 复制目录：  </span><br><span class="line">命令格式：  </span><br><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder  </span><br><span class="line">或者  </span><br><span class="line">scp -r local_folder remote_ip:remote_folder  </span><br><span class="line">第1个指定了用户名，命令执行后需要输入用户密码；  </span><br><span class="line">第2个没有指定用户名，命令执行后需要输入用户名和密码；</span><br><span class="line">eg:</span><br><span class="line">   从 本地 复制到 远程</span><br><span class="line">   scp &#x2F;home&#x2F;daisy&#x2F;full.tar.gz root@172.19.2.75:&#x2F;home&#x2F;root </span><br><span class="line">   从 远程 复制到 本地</span><br><span class="line">   scp root@&#x2F;172.19.2.75:&#x2F;home&#x2F;root&#x2F;full.tar.gz &#x2F;home&#x2F;daisy&#x2F;full.tar.gz</span><br></pre></td></tr></table></figure><p>5.rm [选项] 文件 | 删除文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-r  删除文件夹</span><br><span class="line">-f  删除不提示</span><br><span class="line">-i  删除提示</span><br><span class="line">-v  详细显示进行步骤</span><br></pre></td></tr></table></figure><p>6.touch [选项] 文件 | 创建空文件或更新文件时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a  只修改存取时间</span><br><span class="line">-m  值修改变动时间</span><br><span class="line">-r  eg:touch -r a b ,使b的时间和a相同</span><br><span class="line">-t  指定特定的时间 eg:touch -t 201211142234.50 log.log </span><br><span class="line">   -t time [[CC]YY]MMDDhhmm[.SS],C:年前两位</span><br></pre></td></tr></table></figure><p>7.pwd 查看当前所在路径</p><p>8.cd 改变当前目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- ：返回上次目录</span><br><span class="line">.. :返回上层目录</span><br><span class="line">回车  ：返回主目录</span><br><span class="line">&#x2F;   :根目录</span><br></pre></td></tr></table></figure><p>9.mkdir [选项] 目录… | 创建新目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-p  递归创建目录，若父目录不存在则依次创建</span><br><span class="line">-m  自定义创建目录的权限  eg:mkdir -m 777 hehe</span><br><span class="line">-v  显示创建目录的详细信息</span><br></pre></td></tr></table></figure><p>10.rmdir 删除空目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-v  显示执行过程</span><br><span class="line">-p  若自父母删除后父目录为空则一并删除</span><br></pre></td></tr></table></figure><p>11.rm [选项] 文件… | 一个或多个文件或目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-f  忽略不存在的文件，不给出提示</span><br><span class="line">-i  交互式删除</span><br><span class="line">-r  将列出的目录及其子目录递归删除</span><br><span class="line">-v  列出详细信息</span><br></pre></td></tr></table></figure><p>12.echo：显示内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-n  输出后不换行</span><br><span class="line">-e  遇到转义字符特殊处理  </span><br><span class="line">   eg:</span><br><span class="line">       echo &quot;hehe&quot;   显示hehe</span><br><span class="line">       ehco -e &quot;hehe&quot;    显示he(换行了)he</span><br></pre></td></tr></table></figure><p>13.cat [选项] [文件]..| 一次显示整个文件或从键盘创建一个文件或将几个文件合并成一个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n  编号文件内容再输出</span><br><span class="line">-E  在结束行提示$</span><br></pre></td></tr></table></figure><p>14.tac | 反向显示</p><p>15.more | 按页查看文章内容，从前向后读取文件，因此在启动时就加载整个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+n  从第n行开始显示</span><br><span class="line">-n  每次查看n行数据</span><br><span class="line">+&#x2F;String    搜寻String字符串位置，从其前两行开始查看</span><br><span class="line">-c  清屏再显示</span><br><span class="line">-p  换页时清屏</span><br></pre></td></tr></table></figure><p>16.less | 可前后移动地逐屏查看文章内容，在查看前不会加载整个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-m  显示类似于more命令的百分比</span><br><span class="line">-N  显示行号</span><br><span class="line">&#x2F;   字符串：向下搜索“字符串”的功能</span><br><span class="line">?   字符串：向上搜索“字符串”的功能</span><br><span class="line">n   重复前一个搜索（与 &#x2F; 或 ? 有关）</span><br><span class="line">N   反向重复前一个搜索（与 &#x2F; 或 ? 有关）</span><br><span class="line">b   向后翻一页</span><br><span class="line">d   向后翻半页</span><br></pre></td></tr></table></figure><p>17.nl [选项]… [文件]… | 将输出内容自动加上行号 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-b </span><br><span class="line">-b a 不论是否有空行，都列出行号（类似 cat -n) </span><br><span class="line">-b t 空行则不列行号（默认） </span><br><span class="line">-n 有ln rn rz三个参数，分别为再最左方显示，最右方显示不加0，最右方显示加0</span><br></pre></td></tr></table></figure><p>18.head [参数]… [文件]… | 显示档案开头，默认开头10行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-v  显示文件名</span><br><span class="line">-c number   显示前number个字符,若number为负数,则显示除最后number个字符的所有内容</span><br><span class="line">-number&#x2F;n (+)number     显示前number行内容，</span><br><span class="line">-n number   若number为负数，则显示除最后number行数据的所有内容</span><br></pre></td></tr></table></figure><p>19.tail [必要参数] [选择参数] [文件] | 显示文件结尾内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-v  显示详细的处理信息</span><br><span class="line">-q  不显示处理信息</span><br><span class="line">-num&#x2F;-n (-)num      显示最后num行内容</span><br><span class="line">-n +num 从第num行开始显示后面的数据</span><br><span class="line">-c  显示最后c个字符</span><br><span class="line">-f  循环读取</span><br></pre></td></tr></table></figure><p>20.vi 编辑文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">:w filename 将文章以指定的文件名保存起来  </span><br><span class="line">:wq 保存并退出</span><br><span class="line">:q! 不保存而强制退出</span><br><span class="line">命令行模式功能键</span><br><span class="line">1）插入模式</span><br><span class="line">   按「i」切换进入插入模式「insert mode」，按&quot;i&quot;进入插入模式后是从光标当前位置开始输入文件；</span><br><span class="line">   按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；</span><br><span class="line">   按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。</span><br><span class="line"></span><br><span class="line">2）从插入模式切换为命令行模式</span><br><span class="line"> 按「ESC」键。</span><br><span class="line">3）移动光标</span><br><span class="line">　　vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。</span><br><span class="line">　　按「ctrl」+「b」：屏幕往&quot;后&quot;移动一页。</span><br><span class="line">　　按「ctrl」+「f」：屏幕往&quot;前&quot;移动一页。</span><br><span class="line">　　按「ctrl」+「u」：屏幕往&quot;后&quot;移动半页。</span><br><span class="line">　　按「ctrl」+「d」：屏幕往&quot;前&quot;移动半页。</span><br><span class="line">　　按数字「0」：移到文章的开头。</span><br><span class="line">　　按「G」：移动到文章的最后。</span><br><span class="line">　　按「$」：移动到光标所在行的&quot;行尾&quot;。</span><br><span class="line">　　按「^」：移动到光标所在行的&quot;行首&quot;</span><br><span class="line">　　按「w」：光标跳到下个字的开头</span><br><span class="line">　　按「e」：光标跳到下个字的字尾</span><br><span class="line">　　按「b」：光标回到上个字的开头</span><br><span class="line">　　按「#l」：光标移到该行的第#个位置，如：5l,56l。</span><br><span class="line"></span><br><span class="line">4）删除文字</span><br><span class="line">　　「x」：每按一次，删除光标所在位置的&quot;后面&quot;一个字符。</span><br><span class="line">　　「#x」：例如，「6x」表示删除光标所在位置的&quot;后面&quot;6个字符。</span><br><span class="line">　　「X」：大写的X，每按一次，删除光标所在位置的&quot;前面&quot;一个字符。</span><br><span class="line">　　「#X」：例如，「20X」表示删除光标所在位置的&quot;前面&quot;20个字符。</span><br><span class="line">　　「dd」：删除光标所在行。</span><br><span class="line">　　「#dd」：从光标所在行开始删除#行</span><br><span class="line"></span><br><span class="line">5）复制</span><br><span class="line">　　「yw」：将光标所在之处到字尾的字符复制到缓冲区中。</span><br><span class="line">　　「#yw」：复制#个字到缓冲区</span><br><span class="line">　　「yy」：复制光标所在行到缓冲区。</span><br><span class="line">　　「#yy」：例如，「6yy」表示拷贝从光标所在的该行&quot;往下数&quot;6行文字。</span><br><span class="line">　　「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与&quot;y&quot;有关的复制命令都必须与&quot;p&quot;配合才能完成复制与粘贴功能。</span><br><span class="line"></span><br><span class="line">6）替换</span><br><span class="line">　　「r」：替换光标所在处的字符。</span><br><span class="line">　　「R」：替换光标所到之处的字符，直到按下「ESC」键为止。</span><br><span class="line"></span><br><span class="line">7）回复上一次操作</span><br><span class="line">　　「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次&quot;u&quot;可以执行多次回复。</span><br><span class="line"></span><br><span class="line">8）更改</span><br><span class="line">　　「cw」：更改光标所在处的字到字尾处</span><br><span class="line">　　「c#w」：例如，「c3w」表示更改3个字</span><br><span class="line"></span><br><span class="line">9）跳至指定的行</span><br><span class="line">　　「ctrl」+「g」列出光标所在行的行号。</span><br><span class="line">　　「#G」：例如，「15G」，表示移动光标至文章的第15行行首。</span><br></pre></td></tr></table></figure><p>21.which 可执行文件名称 | 查看可执行文件的位置，在PATH变量指定的路径中查看系统命令是否存在及其位置</p><p>22.whereis [-bmsu] [BMS 目录名 -f ] 文件名| 定位可执行文件、源代码文件、帮助文件在文件系统中的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-b   定位可执行文件。</span><br><span class="line">-m   定位帮助文件。</span><br><span class="line">-s   定位源代码文件。</span><br><span class="line">-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。</span><br><span class="line">-B   指定搜索可执行文件的路径。</span><br><span class="line">-M   指定搜索帮助文件的路径。</span><br><span class="line">-S   指定搜索源代码文件的路径。</span><br></pre></td></tr></table></figure><p>23.locate | 通过搜寻数据库快速搜寻档案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-r  使用正规运算式做寻找的条件</span><br></pre></td></tr></table></figure><p>24.find find [PATH] [option] [action] | 在文件树种查找文件，并作出相应的处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line">1. 与时间有关的选项：共有 -atime, -ctime 与 -mtime 和-amin,-cmin与-mmin，以 -mtime 说明</span><br><span class="line">   -mtime n ：n 为数字，意义为在 n 天之前的『一天之内』被更动过内容的档案；</span><br><span class="line">   -mtime +n ：列出在 n 天之前(不含 n 天本身)被更动过内容的档案档名；</span><br><span class="line">   -mtime -n ：列出在 n 天之内(含 n 天本身)被更动过内容的档案档名。</span><br><span class="line">   -newer file ：file 为一个存在的档案，列出比 file 还要新的档案档名</span><br><span class="line"></span><br><span class="line">2. 与使用者或组名有关的参数：</span><br><span class="line">   -uid n ：n 为数字，这个数字是用户的账号 ID，亦即 UID</span><br><span class="line">   -gid n ：n 为数字，这个数字是组名的 ID，亦即 GID</span><br><span class="line">   -user name ：name 为使用者账号名称！例如 dmtsai</span><br><span class="line">   -group name：name 为组名，例如 users ；</span><br><span class="line">   -nouser ：寻找档案的拥有者不存在 &#x2F;etc&#x2F;passwd 的人！</span><br><span class="line">   -nogroup ：寻找档案的拥有群组不存在于 &#x2F;etc&#x2F;group 的档案！</span><br><span class="line"></span><br><span class="line">3. 与档案权限及名称有关的参数：</span><br><span class="line">   -name filename：搜寻文件名为 filename 的档案（可使用通配符）</span><br><span class="line">   -size [+-]SIZE：搜寻比 SIZE 还要大(+)或小(-)的档案。这个 SIZE 的规格有：</span><br><span class="line">       c: 代表 byte</span><br><span class="line">       k: 代表 1024bytes。所以，要找比 50KB还要大的档案，就是『 -size +50k 』</span><br><span class="line">   -type TYPE ：搜寻档案的类型为 TYPE 的，类型主要有：</span><br><span class="line">       一般正规档案 (f)</span><br><span class="line">       装置档案 (b, c)</span><br><span class="line">       目录 (d)</span><br><span class="line">       连结档 (l)</span><br><span class="line">       socket (s)</span><br><span class="line">       FIFO (p)</span><br><span class="line">   -perm mode ：搜寻档案权限『刚好等于』 mode的档案，这个mode为类似chmod的属性值，举例来说，-rwsr-xr-x 的属性为4755！</span><br><span class="line">   -perm -mode ：搜寻档案权限『必须要全部囊括 mode 的权限』的档案，举例来说，</span><br><span class="line">       我们要搜寻-rwxr--r-- 亦即 0744 的档案，使用-perm -0744，当一个档案的权限为 -rwsr-xr-x ，亦即 4755 时，也会被列出来，因为 -rwsr-xr-x 的属性已经囊括了 -rwxr--r-- 的属性了。</span><br><span class="line">   -perm +mode ：搜寻档案权限『包含任一 mode 的权限』的档案，举例来</span><br><span class="line">       说，我们搜寻-rwxr-xr-x ，亦即 -perm +755 时，但一个文件属性为 -rw-------也会被列出来，因为他有 -rw.... 的属性存在！</span><br><span class="line">4. 额外可进行的动作：</span><br><span class="line">   -exec command ：command 为其他指令，-exec 后面可再接额外的指令来处理搜寻到的结果。</span><br><span class="line">   -print ：将结果打印到屏幕上，这个动作是预设动作！</span><br><span class="line">   eg:</span><br><span class="line">       find &#x2F; -perm +7000 -exec ls -l &#123;&#125; ; ,额外指令以-exec开头，以;结尾&#123;&#125;代替前面找到的内容</span><br><span class="line">   | xargs </span><br><span class="line">       -i  默认的前面输出用&#123;&#125;代替 </span><br><span class="line">       eg:</span><br><span class="line">           find . -name &quot;*.log&quot; | xargs -i mv &#123;&#125; test4</span><br></pre></td></tr></table></figure><p>25.grep ‘正则表达式’ 文件名 | 用正则表达式搜索文本，并把匹配的行打印出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c  只输出匹配行的计数。</span><br><span class="line">-I  不区分大小写(只适用于单字符)。</span><br><span class="line">-l  只显示文件名</span><br><span class="line">-v  显示不包含匹配文本的所有行。</span><br><span class="line">-n  显示匹配行数据及其行号</span><br></pre></td></tr></table></figure><p>25.file | 判断文件类型</p><p>26.gzip [-cdtv#] 檔名 | 压缩、解压缩，源文件都不再存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-d  进行解压缩</span><br><span class="line">-c  将压缩的数据输出到屏幕上</span><br><span class="line">-v  :显示原档案&#x2F;压缩文件案的压缩比等信息</span><br><span class="line">-#  ：压缩等级，-1最快，但压缩比最差，&#x3D;9最慢，但压缩比最好</span><br></pre></td></tr></table></figure><p>27.gunzip | 解压缩</p><p>28.bzip2 | 压缩、解压缩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-d  :解压</span><br><span class="line">-z  :压缩</span><br><span class="line">-k  :保留源文件</span><br><span class="line">-c ：将压缩的过程产生的数据输出到屏幕上！</span><br><span class="line">-v ：可以显示出原档案&#x2F;压缩文件案的压缩比等信息；</span><br><span class="line">-# ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！</span><br></pre></td></tr></table></figure><p>29.bzcat 读取数据而无需解压</p><p>30.tar [主选项+辅选项] 文件或者目录 | 多个目录或档案打包、压缩成一个大档案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">主选项：</span><br><span class="line">   -c  建立打包档案，可搭配 -v 来察看过程中被打包的档名(filename)</span><br><span class="line">   -t  察看打包档案的内容含有哪些档名，重点在察看『档名』就是了；</span><br><span class="line">   -x  解打包或解压缩的功能，可以搭配 -C (大写) 在特定目录解开</span><br><span class="line">辅选项：</span><br><span class="line">   -j  透过 bzip2 的支持进行压缩&#x2F;解压缩：此时档名最好为 *.tar.bz2</span><br><span class="line">   -z  透过 gzip 的支持进行压缩&#x2F;解压缩：此时档名最好为 *.tar.gz</span><br><span class="line">   -v  在压缩&#x2F;解压缩的过程中，将正在处理的文件名显示出来！</span><br><span class="line">   -f filename -f 后面要立刻接要被处理的档名！</span><br><span class="line">   -C 目录   这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</span><br><span class="line">   --exclude FILE：在压缩打包过程中忽略某文件 eg: tar --exclude &#x2F;home&#x2F;zenghao -zcvf myfile.tar.gz &#x2F;home&#x2F;* &#x2F;etc</span><br><span class="line">   -p  保留备份数据的原本权限与属性，常用于备份(-c)重要的配置文件</span><br><span class="line">   -P(大写）  保留绝对路径，亦即允许备份数据中含有根目录存在之意；</span><br><span class="line">eg:</span><br><span class="line">   压 缩：tar -jcvf filename.tar.bz2 要被压缩的档案或目录名称</span><br><span class="line">   查 询：tar -jtvf filename.tar.bz2</span><br><span class="line">   解压缩：tar -jxvf filename.tar.bz2 -C 欲解压缩的目录</span><br></pre></td></tr></table></figure><p>31.exit 退出当前shell </p><p>32.logout 退出登录shell </p><p>33.shutdown -h now</p><p>34.users 显示当前登录系统地用户</p><p>35.who 登录在本机的用户与来源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-H或--heading 　显示各栏位的标题信息列。</span><br></pre></td></tr></table></figure><p>36.w 登录在本机的用户及其运行的程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s 　使用简洁格式列表，不显示用户登入时间，终端机阶段作业和程序所耗费的CPU时间。</span><br><span class="line">-h 　不显示各栏位的标题信息列。</span><br></pre></td></tr></table></figure><p>37.write 给当前联机的用户发消息</p><p>38.wall 给所有登录再本机的用户发消息</p><p>39.last 查看用户的登陆日志</p><p>40.lastlog 查看每个用户最后的登陆时间</p><p>41.finger [选项] [使用者] [用户@主机] | 查看用户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-s 显示用户的注册名、实际姓名、终端名称、写状态、停滞时间、登录时间等信息</span><br><span class="line">-l 除了用-s选项显示的信息外，还显示用户主目录、登录shell、邮件状态等信息，以及用户主目录下的.plan、.project和.forward文件的内容。</span><br><span class="line">-p 除了不显示.plan文件和.project文件以外，与-l选项相同</span><br></pre></td></tr></table></figure><p>42.hostname 查看主机名</p><p>43.alias ii = “ls -l” | 添加别名</p><p>44.unalias ii | 清除别名</p><p>45.useradd [-u UID] [-g 初始群组] [-G 次要群组] [-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者账号名 | 新增用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-M  不建立用户家目录！(系统账号默认值)</span><br><span class="line">-m  建立用户家目录！(一般账号默认值)</span><br><span class="line">-r  建立一个系统的账号，这个账号的 UID 会有限制 </span><br><span class="line">-e  账号失效日期，格式为『YYYY-MM-DD』</span><br><span class="line">-D  查看useradd的各项默认值</span><br></pre></td></tr></table></figure><p>46.passwd | 修改密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-l  使密码失效</span><br><span class="line">-u  与-l相对，用户解锁</span><br><span class="line">-S  列出登陆用户passwd文件内的相关参数</span><br><span class="line">-n  后面接天数，shadow 的第 4 字段，多久不可修改密码天数</span><br><span class="line">-x  后面接天数，shadow 的第 5 字段，多久内必须要更动密码</span><br><span class="line">-w  后面接天数，shadow 的第 6 字段，密码过期前的警告天数</span><br><span class="line">-i  后面接『日期』，shadow 的第 7 字段，密码失效日期</span><br><span class="line">使用管道刘设置密码：echo &quot;zeng&quot; | passwd --stdin zenghao</span><br></pre></td></tr></table></figure><p>47.userdel 删除用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-r  用户文件一并删除</span><br></pre></td></tr></table></figure><p>48.chage [-ldEImMW] 账号名 | 修改用户密码的相关属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-l  列出该账号的详细密码参数；</span><br><span class="line">-d  后面接日期，修改 shadow 第三字段(最近一次更改密码的日期)，格式YYYY-MM-DD</span><br><span class="line">-E  后面接日期，修改 shadow 第八字段(账号失效日)，格式 YYYY-MM-DD</span><br><span class="line">-I  后面接天数，修改 shadow 第七字段(密码失效日期)</span><br><span class="line">-m  后面接天数，修改 shadow 第四字段(密码最短保留天数)</span><br><span class="line">-M  后面接天数，修改 shadow 第五字段(密码多久需要进行变更)</span><br><span class="line">-W  后面接天数，修改 shadow 第六字段(密码过期前警告日期)</span><br></pre></td></tr></table></figure><p>49.usermod [-cdegGlsuLU] username | 修改用户的相关属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-c  后面接账号的说明，即 &#x2F;etc&#x2F;passwd 第五栏的说明栏，可以加入一些账号的说明。</span><br><span class="line">-d  后面接账号的家目录，即修改 &#x2F;etc&#x2F;passwd 的第六栏；</span><br><span class="line">-e  后面接日期，格式是 YYYY-MM-DD 也就是在 &#x2F;etc&#x2F;shadow 内的第八个字段数据啦！</span><br><span class="line">-f  后面接天数为 shadow 的第七字段。</span><br><span class="line">-g  后面接初始群组，修改 &#x2F;etc&#x2F;passwd 的第四个字段，亦即是GID的字段！</span><br><span class="line">-G  后面接次要群组，修改这个使用者能够支持的群组</span><br><span class="line">-l  后面接账号名称。亦即是修改账号名称， &#x2F;etc&#x2F;passwd 的第一栏！</span><br><span class="line">-s  后面接 Shell 的实际档案，例如 &#x2F;bin&#x2F;bash 或 &#x2F;bin&#x2F;csh 等等。</span><br><span class="line">-u  后面接 UID 数字啦！即 &#x2F;etc&#x2F;passwd 第三栏的资料；</span><br><span class="line">-L  冻结密码</span><br><span class="line">-U  解冻密码</span><br></pre></td></tr></table></figure><p>50.id [username] | 查看用户相关的id信息，还可以用来判断用户是否存在</p><p>51.groups 查看登陆用户支持的群组， 第一个输出的群组为有效群组</p><p>52.newgrp 切换有效群组</p><p>53.groupadd [-g gid] 组名 | 添加组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-g  设定添加组的特定组id</span><br></pre></td></tr></table></figure><p>54.groupmod [-g gid] [-n group_name] 群组名 | 修改组信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-g  修改既有的 GID 数字</span><br><span class="line">-n  修改既有的组名</span><br></pre></td></tr></table></figure><p>55.groupdel [groupname] | 删除群组</p><p>56.gpasswd | 群组管理员功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root管理员动作：</span><br><span class="line">   -gpasswd groupname 设定密码</span><br><span class="line">   -gpasswd [-A user1,...] [-M user3,...] groupname</span><br><span class="line">       -A  将 groupname 的主控权交由后面的使用者管理(该群组的管理员)</span><br><span class="line">       -M  将某些账号加入这个群组当中</span><br><span class="line">   -gpasswd [-r] groupname</span><br><span class="line">       -r  将 groupname 的密码移除</span><br><span class="line">群组管理员动作：</span><br><span class="line">   - gpasswd [-ad] user groupname </span><br><span class="line">       -a  将某位使用者加入到 groupname 这个群组当中</span><br><span class="line">       -d  将某位使用者移除出 groupname 这个群组当中</span><br></pre></td></tr></table></figure><p>57.chfn修改个人信息</p><p>58.mount [-t vfstype] [-o options] device dir</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-ro 采用只读方式挂接设备</span><br><span class="line">-rw 采用读写方式挂接设备</span><br><span class="line">eg:mount &#x2F;home&#x2F;mydisk.iso &#x2F;tmp&#x2F;mnt 通过mnt访问mydisk内的内容</span><br></pre></td></tr></table></figure><p>59.umount 取消挂载</p><p>60.cut</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。</span><br><span class="line">-c ：以字符为单位进行分割。</span><br><span class="line">-d ：自定义分隔符，默认为制表符。</span><br><span class="line">-f  ：与-d一起使用，指定显示哪个区域。</span><br></pre></td></tr></table></figure><p>61.sort</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-n   依照数值的大小排序。</span><br><span class="line">-o&lt;输出文件&gt;   将排序后的结果存入指定的文件。</span><br><span class="line">-r   以相反的顺序来排序。</span><br><span class="line">-t&lt;分隔字符&gt;   指定排序时所用的栏位分隔字符。</span><br><span class="line">-k  选择以哪个区间进行排序。</span><br></pre></td></tr></table></figure><p>62.wc 统计指定文件中的字节数、字数、行数, 并将统计结果显示输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-l filename 报告行数</span><br><span class="line">-c filename 报告字节数</span><br><span class="line">-m filename 报告字符数</span><br><span class="line">-w filename 报告单词数</span><br></pre></td></tr></table></figure><p>63.uniq 去除文件中相邻的重复行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c或——count：在每列旁边显示该行重复出现的次数；</span><br><span class="line">-d或--repeated：仅显示重复出现的行列；</span><br><span class="line">-f&lt;栏位&gt;或--skip-fields&#x3D;&lt;栏位&gt;：忽略比较指定的栏位；</span><br><span class="line">-s&lt;字符位置&gt;或--skip-chars&#x3D;&lt;字符位置&gt;：忽略比较指定的字符；</span><br><span class="line">-u或——unique：仅显示出一次的行列；</span><br><span class="line">-w&lt;字符位置&gt;或--check-chars&#x3D;&lt;字符位置&gt;：指定要比较的字符。</span><br></pre></td></tr></table></figure><p>64.set 显示环境变量和普通变量 </p><p>65.env 显示环境变量 </p><p>66.export 把普通变量变成环境变量 </p><p>67.unset 删除一个环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaa()&#123;&#125; 定义函数</span><br></pre></td></tr></table></figure><p>68.read</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-p  接提示字符</span><br><span class="line">-t  接等待的秒数</span><br></pre></td></tr></table></figure><p>69.declare、typeset</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-i 声明为整数</span><br><span class="line">-a 声明为数组</span><br><span class="line">-f 声明为函数</span><br><span class="line">-r 声明为只读</span><br></pre></td></tr></table></figure><p>70.ulimit 限制使用者的某些系统资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-f  此 shell 可以建立的最大档案容量 (一般可能设定为 2GB)单位为 Kbytes eg: ulimit -f 1024 限制使用者仅能建立 1MBytes 以下的容量的档案</span><br></pre></td></tr></table></figure><p>71.df [选项] [文件] | 显示指定磁盘文件的可用空间,如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a  显示全部文件系统</span><br><span class="line">-h  文件大小友好显示</span><br><span class="line">-l  只显示本地文件系统</span><br><span class="line">-i  显示inode信息</span><br><span class="line">-T  显示文件系统类型</span><br></pre></td></tr></table></figure><p>72.du [选项] [文件] | 显示每个文件和目录的磁盘使用空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-h  方便阅读的方式</span><br><span class="line">-s  只显示总和的大小</span><br></pre></td></tr></table></figure><p>73.ln [参数] [源文件或目录] [目标文件或目录] | 某一个文件在另外一个位置建立一个同步的链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s  建立软连接   </span><br><span class="line">-v  显示详细的处理过程</span><br></pre></td></tr></table></figure><p>74.diff [参数] [文件1或目录1] [文件2或目录2] | 比较单个文件或者目录内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-b 　不检查空格字符的不同。</span><br><span class="line">-B 　不检查空白行。</span><br><span class="line">-i  不检查大小写</span><br><span class="line">-q  仅显示差异而不显示详细信息</span><br><span class="line">eg: diff a b &gt; parch.log 比较两个文件的不同并产生补丁</span><br></pre></td></tr></table></figure><p>75.date [参数]… [+格式] | 显示或设定系统的日期与时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%H 小时(以00-23来表示)。 </span><br><span class="line">%M 分钟(以00-59来表示)。 </span><br><span class="line">%P AM或PM。</span><br><span class="line">%D 日期(含年月日)</span><br><span class="line">%U 该年中的周数。</span><br><span class="line">date -s “2015-10-17 01:01:01″ &#x2F;&#x2F;时间设定</span><br><span class="line">date +%Y%m%d         &#x2F;&#x2F;显示前天年月日</span><br><span class="line">date +%Y%m%d --date&#x3D;&quot;+1 day&#x2F;month&#x2F;year&quot;  &#x2F;&#x2F;显示前一天&#x2F;月&#x2F;年的日期</span><br><span class="line">date +%Y%m%d --date&#x3D;&quot;-1 day&#x2F;month&#x2F;year&quot;  &#x2F;&#x2F;显示后一天&#x2F;月&#x2F;年的日期</span><br><span class="line">date -d &#39;2 weeks&#39; 2周后的日期</span><br></pre></td></tr></table></figure><p>76.cal [参数] 月份] [年份] | 查看日历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-1  显示当月的月历</span><br><span class="line">-3  显示前、当、后一个月的日历</span><br><span class="line">-m  显示星期一为一个星期的第一天</span><br><span class="line">-s  （默认）星期天为第一天</span><br><span class="line">-j  显示当月是一年中的第几天的日历</span><br><span class="line">-y  显示当前年份的日历</span><br></pre></td></tr></table></figure><p>77.ps | 列出当前进程的快照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a   显示所有的进程</span><br><span class="line">-a  显示同一终端下的所有程序</span><br><span class="line">e   显示环境变量</span><br><span class="line">f   显示进程间的关系</span><br><span class="line">-H  显示树状结构</span><br><span class="line">r   显示当前终端的程序</span><br><span class="line">T   显示当前终端的所有程序</span><br><span class="line">-au 显示更详细的信息</span><br><span class="line">-aux    显示所有包含其他使用者的行程 </span><br><span class="line">-u  指定用户的所有进程</span><br></pre></td></tr></table></figure><p>78.top [参数] | 显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等</p><p>79.kill [参数] [进程号] | 杀死进程</p><p>80.free [参数] | 显示linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer</p><p>81.vmstat | 对操作系统的虚拟内存、进程、CPU活动进行监控</p><p>82.iostat [参数] [时间t] [次数n](每隔t时间刷新一次，最多刷新n次）| 对系统的磁盘操作活动进行监视,汇报磁盘活动统计情况，同时也会汇报出CPU使用情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p[磁盘] 显示磁盘和分区的情况</span><br></pre></td></tr></table></figure><p>83.watch [参数] [命令] |重复执行某一命令以观察变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n  时隔多少秒刷新</span><br><span class="line">-d  高亮显示动态变化</span><br></pre></td></tr></table></figure><p>84.at [参数] [时间] | 在一个指定的时间执行一个指定任务，只能执行一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HH:MM[am|pm] + number [minutes|hours|days|weeks] 强制在某年某月某日的某时刻进行该项任务</span><br><span class="line">atq 查看系统未执行的任务</span><br><span class="line">atrm n 删除编号为n的任务</span><br><span class="line">at -c n 显示编号为n的任务的内容</span><br></pre></td></tr></table></figure><p>85.crontab | 定时任务调度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file    载入crontab</span><br><span class="line">-e  编辑某个用户的crontab文件内容</span><br><span class="line">-l  显示某个用户的crontab文件内容</span><br><span class="line">-r  删除某个用户的crontab文件</span><br></pre></td></tr></table></figure><p>86.ifconfig [网络设备] [参数] | 查看和配置网络设备</p><p>87.route | 显示和操作IP路由表</p><p>88.ping [参数] [主机名或IP地址] | 测试与目标主机的连通性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-q  只显示最后的结果</span><br></pre></td></tr></table></figure><p>89.netstat | 显示与IP、TCP、UDP和ICMP协议相关的统计数据</p><p>90.telnet [参数] [主机] | 用于远程登录，采用明文传送报文，安全性不好</p><p>91.rcp [参数] [源文件] [目标文件] | 远程文件拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r  递归复制</span><br><span class="line">-p  保留源文件的属性</span><br><span class="line">usage: rcp –r remote_hostname:remote_dir local_dir</span><br></pre></td></tr></table></figure><p>92.wget [参数] [URL地址] | 直接从网络上下载文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-o FILE 把记录写到FILE文件中    eg : wget -O a.txt URL</span><br><span class="line">wget --limit-rate&#x3D;300k URL  限速下载</span><br></pre></td></tr></table></figure><p>93.awk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-F 分隔符  以分隔符分隔内容</span><br><span class="line">&#123;&#125;  要执行的脚本内容 eg:cat &#x2F;etc&#x2F;passwd |awk  -F &#39;:&#39;  &#39;&#123;print $1&quot;&quot;$7&#125;&#39;</span><br></pre></td></tr></table></figure><p>94.sed 对数据行进行替换、删除、新增、选取等操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a   新增，在新的下一行出现</span><br><span class="line">c   取代，取代 n1,n2 之间的行 eg: sed &#39;1,2c Hi&#39; ab</span><br><span class="line">d   删除</span><br><span class="line">i   插入，在新的上一行出现</span><br></pre></td></tr></table></figure><p>95.paste 合并文件，需确保合并的两文件行数相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-d  指定不同于空格或tab键的域分隔符</span><br><span class="line">-s  按行合并，单独一个文件为一行</span><br></pre></td></tr></table></figure><p>96.su [参数] user | 切换登陆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-l  切换时连同环境变量、工作目录一起改变</span><br><span class="line">-c command  执行command变回原来的使用者</span><br></pre></td></tr></table></figure><p>97.sudo | 以特定用户的权限执行特定命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-l  列出当前用户可执行的命令</span><br><span class="line">-u username#uid 以指定用户执行命令</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Linux命令 </tag>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clone graph（克隆一个图）</title>
      <link href="/2019/01/14/clone-graph%EF%BC%88%E5%85%8B%E9%9A%86%E4%B8%80%E4%B8%AA%E5%9B%BE%EF%BC%89/"/>
      <url>/2019/01/14/clone-graph%EF%BC%88%E5%85%8B%E9%9A%86%E4%B8%80%E4%B8%AA%E5%9B%BE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p><p><strong>OJ’s undirected graph serialization:</strong></p><p>Nodes are labeled uniquely.</p><p>We use # as a separator for each node, and,as a separator for node label and each neighbor of the node.</p><p>As an example, consider the serialized graph{0,1,2# 1,2# 2,2}.</p><a id="more"></a><p>The graph has a total of three nodes, and therefore contains three parts as separated by#.</p><ol><li>First node is labeled as0. Connect node0to both nodes1and2.</li><li>Second node is labeled as1. Connect node1to node2.</li><li>Third node is labeled as2. Connect node2to node2(itself), thus forming a self-cycle.</li></ol><p>Visually, the graph looks like the following:</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>克隆一个无向图。<br>图中的每个节点都包含一个标签和一个邻接表。<br><strong>无向图序列化：</strong><br>节点是唯一标记。<br>我们使用 ＃ 作为每个节点的分隔符，并且作为节点标签的分隔符和节点的每个邻居节点。<br>例如，考虑序列化图{0,1,2＃1,2＃2,2}。<br>该图总共有三个节点，因此包含三个部分，用＃分隔。<br>第一个节点标记为0。 将node0连接到节点1和2。<br>第二个节点标记为1。 将node1连接到node2。<br>第三个节点标记为2。 将node2连接到node2（他自己本身），从而形成自循环。<br>在视觉上，图表如下所示：</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-dfeb3a43f317fbc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>使用了BFS算法；<br>算法思想很类似，只是，是将创建节点的过程移动到了处理当前节点的邻接点部分处理了；<br>如果当前节点的某个邻接点不存在， 创建他， 如果存在， 直接更新map对应的新的图的部分。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for undirected graph.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UndirectedGraphNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> label;</span><br><span class="line"><span class="built_in">vector</span>&lt;UndirectedGraphNode *&gt; neighbors;</span><br><span class="line">UndirectedGraphNode(<span class="keyword">int</span> x) : label(x) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 如果结点为空，直接返回NULL</span></span><br><span class="line">        <span class="comment">// 新的copy的图</span></span><br><span class="line">        UndirectedGraphNode* copy = <span class="keyword">new</span> UndirectedGraphNode(node -&gt; label);</span><br><span class="line">        mp[node] = copy; <span class="comment">// 保存新旧两个图结点的对应关系</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;UndirectedGraphNode*&gt; toVisit;</span><br><span class="line">        toVisit.push(node);</span><br><span class="line">        <span class="keyword">while</span> (!toVisit.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            UndirectedGraphNode* cur = toVisit.front();</span><br><span class="line">            toVisit.pop();</span><br><span class="line">            <span class="comment">// 遍历cur结点的相邻结点</span></span><br><span class="line">            <span class="keyword">for</span> (UndirectedGraphNode* neigh : cur -&gt; neighbors)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// find();：函数返回一个迭代器指向键值为key的元素，如果没找到就返回指向map尾部的迭代器。</span></span><br><span class="line">            <span class="comment">// end();：返回指向map末尾的迭代器</span></span><br><span class="line">            <span class="comment">// 如果在map中没有找到neigh</span></span><br><span class="line">                <span class="keyword">if</span> (mp.<span class="built_in">find</span>(neigh) == mp.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="comment">// map中没有neigh，就创建它</span></span><br><span class="line">                    UndirectedGraphNode* neigh_copy = <span class="keyword">new</span> UndirectedGraphNode(neigh -&gt; label);</span><br><span class="line">                    <span class="comment">// 把新旧两个图的对应关系保存</span></span><br><span class="line">                    mp[neigh] = neigh_copy;</span><br><span class="line">                    <span class="comment">// 把neigh结点入队（以便接下来遍历他的相邻结点）</span></span><br><span class="line">                    toVisit.push(neigh);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新当前cur结点的相邻结点的部分</span></span><br><span class="line">                mp[cur] -&gt; neighbors.push_back(mp[neigh]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copy; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 无序map，键值都是UndirectedGraphNode*指针类型</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归的思想来做</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">find</span>(node) == mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            mp[node] = <span class="keyword">new</span> UndirectedGraphNode(node -&gt; label);</span><br><span class="line">            <span class="keyword">for</span> (UndirectedGraphNode* neigh : node -&gt; neighbors)</span><br><span class="line">                mp[node] -&gt; neighbors.push_back(cloneGraph(neigh));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mp[node];</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; mp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 图 </tag>
            
            <tag> 无向图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>binary tree level order traversal ii)（二叉树自下向上层序遍历）</title>
      <link href="/2019/01/13/binary-tree-level-order-traversal-ii-%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E8%87%AA%E4%B8%8B%E5%90%91%E4%B8%8A%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%89/"/>
      <url>/2019/01/13/binary-tree-level-order-traversal-ii-%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E8%87%AA%E4%B8%8B%E5%90%91%E4%B8%8A%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><p>For example:<br>Given binary tree{3,9,20,#,#,15,7},</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-2995afdae0fa6828.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><a id="more"></a><p>return its bottom-up level order traversal as:</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-74c420bdb40da800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>confused what”{1,#,2,3}”means? <a href="#">&gt; read more on how binary tree is serialized on OJ.</a></p><p><strong>OJ’s Binary Tree Serialization:</strong></p><p>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.</p><p>Here’s an example:</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-60006303e2955b65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>The above binary tree is serialized as”{1,2,3,#,#,4,#,#,5}”.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>实现二叉树自底层向上层的层序遍历。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>还是二叉树层序遍历的问题，只不过是自下向上；<br>很好解决<br>在C++中，可以用vector，可以实现在vector前边插入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; &gt; vec; <span class="comment">// 定义二维数组，其中元素为int类型</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; vt; <span class="comment">// 二维数组的新一行</span></span><br><span class="line">vec.insert(vec.<span class="built_in">begin</span>(), vt); <span class="comment">// 在二维数组前面插入新的一行</span></span><br></pre></td></tr></table></figure><p>或者在Java中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">res.add(<span class="number">0</span>, list);</span><br></pre></td></tr></table></figure><p>也可以实现在二维数组前面插入一行。</p><p>但是经过我在用C++的实验，发现先用vec.push_back(vt)的方式，插入，然后最后的时候用swap(vec[i], vec[j])交换一下，不管是空间还是时间，效率更优。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    结构体定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    具体实现算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> TreeNode* tree;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">levelOrderBottom</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; &gt; vec; <span class="comment">// 定义二维数组，其中元素为int类型</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> vec;</span><br><span class="line">    <span class="built_in">queue</span>&lt;tree&gt; qu; <span class="comment">// 保存二叉树层序遍历结点的指针</span></span><br><span class="line">    qu.push(root); <span class="comment">// 头指针入队</span></span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = qu.<span class="built_in">size</span>(); <span class="comment">// 本层的结点个数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; vt; <span class="comment">// 二维数组的新一行</span></span><br><span class="line">        tree now; <span class="comment">// 暂存当前结点</span></span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">        &#123;</span><br><span class="line">            now = qu.front(); <span class="comment">// 暂存当前结点</span></span><br><span class="line">            qu.pop(); <span class="comment">// 出队</span></span><br><span class="line">            vt.push_back(now-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span>)qu.push(now-&gt;left); <span class="comment">// 入队</span></span><br><span class="line">            <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span>)qu.push(now-&gt;right); <span class="comment">// 入队</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果vt不为空，则加入到二维数组的新一行中</span></span><br><span class="line">        <span class="comment">// 其实分析可以发现，vt也不可能为空</span></span><br><span class="line">        <span class="keyword">if</span>(vt.<span class="built_in">size</span>())</span><br><span class="line">            vec.push_back(vt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为自下向上，所以换一下</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=vec.<span class="built_in">size</span>()<span class="number">-1</span>; i&lt;j; i++,j--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(vec[i], vec[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的层序遍历算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;tree &gt; qu;</span><br><span class="line">    qu.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tree now = qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;now-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span>)qu.push(now-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span>)qu.push(now-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree tr;</span><br><span class="line">    tr = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    tree t1;</span><br><span class="line">    t1 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    tr-&gt;left = t1;</span><br><span class="line"></span><br><span class="line">    tree t2;</span><br><span class="line">    t2 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    tr-&gt;right = t2;</span><br><span class="line"></span><br><span class="line">    tree t3;</span><br><span class="line">    t3 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">    t2-&gt;left = t3;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; &gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print(tr);</span></span><br><span class="line"></span><br><span class="line">    vec = levelOrderBottom(tr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;vec[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;vec[i][j]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 树 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pascals triangle ii（杨辉三角、帕斯卡三角）</title>
      <link href="/2019/01/12/pascals-triangle-ii%EF%BC%88%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E3%80%81%E5%B8%95%E6%96%AF%E5%8D%A1%E4%B8%89%E8%A7%92%EF%BC%89/"/>
      <url>/2019/01/12/pascals-triangle-ii%EF%BC%88%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E3%80%81%E5%B8%95%E6%96%AF%E5%8D%A1%E4%B8%89%E8%A7%92%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given an index <em>k</em>, return the <em>k</em> <sup>th</sup> row of the Pascal’s triangle.<br>For example, given <em>k</em> = 3,<br>Return[1,3,3,1].<br><strong>Note:</strong><br>Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个索引值k，返回杨辉三角中第k行索引的结果<br>例如，给定：k=3，<br>返回：[1,3,3,1]<br>空间复杂度要求为O(k)。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>也是一个杨辉三角的问题，但是这个题不要求返回整个杨辉三角，只要求返回索引行的结果，而且要求空间复杂度为O(k)。<br>因此想到用动规的思想，用一维数组的动态更新来模拟二维数组，但是，考虑每一行的时候，当从前向后递归时是有后效影响的，因此采用从后向前迭代的方式。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rowIndex++; <span class="comment">// 行索引加一是真正的行数</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; <span class="title">res</span><span class="params">(rowIndex, <span class="number">1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一二行均为1，从第三行才需要进行计算操作</span></span><br><span class="line">    <span class="comment">// 因此索引从2开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;rowIndex; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;<span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 每次从后向前迭代</span></span><br><span class="line">            res[j] = res[j<span class="number">-1</span>] + res[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; res;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入："</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        res = getRow(n);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"输出："</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;res[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-39580c5304e4288a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 杨辉三角 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pascals triangle（杨辉三角、帕斯卡三角）</title>
      <link href="/2019/01/11/pascals-triangle%EF%BC%88%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E3%80%81%E5%B8%95%E6%96%AF%E5%8D%A1%E4%B8%89%E8%A7%92%EF%BC%89/"/>
      <url>/2019/01/11/pascals-triangle%EF%BC%88%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E3%80%81%E5%B8%95%E6%96%AF%E5%8D%A1%E4%B8%89%E8%A7%92%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given numRows, generate the first numRows of Pascal’s triangle.<br>For example, given numRows = 5,<br>Return：</p><blockquote><p>[<br>[1],<br>[1,1],<br>[1,2,1],<br>[1,3,3,1],<br>[1,4,6,4,1]<br>]</p></blockquote><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>杨辉三角<br>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br>在杨辉三角中，每个数是它左上方和正上方的数的和。<br>示例:<br>输入:<br>5<br>输出:</p><blockquote><p>[<br>[1],<br>[1,1],<br>[1,2,1],<br>[1,3,3,1],<br>[1,4,6,4,1]<br>]</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>每行比上一行多一个数，每行的第一个数和最后一个数为1，其他的位置的数等于它左上方和正上方的数的和。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 杨辉三角</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> numRows)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numRows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; <span class="title">tmp</span><span class="params">(i+<span class="number">1</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 数组空间为i+1，数组全部初始化为1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前的数值是上方和左上方数值之和</span></span><br><span class="line">            tmp[j] = res[i<span class="number">-1</span>][j<span class="number">-1</span>] + res[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">generate_1</span><span class="params">(<span class="keyword">int</span> numRows)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numRows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; tmp; <span class="comment">// 数组空间为i+1，数组全部初始化为1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 每行第一个数和最后一个数为1</span></span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span> || j==i)</span><br><span class="line">                tmp.push_back(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 其他位置的数遵循规则</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp.push_back(res[i<span class="number">-1</span>][j<span class="number">-1</span>] + res[i<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; a = generate(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;a[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[i][j]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-3de2a1c90253126b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 杨辉三角 </tag>
            
            <tag> 帕斯卡三角 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>remove duplicates from sorted array ii（从重复数组中移除重复元素）</title>
      <link href="/2019/01/10/remove-duplicates-from-sorted-array-ii%EF%BC%88%E4%BB%8E%E9%87%8D%E5%A4%8D%E6%95%B0%E7%BB%84%E4%B8%AD%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%89/"/>
      <url>/2019/01/10/remove-duplicates-from-sorted-array-ii%EF%BC%88%E4%BB%8E%E9%87%8D%E5%A4%8D%E6%95%B0%E7%BB%84%E4%B8%AD%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>类似问题：<a href="https://yangyuanlin.club/2019/01/01/remove-duplicates-from-sorted-list%EF%BC%88%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%89/" target="_blank" rel="noopener">remove duplicates from sorted list（移除有序链表中的重复元素）</a></p></blockquote><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Follow up for “Remove Duplicates”:<br>What if duplicates are allowed at most <em>twice</em>?<br>For example,<br>Given sorted array A =[1,1,1,2,2,3],<br>Your function should return length =5, and A is now[1,1,2,2,3].</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>从重复数组中移除重复元素；<br>允许最多重复两次。</p><h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>常规版本。<br>设置index索引值，索引数组序号，然后对数组进行遍历；<br>当有前中后三个连续重复元素时，就执行continue；<br>否则就把当前值赋值给index下标，并且把index加一。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)<span class="keyword">return</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当有三个连续相等的情况</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;i&lt;n<span class="number">-1</span> &amp;&amp; A[i]==A[i+<span class="number">1</span>] &amp;&amp; A[i]==A[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        A[index++] = A[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = removeDuplicates(a, <span class="number">8</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>很灵活的方法，扩展性较强；<br>如果将occur&lt;2改为occur&lt;3，就变成了允许重复最多三次。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates_2</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)<span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">2</span>; <span class="comment">// 允许重复两次，可以修改为三次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]!=A[index<span class="number">-2</span>]) <span class="comment">// 允许重复两次，可以修改为三次</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[index++]=A[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>plus-one（加一）</title>
      <link href="/2019/01/09/plus-one%EF%BC%88%E5%8A%A0%E4%B8%80%EF%BC%89/"/>
      <url>/2019/01/09/plus-one%EF%BC%88%E5%8A%A0%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a number represented as an array of digits, plus one to the number.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>用一个数组表示一个数，把这个数做加一操作。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>不需要flag！<br>从右向左，遇到9就变0，非9就加1，然后break;<br>digits[0]如果等于0，说明长度增加了1，则新插入一个首位，首位为1，其他位为0。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;digits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=digits.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若当前位小于9，只需在当前位加一就可以结束循环了</span></span><br><span class="line">        <span class="comment">// 并且当前结束循环后不存在第一位进位，因此置标识符为true</span></span><br><span class="line">        <span class="keyword">if</span>(digits[i] &lt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            digits[i] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若当前数字为9，则需要向前一位进位，并且把本位置为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(digits[i] == <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// digits[0]如果等于0，说明长度增加了1。</span></span><br><span class="line">    <span class="comment">// vector.insert(iterator loc, const TYPE &amp;val)，</span></span><br><span class="line">    <span class="comment">// 表示在指定位置loc前插入值为val的元素，</span></span><br><span class="line">    <span class="comment">// 返回指向这个元素的迭代器,</span></span><br><span class="line">    <span class="keyword">if</span>(digits[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        digits.insert(digits.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vec1.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1 2 3 4</span></span><br><span class="line">    plusOne(vec1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vec1.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;vec1[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">9</span>; i&gt;<span class="number">4</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        vec2.push_back(<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 9 9 9 9 9</span></span><br><span class="line">    plusOne(vec2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vec2.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;vec2[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-05a3148f5d8f3aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>merge-sorted-array（合并已排序的数组）</title>
      <link href="/2019/01/08/merge-sorted-array%EF%BC%88%E5%90%88%E5%B9%B6%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%89/"/>
      <url>/2019/01/08/merge-sorted-array%EF%BC%88%E5%90%88%E5%B9%B6%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given two sorted integer arrays A and B, merge B into A as one sorted array.<br><strong>Note:</strong><br>You may assume that A has enough space to hold additional elements from B. The number of elements initialized in A and B are <em>m</em> and <em>n</em> respectively.</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定两个排序的整型数组A和B，将B合并到A中。</p><p>假设A有足够的空间来容纳B中的元素，A和B中初始的元素数目分别为m和n。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>最优解：从后往前处理,不需要开辟额外空间。<br>i从A的末尾，j从B末尾开始，两两比较，大的放在末端。<br>如此类推如果A穷尽，把B元素依次放进A的前几个位置（第二个while循环），如果B穷尽，正好结束（此时不用判断）。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = m<span class="number">-1</span>, j = n<span class="number">-1</span>, index = m+n<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当A和B都没有遍历完</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 大的放到当前index位置</span></span><br><span class="line">        A[index--] = A[i]&gt;B[j] ? A[i--]:B[j--];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当B没有遍历结束时，直接把B剩余元素放进A</span></span><br><span class="line">    <span class="comment">// A未穷尽时不用判断，直接就在前边了</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        A[index--] = B[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> B[] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    merge(A, <span class="number">5</span>, B, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;A[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-dd5a4425ffe27cce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>count-and-say</title>
      <link href="/2019/01/06/count-and-say/"/>
      <url>/2019/01/06/count-and-say/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>The count-and-say sequence is the sequence of integers beginning as follows:<br>1, 11, 21, 1211, 111221, …</p><p>1 is read off as”one 1”or11.<br>1 1is read off as”two 1s”or21.<br>2 1is read off as”one 2, thenone 1”or1211.</p><p>Given an integer <em>n</em>, generate the <em>n</em> <sup>th</sup> sequence.</p><p>Note: The sequence of integers will be represented as a string.</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>题意是：<br>n=1时输出字符串1；<br>n=2时，数上次字符串中的数值个数，因为上次字符串有1个1，所以输出11；<br>n=3时，由于上次字符是11，有2个1，所以输出21；<br>n=4时，由于上次字符串是21，有1个2和1个1，所以输出1211</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>就每次计算一下pre_out中各个数字的个数，然后储存到新的cur_out中就好了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">help_fun</span><span class="params">(<span class="built_in">string</span> pre_out)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> cur_out = <span class="string">"1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出第n个结果，就是说要计数到第n个</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每次用当前的cur_out计算的下一次的cur_out</span></span><br><span class="line">        cur_out = help_fun(cur_out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur_out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">help_fun</span><span class="params">(<span class="built_in">string</span> pre_out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> cur_out = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">// 用前一次的pre_out计数当前的cur_out</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pre_out.<span class="built_in">size</span>(); )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = pre_out[i]; <span class="comment">// 一个新的数字字符</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="comment">// 是当前数字字符就让j++</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;pre_out.<span class="built_in">size</span>() &amp;&amp; pre_out[j]==c)</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数当前数字字符</span></span><br><span class="line">        cur_out += (<span class="keyword">char</span>)(<span class="string">'0'</span> + (j - i)); <span class="comment">// 保存数字字符个数</span></span><br><span class="line">        cur_out += c; <span class="comment">// 保存数字字符</span></span><br><span class="line">        i = j; <span class="comment">// 更新下标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cur_out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入："</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"输出："</span>&lt;&lt;countAndSay(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-a9f452803e2921fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swap nodes in pairs（成对的交换链表结点）</title>
      <link href="/2019/01/05/swap-nodes-in-pairs%EF%BC%88%E6%88%90%E5%AF%B9%E7%9A%84%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%EF%BC%89/"/>
      <url>/2019/01/05/swap-nodes-in-pairs%EF%BC%88%E6%88%90%E5%AF%B9%E7%9A%84%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a linked list, swap every two adjacent nodes and return its head.<br>For example,<br>Given1-&gt;2-&gt;3-&gt;4, you should return the list as2-&gt;1-&gt;4-&gt;3.<br>Your algorithm should use only constant space. You may <strong>not</strong> modify the values in the list, only nodes itself can be changed.</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个链表，交换每两个相邻的链表结点。<br>不能修改结点值，只改变链表指向。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先是递归思路，在递归过程中，判断结点的情况，共有三种情况：<br>（1）当前结点为NULL，或者当前结点是落单的结点；<br>（2）正好剩下最后一对结点；<br>（3）还剩至少三个以上的结点。<br>针对第一种情况，直接返回该结点给上一层递归调用的地方；<br>针对第二种情况，就直接交换指向，然后把当前的第一个结点返回；<br>针对第三种情况，交换结点指向，并且，递归判断下面的结点。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ListNode* node;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">swapPairs</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当前结点是NULL</span></span><br><span class="line">    <span class="comment">// 或者当前结点落单了，没有与之成对的结点</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前的结点是最后一对结点，再往下是NULL</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(head-&gt;next-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node tmp_node = head-&gt;next;</span><br><span class="line">        tmp_node-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 把原先的第一个结点的指向置为NULL</span></span><br><span class="line">        <span class="keyword">return</span> tmp_node; <span class="comment">// 返回当前的第一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还有至少三个及以上的结点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        node tmp_node = head-&gt;next;</span><br><span class="line">        node new_node = tmp_node-&gt;next;</span><br><span class="line">        tmp_node-&gt;next = head;</span><br><span class="line">        head-&gt;next = swapPairs(new_node); <span class="comment">// 继续向后递归</span></span><br><span class="line">        <span class="keyword">return</span> tmp_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Symmetric Tree（对称树）</title>
      <link href="/2019/01/05/Symmetric-Tree%EF%BC%88%E5%AF%B9%E7%A7%B0%E6%A0%91%EF%BC%89/"/>
      <url>/2019/01/05/Symmetric-Tree%EF%BC%88%E5%AF%B9%E7%A7%B0%E6%A0%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).<br>For example, this binary tree is symmetric:</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-d9b6796319d21653.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><a id="more"></a><p>But the following is not:</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-696113bf1270c389.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>Note:</strong><br>Bonus points if you could solve it both recursively and iteratively.<br>confused what”{1,#,2,3}”means? <a href="#">&gt; read more on how binary tree is serialized on OJ.</a><br><strong>OJ’s Binary Tree Serialization:</strong><br>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.<br>Here’s an example:</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-4ab3a6c66dda04b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>The above binary tree is serialized as”{1,2,3,#,#,4,#,#,5}”.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>判断一棵树是否是对称树。</p><p>要注意，对称树是一棵树的左右子树互为镜面；<br>所以是左子树的左孩子==右子树的右孩子。<br>这点要区别于相等树。</p><p><a href="https://www.jianshu.com/p/afa131dce9ef" target="_blank" rel="noopener">相等二叉树</a>：左子树的左孩子==右子树的左孩子</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>可以用递归也可以把递归改成非递归（所有的递归都可以改写成非递归的形式）。</p><p>不管递归还是非递归，判断条件都是一样的，<br>（1）首先判断当前结点是否为NULL，如果都为NULL，显然是相等的，<br>（2）如果不是两棵树的当前结点都为NULL，其中有一个为NULL，那么两棵树必不相等，<br>（3）如果两棵树的两个结点的值不相等，那么两棵树必不相等。条件判断完后，说明当前结点相等且不为NULL。接下来就再判断当前结点的左右子树，在递归方法中，用递归手段去判断；在非递归方法中，将当前结点的左右孩子结点入队，在去循环判断。由此可见，递归、非递归，思想是一样的。<br>但是在入队的时候要注意，因为是判断是否是镜像树，所以一棵树以左右孩子子树的顺序入队，另一棵树要以右左孩子的顺序入队。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition for binary tree</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> help_fun(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">help_fun</span><span class="params">(TreeNode *root1, TreeNode *root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root1==<span class="literal">NULL</span> &amp;&amp; root2==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root1==<span class="literal">NULL</span> || root2==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root1-&gt;val != root2-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 注意：第一棵树的左孩子与第二颗树的右孩子比较</span></span><br><span class="line">    <span class="comment">// 第二颗树的右孩子与第一棵树的左孩子相比较</span></span><br><span class="line">    <span class="keyword">return</span> help_fun(root1-&gt;left, root2-&gt;right) &amp;&amp; help_fun(root1-&gt;right, root2-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition for binary tree</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> TreeNode* tree;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;tree&gt; q1, q2;</span><br><span class="line">    <span class="comment">// 把根结点的左右子树分别看成一棵树，判断这两棵树是否对称</span></span><br><span class="line">    q1.push(root-&gt;left);</span><br><span class="line">    q2.push(root-&gt;right);</span><br><span class="line">    <span class="keyword">while</span>(!q1.empty() &amp;&amp; !q2.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tree tmp1 = q1.front();</span><br><span class="line">        tree tmp2 = q2.front();</span><br><span class="line">        <span class="comment">// 记得出队</span></span><br><span class="line">        q1.pop(); q2.pop();</span><br><span class="line">        <span class="comment">// 当前结点都为NULL，就继续去比较队内其他结点</span></span><br><span class="line">        <span class="keyword">if</span>(tmp1==<span class="literal">NULL</span> &amp;&amp; tmp2==<span class="literal">NULL</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 只有一个结点为NULL，另一个结点非NULL，必不对称</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tmp1==<span class="literal">NULL</span> || tmp2==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 结点值不相等，必不对称</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tmp1-&gt;val != tmp2-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 前面三个判断条件都没有走，说明tmp1和tmp2都非NULL</span></span><br><span class="line">        <span class="comment">// 就把他们的左右孩子入队</span></span><br><span class="line">        <span class="comment">// 注意：第一个入队顺序为：1. 左 2. 右</span></span><br><span class="line">        q1.push(tmp1-&gt;left);</span><br><span class="line">        q1.push(tmp1-&gt;right);</span><br><span class="line">        <span class="comment">// 注意：第二个入队顺序为：1. 右 2. 左</span></span><br><span class="line">        q2.push(tmp2-&gt;right);</span><br><span class="line">        q2.push(tmp2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两个队列有一个非NULL，说明必不对称</span></span><br><span class="line">    <span class="keyword">if</span>(!q1.empty() || !q2.empty())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>permutations（全排列）</title>
      <link href="/2019/01/03/permutations%EF%BC%88%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%89/"/>
      <url>/2019/01/03/permutations%EF%BC%88%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a collection of numbers, return all possible permutations.<br>For example,<br>[1,2,3]have the following permutations:<br>[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2], and[3,2,1].</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个数组集合，返回所有可能的排列。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>给的提示是分治+递归。</p><p>分治：就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><p>由实例可以看出来，全排列是有规律可循的：<br>第一个排列是集合由小到大排列；<br>第二个交换了最后两个数字；<br>第三个交换了一二两个数字；<br>第四个是在第三个的基础上交换了二三两个数字；<br>… …</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permute_help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="keyword">if</span>(num.<span class="built_in">size</span>() == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    permute_help(res, num, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permute_help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == num.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt;num.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(num[i], num[index]);</span><br><span class="line">        permute_help(res, num, index+<span class="number">1</span>);</span><br><span class="line">        swap(num[i], num[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res = permute(num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;res[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; res[i][j]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-f217077dbd702288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>path sum（路径和）</title>
      <link href="/2019/01/02/path-sum%EF%BC%88%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%89/"/>
      <url>/2019/01/02/path-sum%EF%BC%88%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.<br>For example:<br>Given the below binary tree andsum = 22,</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-2afa6162e511a6df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><a id="more"></a><p>return true, as there exist a root-to-leaf path5-&gt;4-&gt;11-&gt;2which sum is 22.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个二叉树和一个sum值，看看是否有一条从根到叶子结点的路径，使得这条路径上各个结点的值相加刚好等于sum。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>递归思路求解，递归每条路径，看是否有一条路径之和刚好等于sum。</p><p>递归出口是：<br>（1）返回为true：当前结点刚好是叶子结点&amp;&amp;sum-当前结点的值为0。<br>（2）返回为false：root == NULL。</p><p>避坑：sum和各个结点值有可能是负数；</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition for binary tree</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> TreeNode* tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode *root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证该店是叶子结点且加到这儿的和为sum</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val==sum &amp;&amp; root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree t = <span class="keyword">new</span> TreeNode(<span class="number">-2</span>);</span><br><span class="line">    t-&gt;left = <span class="keyword">new</span> TreeNode(<span class="number">-3</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;hasPathSum(t, <span class="number">-5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;-5-(-2)&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>remove duplicates from sorted list（移除有序链表中的重复元素）</title>
      <link href="/2019/01/01/remove-duplicates-from-sorted-list%EF%BC%88%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%89/"/>
      <url>/2019/01/01/remove-duplicates-from-sorted-list%EF%BC%88%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p><p>For example,<br>Given1-&gt;1-&gt;2, return1-&gt;2.<br>Given1-&gt;1-&gt;2-&gt;3-&gt;3, return1-&gt;2-&gt;3.</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个有序链表，删除其中重复元素，仅剩下一个。<br>如例子所见。</p><h1 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>维护两个指针，前指针负责向后遍历，后指针负责连接不重复的元素。<br>注意delete操作，以防止内存泄漏。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> ListNode* list_node; <span class="comment">// 别名</span></span><br><span class="line"><span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    list_node p1 = head;</span><br><span class="line">    list_node p2 = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val == p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            p1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            list_node tmp = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p1-&gt;next = p2;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list_node p1, p2, p3, p4, p5;</span><br><span class="line"></span><br><span class="line">    p1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    p2 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    p3 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">    p4 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">    p5 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    p1-&gt;next = p2;</span><br><span class="line">    p2-&gt;next = p3;</span><br><span class="line">    p3-&gt;next = p4;</span><br><span class="line">    p4-&gt;next = p5;</span><br><span class="line"></span><br><span class="line">    p1 = deleteDuplicates(p1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p1-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-32551e414ee32240.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>思路跟第一种并无大的区别。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> ListNode* list_node; <span class="comment">// 别名</span></span><br><span class="line"><span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="keyword">return</span> head;</span><br><span class="line">    list_node cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            list_node tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h2><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-db07159a060f578e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构， 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Tree Level Order Traversal（二叉树层序遍历-保存并返回结果集）</title>
      <link href="/2018/12/30/Binary-Tree-Level-Order-Traversal%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-%E4%BF%9D%E5%AD%98%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%9B%86%EF%BC%89/"/>
      <url>/2018/12/30/Binary-Tree-Level-Order-Traversal%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-%E4%BF%9D%E5%AD%98%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%9B%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).<br>For example:<br>Given binary tree{3,9,20,#,#,15,7},</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-8069e9a71691ac7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><a id="more"></a><p>return its level order traversal as:</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-0d2d3515a84d26bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>confused what”{1,#,2,3}”means? <a href="#">&gt; read more on how binary tree is serialized on OJ.</a></p><p><strong>OJ’s Binary Tree Serialization:</strong></p><p>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.</p><p>Here’s an example:</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-e20a36cf0c9380ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>The above binary tree is serialized as”{1,2,3,#,#,4,#,#,5}”.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>层序遍历二叉树<br>把遍历结果保存在一个二维数组中<br>一层保存在二维数组的一行中</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>刚开始用的时候感觉vector不好用，现在越用感觉越好用<br>用队列实现二叉树的层序遍历<br>关键是定义两个指针，指向每一层的当前结点和最后一个结点<br>每当一层遍历完毕，层数加一，并且给vector二维数组增加新的一行。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    结构体定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    具体实现算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> TreeNode* tree;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">levelOrder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; &gt; vec; <span class="comment">// 定义二维数组，其中元素为int类型</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> vec;</span><br><span class="line">    <span class="built_in">queue</span>&lt;tree&gt; qu; <span class="comment">// 保存二叉树层序遍历结点的指针</span></span><br><span class="line">    qu.push(root);</span><br><span class="line">    tree now = root; <span class="comment">// 当前结点指针</span></span><br><span class="line">    tree last = root; <span class="comment">// 保存每层最后一个结点的指针</span></span><br><span class="line">    <span class="keyword">int</span> lev = <span class="number">0</span>; <span class="comment">// 保存层的序号</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vt; <span class="comment">// 二维数组的新一行</span></span><br><span class="line">    vec.push_back(vt); <span class="comment">// 给二维数组加一行</span></span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        now = qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line">        vec[lev].push_back(now-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span>)qu.push(now-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span>)qu.push(now-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(last==now &amp;&amp; !qu.empty())</span><br><span class="line">        &#123; <span class="comment">// 表示当前层已遍历完毕</span></span><br><span class="line">            lev++; <span class="comment">// 层数序号加一</span></span><br><span class="line">            last = qu.back(); <span class="comment">// last指向新的一层的最后一个元素</span></span><br><span class="line">            vec.push_back(vt); <span class="comment">// 给二维数组加一行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的层序遍历算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;tree &gt; qu;</span><br><span class="line">    qu.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tree now = qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;now-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;left != <span class="literal">NULL</span>)qu.push(now-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;right != <span class="literal">NULL</span>)qu.push(now-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree tr;</span><br><span class="line">    tr = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    tree t1;</span><br><span class="line">    t1 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    tr-&gt;left = t1;</span><br><span class="line"></span><br><span class="line">    tree t2;</span><br><span class="line">    t2 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    tr-&gt;right = t2;</span><br><span class="line"></span><br><span class="line">    tree t3;</span><br><span class="line">    t3 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">    t2-&gt;left = t3;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; &gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print(tr);</span></span><br><span class="line"></span><br><span class="line">    vec = levelOrder(tr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;vec[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;vec[i][j]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-b00ba9dbc0279b26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 二叉树层序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>n queens ii（n皇后问题2-只计数不保存）</title>
      <link href="/2018/12/29/n-queens-ii%EF%BC%88n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%982-%E5%8F%AA%E8%AE%A1%E6%95%B0%E4%B8%8D%E4%BF%9D%E5%AD%98%EF%BC%89/"/>
      <url>/2018/12/29/n-queens-ii%EF%BC%88n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%982-%E5%8F%AA%E8%AE%A1%E6%95%B0%E4%B8%8D%E4%BF%9D%E5%AD%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://yangyuanlin.club/2018/12/28/n-queens（n皇后问题）/#more" target="_blank" rel="noopener">n皇后问题（保存并返回所有的解决方案）</a></p></blockquote><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Follow up for N-Queens problem.<br>Now, instead outputting board configurations, return the total number of distinct solutions.</p><p><img data-src="http://upload-images.jianshu.io/upload_images/15108298-1bf68a71b367b0f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>著名n皇后问题。<br>n个皇后摆放在N x N的棋盘格中，使得横、竖和两个对角线方向均不会同时出现两个皇后。<br>只返回解决方案总数</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>n皇后问题当n大于等于4才有讨论意义，而且不只有一个解决方案；<br>用递归的方法找到每一种解决方案；<br>在当前解决方案中，遍历每一行的每一列查找可以放置皇后的位置；<br>在当前行中，遍历每一列的每一个位置，假设当前位置可以放，然后进行合法性判断，合法则放置；<br>然后再递归判断下一行；<br>递归结束后，将当前行当前列的位置回溯，置为未放状态，再接着判断当前行下一列，目的是为了找到所有的解决方案。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    函数声明</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// n皇后问题解决函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 递归实现深度优先搜索寻找解决方案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span> &gt; &amp;arr, <span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span> &amp;sum)</span></span>;</span><br><span class="line"><span class="comment">// 判断当前arr[row][col]是否可以放一个皇后</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_valid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span> &gt; &amp;arr, <span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    n：n皇后问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span> &gt; <span class="title">arr</span><span class="params">(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>))</span></span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    dfs(arr, n, <span class="number">0</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    arr：用这个数组保存得到的n皇后问题的当前解决方案</span></span><br><span class="line"><span class="comment">    n：n皇后问题</span></span><br><span class="line"><span class="comment">    row：递归寻找当前行的皇后放在哪一列</span></span><br><span class="line"><span class="comment">    sum：总的解决方案数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span> &gt; &amp;arr, <span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span> &amp;sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row == n)</span><br><span class="line">    &#123;</span><br><span class="line">        sum++; <span class="comment">// 解决方案数加一</span></span><br><span class="line">        <span class="comment">/* 输出解决方案</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;n; i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for(int j=0; j&lt;n; j++)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                cout&lt;&lt;arr[i][j]&lt;&lt;' ';</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断是否可以在arr[row][i]放一个皇后</span></span><br><span class="line">        <span class="keyword">if</span>(is_valid(arr, n, row, i))</span><br><span class="line">        &#123;</span><br><span class="line">            arr[row][i] = <span class="string">'Q'</span>;</span><br><span class="line">            dfs(arr, n, row+<span class="number">1</span>, sum); <span class="comment">// 递归判断下一列</span></span><br><span class="line">            arr[row][i] = <span class="string">'.'</span>; <span class="comment">// 回溯判断下一列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    arr：用这个数组保存得到的n皇后问题的当前解决方案</span></span><br><span class="line"><span class="comment">    n：n皇后问题</span></span><br><span class="line"><span class="comment">    row、col：当前判断的是第row行、第col列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_valid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span> &gt; &amp;arr, <span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i][col] == <span class="string">'Q'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查对角线</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=row<span class="number">-1</span>,j=col<span class="number">-1</span>; i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>; i--,j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查副对角线</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=row<span class="number">-1</span>,j=col+<span class="number">1</span>; i&gt;=<span class="number">0</span>&amp;&amp;j&lt;n; i--,j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入皇后的个数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">"皇后问题共有 "</span> &lt;&lt; totalNQueens(n) &lt;&lt; <span class="string">" 种解决方案。"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-b8eb71bee1d4f1a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> n皇后问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>n queens（n皇后问题）</title>
      <link href="/2018/12/28/n-queens%EF%BC%88n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%EF%BC%89/"/>
      <url>/2018/12/28/n-queens%EF%BC%88n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://localhost:4000/2018/12/29/n-queens-ii（n皇后问题2-只计数不保存）/#more" target="_blank" rel="noopener">n-queens-ii（n皇后问题2-只计数不保存）</a></p></blockquote><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>The <em>n</em> queens puzzle is the problem of placing <em>n</em> queens on an N x N chessboard such that no two queens attack each other.</p><p><img data-src="http://upload-images.jianshu.io/upload_images/15108298-5db7b3f2dae35578.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>Given an integer <em>n</em>, return all distinct solutions to the <em>n</em>-queens puzzle.<br>Each solution contains a distinct board configuration of the <em>n</em>-queens’ placement, where’Q’and’.’both indicate a queen and an empty space respectively.</p><a id="more"></a><p>For example,</p><p>There exist two distinct solutions to the 4-queens puzzle:</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-206b2946aae8b9a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>著名n皇后问题。<br>n个皇后摆放在 N x N 的棋盘格中，使得横、竖和两个对角线方向均不会同时出现两个皇后。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>n皇后问题当n大于等于4才有讨论意义，而且不只有一个解决方案；<br>用<strong>递归</strong>的方法找到每一种解决方案；<br>在当前解决方案中，遍历每一行的每一列查找可以放置皇后的<strong>位置</strong>；<br>在当前行中，遍历每一列的每一个位置，假设当前位置可以放，然后进行合法性判断，合法则放置；<br>然后再递归判断下一行；<br>递归结束后，将当前行当前列的位置回溯，置为未放状态，再接着判断当前行下一列，目的是为了找到所有的解决方案。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    函数声明</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解决方案函数</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span> &gt; &gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 用深度优先搜索的递归实现进行查找解决方案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span> &gt; &gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span> &gt; &amp;cur, <span class="keyword">int</span> &amp;n, <span class="keyword">int</span> row)</span></span>;</span><br><span class="line"><span class="comment">// 判断是否可以在当前的row行col列进行放置的合法性</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;cur, <span class="keyword">int</span> &amp;n, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span> &gt; &gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决方案结果集</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span> &gt; &gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化棋盘，所有的位置都没有摆放皇后</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">cur</span><span class="params">(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>))</span></span>;</span><br><span class="line">    dfs(res, cur, n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    res：返回的解决方案集</span></span><br><span class="line"><span class="comment">    cur：当前的一个解决方案</span></span><br><span class="line"><span class="comment">    n：n皇后问题</span></span><br><span class="line"><span class="comment">    row：当前解决方案的第row行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span> &gt; &gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;cur, <span class="keyword">int</span> &amp;n, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当超出行数超出了棋盘，则把这次搜索的结果放入res中。</span></span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        res.push_back(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断在row行j列处是否可以放一个皇后</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(cur, n, row, j)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果可以，则放一个皇后在（row，j）</span></span><br><span class="line">            cur[row][j] = <span class="string">'Q'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 继续在下一行找一个位置放皇后</span></span><br><span class="line">            dfs(res, cur, n, row + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为需要找到所有可能的情况，所以必然需要对每一行进行回退。</span></span><br><span class="line">            <span class="comment">// 去判断这一行的下一列是否可以放皇后。</span></span><br><span class="line">            cur[row][j] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    cur：当前解决方案</span></span><br><span class="line"><span class="comment">    n：n皇后问题</span></span><br><span class="line"><span class="comment">    row：考虑当前解决方案的第row行</span></span><br><span class="line"><span class="comment">    col：考虑当前解决方案的第col行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;cur, <span class="keyword">int</span> &amp;n, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur[i][col] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查反斜线（\）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur[i][j] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查斜线（/）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur[i][j] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span> &gt; &gt; res = solveNQueens(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;res[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;res[i][j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-3eaa12c15bb8a76c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> n皇后问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set Matrix Zeroes（矩阵置0）</title>
      <link href="/2018/12/25/Set-Matrix-Zeroes%EF%BC%88%E7%9F%A9%E9%98%B5%E7%BD%AE0%EF%BC%89/"/>
      <url>/2018/12/25/Set-Matrix-Zeroes%EF%BC%88%E7%9F%A9%E9%98%B5%E7%BD%AE0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><ul><li>Set Matrix Zeroes</li></ul><p>Given a <em>m</em> x <em>n</em> matrix, if an element is 0, set its entire row and column to 0. Do it in place.<br><strong>Follow up:</strong><br>Did you use extra space?<br>A straight forward solution using O(<em>m</em> <em>n</em>) space is probably a bad idea.<br>A simple improvement uses O(<em>m</em> + <em>n</em>) space, but still not the best solution.<br>Could you devise a constant space solution?</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>题目的意思就是，给定一个矩阵，如果矩阵中某个位置的数是0，就把该位置所在的行和列全部置为0。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>使用第一行和第一列来记录行和列的置0情况（例如matrix[2][3]是0，就把matrix[0][3]和matrix[2][0]置为0）。</p><p>首先，遍历第一行和第一列，看是否原先就有0，用两个bool变量来标识，如果原先就有0，最后要把有0的第一行或者第一列置为0。</p><p>然后，用第一行和第一列来记录行和列的置0情况，为什么能这样做呢，因为假如matrix[i][j]为0，最终总要把matrix[i][0]和matrix[0][j]置为0。</p><p>然后，遍历这个二维数组，如果发现matrix[i][0]<strong>或者</strong>matrix[0][j]为0，就把matrix[i][j]置为0。</p><p>这样的做法只需要两个额外变量（即，来标识第一行或者第一列是否有0的两个bool值），所以空间复杂度是O(1)。<br>时间上需要进行两次扫描，一次确定行列置0情况，一次对矩阵进行实际的置0操作，所以总的时间复杂度是O(m*n)</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>(); <span class="comment">// 行数</span></span><br><span class="line">    <span class="keyword">if</span>(rows == <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>(); <span class="comment">// 列数</span></span><br><span class="line">    <span class="keyword">if</span>(cols == <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> r0 = <span class="literal">false</span>; <span class="comment">// 标识第一行是否有0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cols; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[<span class="number">0</span>][i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;0&lt;&lt;' '&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">            r0 = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> c0 = <span class="literal">false</span>; <span class="comment">// 标识第一列是否有0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;' '&lt;&lt;0&lt;&lt;endl;</span></span><br><span class="line">            c0 = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用第一行第一列来记录0的情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将存在0的所在的行和列都置为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>]==<span class="number">0</span> || matrix[<span class="number">0</span>][j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若第一行有0，就把第一行全部置为0</span></span><br><span class="line">    <span class="keyword">if</span>(r0 == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// r0==true，说明第一行有0，每行有cols列，所以循环cols次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cols; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若第一列有0，就把第一列全部置为0</span></span><br><span class="line">    <span class="keyword">if</span>(c0 == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// c0==true，说明第一列有0，每行有rows列，所以循环rows次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>&#125;,</span><br><span class="line">        &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; &gt; <span class="title">matrix</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix[i].push_back(a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setZeroes(matrix);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;matrix[i][j]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-8958d36d719282fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jump-Game</title>
      <link href="/2018/12/24/Jump-Game/"/>
      <url>/2018/12/24/Jump-Game/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><ul><li>Jump Game</li></ul><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.<br>Each element in the array represents your maximum jump length at that position.<br>Determine if you are able to reach the last index.<br>For example:<br>A =[2,3,1,1,4], return true.<br>A =[3,2,1,0,4], returnfalse.</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个非负整数数组，最初的位置是该数组的第一个索引位置。<br>数组中的每个元素值表示该位置的最大跳跃长度。<br>确定是否能够达到最后一个索引位置。<br>例如：<br>a=[2，3，1，1，4]，返回 true。<br>A=[3，2，1，0，4]，返回 false。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>定义一个max_reach变量，表示最大能够达到的位置，然后遍历数组元素，每次到达一个索引位置后，判断大年索引位置加上当前索引位置的元素的值A[ i ] + i是否大于max_reach，如果大于就更新max_reach的值。<br>数组元素遍历的一个条件是<code>max_reach &gt;= i</code>，表示此时能够调到<em>i</em>处。<br>最后判断，<code>max_reach &gt;= n-1</code>表示能够调到最后一个位置。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_reach = <span class="number">0</span>; <span class="comment">// max标记能跳到的最远处</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// max_reach&gt;=i表示此时能跳到i处,</span></span><br><span class="line">    <span class="comment">// 0&lt;=i&lt;n表示扫描所有能到达的点，在改点处能跳到的最远处</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n &amp;&amp; max_reach&gt;=i; i++)</span><br><span class="line">        <span class="keyword">if</span>(max_reach &lt; A[i]+i)max_reach = A[i]+i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最后跳的最远的结果大于等于n-1，</span></span><br><span class="line">    <span class="comment">// 那么满足能跳到最后。</span></span><br><span class="line">    <span class="keyword">if</span>(max_reach &lt; n<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(canJump(A, <span class="number">5</span>))</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"true"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> B[] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(canJump(B, <span class="number">5</span>))</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"true"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-6f46f315304be612.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>以上。</p></blockquote><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找第一个丢失的正数</title>
      <link href="/2018/12/23/%E5%AF%BB%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B0/"/>
      <url>/2018/12/23/%E5%AF%BB%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><ul><li>First Missing Positive</li></ul><p>Given an unsorted integer array, find the first missing positive integer.<br>For example,<br>Given[1,2,0]return3,<br>and[3,4,-1,1]return2.<br>Your algorithm should run in O(n) time and uses constant space.</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>把正数n放在第n-1个位置上，这样从第一个位置开始，如果位置上的数不等于位置号，那么就是第一个缺失的正数。<br>while 是把数字一直换到正确的位置上为止。<br>对于每个数 A[ i ] 调整到 i - 1 位置，当然调整后还要接着判断。<br>最后从头扫一遍，发现第一个A[ i ] != i+1位置的就返回 i+1；<br>while 先判断前面语句，前者不满足并不读取后面的语句。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 把数字一直换到正确的位置上为止</span></span><br><span class="line">        <span class="keyword">while</span>(A[i]&gt;<span class="number">0</span> &amp;&amp; A[i]&lt;n &amp;&amp; A[i]!=A[A[i]<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(A[i], A[A[i]<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后从头扫一遍，发现第一个A[ i ] != i+1位置的就返回 i+1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[j] != j+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; firstMissingPositive(A, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> B[] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; firstMissingPositive(B, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上。</li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>截留雨水</title>
      <link href="/2018/12/23/%E6%88%AA%E7%95%99%E9%9B%A8%E6%B0%B4/"/>
      <url>/2018/12/23/%E6%88%AA%E7%95%99%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<ul><li>类似问题：<a href="https://www.jianshu.com/p/0f0319c3be12" target="_blank" rel="noopener">容器最大容水量</a></li></ul><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br>For example,<br>Given[0,1,0,2,1,0,1,3,2,1,2,1], return6.</p><p><img data-src="http://upload-images.jianshu.io/upload_images/15108298-a11344caa3d8ab5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks <strong>Marcos</strong> for contributing this image!</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定n个非负整数，表示每根杆的宽度为1的高程图，计算雨后它能收集多少水。<br>例如：给定[0，1，0，2，1，0，1，3，2，1，2，1]，返回6。<br>上述高程图由数组[0，1，0，2，1，0，1，3，2，1，2，1]表示。在这种情况下，有6个单位的雨水(蓝色部分)被困住了。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>两种思路。<br>第一种：<br>两次遍历，空间复杂度为O(1)，时间复杂度为O(2n)。<br>先进行一次遍历，找到数组中的最大值（不是最大值的下标）maxhigh，然后分别进行从两边到maxhigh这个值的位置的遍历，以左边为例，因为已经找到了最大值，从左边第一个值记为left开始向右边进行遍历，当右边的值比左边的值小时，说明形成高度差，该高度差可以截留雨水，如果left右边的值A[i]大于left，就更新left值，将A[i]记为left。<br>第二种：<br>只需遍历一遍的解决方案，空间复杂度O(1)，时间复杂度为O(n)。<br>从数组两边向中间找，两边维护两个最大值，每次选较小的那个最大值，然后进行比较，看是否可以截留住雨水。<br>具体代码如下所示。<br><strong>代码解析</strong> 见 <strong>代码解析</strong>。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left_max = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> right_max = A[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = n<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(left_max &lt;= right_max)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += <span class="built_in">max</span>(<span class="number">0</span>, left_max-A[i]);</span><br><span class="line">            left_max = <span class="built_in">max</span>(left_max, A[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum += <span class="built_in">max</span>(<span class="number">0</span>, right_max-A[j]);</span><br><span class="line">            right_max = <span class="built_in">max</span>(right_max, A[j]);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; trap(A, <span class="number">12</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><p>首先选择A[0]和A[n-1]作为两边的最大值分别为：left_max和right_max，<br>然后从下标为1和n-2的位置分别记为A[ i ]和A[ j ]向中间进行遍历，<br>每次选择左右较小的那个max值（因为这样的话可以保证如果存在高度差则一定可以截留住雨水），<br>例如，如果left_max比较小，那么就与A[j]，进行比较，<br>如果left_max - A[j]的值为正数，就说明可以截留住雨水，<br>如果left_max - A[j]的值为负数，说明不能截留住雨水，并且当前left_max值已经不是最大值，就更新left_max = A[j]。</p><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-e4d6f7772e13f3fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/672/format/webp" alt></p><ul><li>以上。</li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>荷兰国旗问题（颜色排序问题）</title>
      <link href="/2018/12/21/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98%EF%BC%88%E9%A2%9C%E8%89%B2%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%EF%BC%89/"/>
      <url>/2018/12/21/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98%EF%BC%88%E9%A2%9C%E8%89%B2%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><ul><li>Sort Colors</li></ul><p>Given an array with <em>n</em> objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.<br>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.<br><strong>Note:</strong><br>You are not suppose to use the library’s sort function for this problem.<br><a href="https://www.nowcoder.com/practice/4345e55fdb03498a89a97ec18e62b3ab?tpId=46&tqId=29103&tPage=2&rp=2&ru=/ta/leetcode&qru=/ta/leetcode/question-ranking#" target="_blank" rel="noopener">click to show follow up.</a><br><strong>Follow up:</strong><br>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.<br>Could you come up with an one-pass algorithm using only constant space?</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个有n个对象的数组，数组中有三种颜色，红色、白色和蓝色，对他们进行排序，相同颜色的在一起，排序顺序是（1）红色、（2）白色、（3）蓝色。数组是int类型的数组，在数组中用0表示红色，1表示白色，2表示蓝色。<br>必能用库排序函数。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目中给出了一种思路是，遍历两次数组，第一次遍历统计其中0、1、2的个数，第二次遍历把数组中的值按照0、1、2的个数重新覆盖。<br>但这种方法不可取，用只用一次遍历的做法来做。<br>问题就成了荷兰国旗问题：</p><ul><li>”荷兰国旗难题“问题描述</li></ul><p>”荷兰国旗难题“是计算机科学中的一个程序难题，它是由Edsger Dijkstra提出的。荷兰国旗是由红、白、蓝三色组成的。</p><p><img data-src="http://upload-images.jianshu.io/upload_images/15108298-099d9a441adb5631.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>现在有若干个红、白、蓝三种颜色的球随机排列成一条直线。现在我们的任务是把这些球按照红、白、蓝排序。</p><p>我的思路如下：<br>设置3个变量，分别代表数组前部zeroindex，当前遍历的位置 i，数组后部 twoindex<br>（1）当A[i] = 0时，必然属于数组前部，则交换A[i] 和 A[zeroindex] ,接着i++ , zeroindex++<br>（2）当A[i] = 1时，只需i++就好，因为只有排好了0和2,1自然就只能在中间了，故不作处理<br>（3）当A[i] = 2时，不然属于数组后部，则交换A[i]和A[twoindex]，接着twoindex–，不过此时就不能i++了，因为，交换过去的A[i]有可能是0或者2，所以需要在下一个循环里判断，这样它的位置才能够正确。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(current &lt;= <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[current] &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(A[current++], A[start++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[current] &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 交换过去的current有可能是0或者2</span></span><br><span class="line">            <span class="comment">// 所以得在下次循环判断</span></span><br><span class="line">            swap(A[current], A[<span class="built_in">end</span>--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            current++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    sortColors(A, <span class="number">18</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">18</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;A[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上。</p></blockquote><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从有序数组中移除相等的数值</title>
      <link href="/2018/12/19/%E4%BB%8E%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%A7%BB%E9%99%A4%E7%9B%B8%E7%AD%89%E7%9A%84%E6%95%B0%E5%80%BC/"/>
      <url>/2018/12/19/%E4%BB%8E%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%A7%BB%E9%99%A4%E7%9B%B8%E7%AD%89%E7%9A%84%E6%95%B0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><ul><li>Remove Duplicates From Sorted Array</li></ul><p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.<br>Do not allocate extra space for another array, you must do this in place with constant memory.<br>For example,<br>Given input array A =[1,1,2],<br>Your function should return length =2, and A is now[1,2].</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个有序数组，移除其中相等的值，并将移除后的数组长度返回。如例子所示。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>最笨的办法就是挨个比较，每次发现了相等的数，就把后边的数都前移一位。<br>这里用的办法是：维护两个指针，第一个指针记录不相同的数值，第二个指针挨个向后遍历，不相同就用第一个指针记录下来。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="literal">NULL</span> || n&lt;<span class="number">1</span>)<span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// count记录不重复元素的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] != A[i<span class="number">-1</span>]) <span class="comment">// 相等就跳过</span></span><br><span class="line">            A[count++] = A[i]; <span class="comment">// 不相等就留下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上。</li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式02之工厂方法模式</title>
      <link href="/2018/12/18/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F02%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/12/18/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F02%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li><p>简单工厂模式实现了生成产品类的代码与客户端代码分离，在工厂类中可以添加生成产品的逻辑代码。</p></li><li><p>但是简单工厂模式不符合“开放-封闭”原则。例如要加一个 <strong>新产品类</strong>，就要修改 <strong>工厂类</strong> 生成产品的逻辑代码，增加<em>if-else</em>判断。对于这个问题，工厂方法模式可以解决。</p></li></ul><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>工厂方法模式</strong> 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。<strong>工厂方法模式</strong> 让类把实例化推迟到子类。</p><a id="more"></a><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-dc60439d9ec3f88a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>角色</li></ul><ol><li>抽象产品类 : Product</li><li>具体产品类 : ConcreteProductA 和 ConcreteProductB</li><li>抽象工厂类 : AbstractFactory</li><li>具体工厂类 : ConcreteFactoryA 和 ConcreteFactoryB</li></ol><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>还是以披萨店的披萨订单为例，用<strong>工厂方法模式</strong>来处理披萨店的订单。并且披萨店还开了加盟店，有<strong>纽约披萨店</strong>和<strong>芝加哥披萨店</strong>。</p><h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><ul><li>创建者类（抽象工厂类 + 具体工厂实现类）</li></ul><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-3aa7269e8be86ce7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>产品类（抽象产品类 + 具体产品实现类）</li></ul><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-1f7fac7818b8be0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li>抽象工厂类<code>PizzaStore</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.factoryMethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">pizza = createPizza(type);</span><br><span class="line"></span><br><span class="line">pizza.prepare();</span><br><span class="line">pizza.bake();</span><br><span class="line">pizza.cut();</span><br><span class="line">pizza.box();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象的工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体工厂实现类1 <code>NYPizzaStore</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.factoryMethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYStylePizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(type.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> NYStyleCheesePizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"prpperoni"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> NYStylePepperoniPizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"clam"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> NYStyleClamPizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"veggie"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> NYStyleVeggiePizza();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体工厂实现类2 <code>ChicagoPizzaStore</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.factoryMethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoStylePizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function">Pizza <span class="title">createPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(type.equals(<span class="string">"cheese"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> ChicagoStyleCheesePizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"prpperoni"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> ChicagoStylePepperoniPizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"clam"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> ChicagoStyleClamPizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"veggie"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> ChicagoStyleVeggiePizza();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>抽象产品类<code>Pizza</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.factoryMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 抽象类提供了默认基本做法， 准备工作以特定顺序进行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String name;</span><br><span class="line">String dough;</span><br><span class="line">String sauce;</span><br><span class="line">ArrayList toppings = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Preparing "</span> + name);</span><br><span class="line">System.out.println(<span class="string">"Tossing dough..."</span>);</span><br><span class="line">System.out.println(<span class="string">"Adding sauce..."</span>);</span><br><span class="line">System.out.println(<span class="string">"Adding toppings: "</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toppings.size(); i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"   "</span> + toppings.get(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Bake for 25 minutes at 350"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Cutting the pizza into diagonal slices"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Place pizza in official PizzaStore box"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体产品实现类1 <code>NYStyleCheesePizza</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.factoryMethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYStyleCheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 具体产品实现类中可以加入自己的特色，或者覆盖Pizza类中的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NYStyleCheesePizza</span><span class="params">()</span></span>&#123;</span><br><span class="line">name = <span class="string">"NY Style Sauce and Cheese Pizza"</span>;</span><br><span class="line">dough = <span class="string">"Thin Crust Dough"</span>;</span><br><span class="line">sauce = <span class="string">"Marinara Sauce"</span>;</span><br><span class="line"></span><br><span class="line">toppings.add(<span class="string">"Grated Reggiano Cheese"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体产品实现类2 <code>NYStylePepperoniPizza</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.factoryMethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYStylePepperoniPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体产品实现类3 <code>NYStyleClamPizza</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.factoryMethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYStyleClamPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体产品实现类4 <code>NYStyleVeggiePizza</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.factoryMethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYStyleVeggiePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体产品实现类5 <code>ChicagoStyleCheesePizza</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.factoryMethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoStyleCheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 具体产品实现类中可以加入自己的特色，或者覆盖Pizza类中的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ChicagoStyleCheesePizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">name = <span class="string">""</span>;</span><br><span class="line">dough = <span class="string">""</span>;</span><br><span class="line">sauce = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">toppings.add(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Cutting the pizza into square slices"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体产品实现类6 <code>ChicagoStylePepperoniPizza</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.factoryMethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoStylePepperoniPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体产品实现类7 <code>ChicagoStyleClamPizza</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.factoryMethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoStyleClamPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体产品实现类8 <code>ChicagoStyleVeggiePizza</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.factoryMethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoStyleVeggiePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类 <code>PizzaTestDrive</code></li></ul><p>顾客Ethan想要纽约风格的奶酪披萨，顾客Joel想要芝加哥风格的奶酪披萨。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.factoryMethod;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaTestDrive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立两个不同的披萨店</span></span><br><span class="line">PizzaStore nyStore = <span class="keyword">new</span> NYStylePizzaStore();</span><br><span class="line">PizzaStore chicagoStore = <span class="keyword">new</span> ChicagoStylePizzaStore();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顾客Ethan的订单</span></span><br><span class="line">Pizza pizza = nyStore.orderPizza(<span class="string">"cheese"</span>);</span><br><span class="line">System.out.println(<span class="string">"Ethan ordered a "</span> + pizza.getName() + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顾客Joel的订单</span></span><br><span class="line">pizza = chicagoStore.orderPizza(<span class="string">"cheese"</span>);</span><br><span class="line">System.out.println(<span class="string">"Joel ordered a "</span> + pizza.getName() + <span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Preparing NY Style Sauce and Cheese Pizza</span><br><span class="line">Tossing dough...</span><br><span class="line">Adding sauce...</span><br><span class="line">Adding toppings: </span><br><span class="line">   Grated Reggiano Cheese</span><br><span class="line">Bake for 25 minutes at 350</span><br><span class="line">Cutting the pizza into diagonal slices</span><br><span class="line">Place pizza in official PizzaStore box</span><br><span class="line">Ethan ordered a NY Style Sauce and Cheese Pizza</span><br><span class="line"></span><br><span class="line">Preparing Chicago Style Deep Dish Cheese Pizza</span><br><span class="line">Tossing dough...</span><br><span class="line">Adding sauce...</span><br><span class="line">Adding toppings: </span><br><span class="line">   Shredded Mozzarella Cheese</span><br><span class="line">Bake for 25 minutes at 350</span><br><span class="line">Cutting the pizza into square slices</span><br><span class="line">Place pizza in official PizzaStore box</span><br><span class="line">Joel ordered a Chicago Style Deep Dish Cheese Pizza</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol><li><p>工厂方法模式又称为工厂模式，也叫虚拟构造器（Virtual Constructor）模式或者多态工厂模式（Polymorphic Factory）。</p></li><li><p>在工厂方法模式中，父类负责定义创建对象的公共接口，而子类则负责生成具体的对象；<br> 这样做的目的是将类的实例化操作延迟到子类中完成；<br> 即由子类来决定究竟应该实例化（创建）哪一个类。</p></li><li><p>工厂方法模式包含四个角色：<br> （1）抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；<br> （2）具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；<br> （3）抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；<br> （4）具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。 </p></li><li><p>工厂方法模式是简单工厂模式的进一步抽象和推广。<br> 由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。<br> 在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。<br> 这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。 </p></li><li><p>工厂方法模式：<br> （1）主要优点：增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；<br> （2）缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。 </p></li><li><p>工厂方法模式适用情况包括：<br> （1）一个类不知道它所需要的对象的类；<br> （2）一个类通过其子类来指定创建哪个对象；<br> （3）将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 工厂模式 </tag>
            
            <tag> 工厂方法模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式01之简单工厂</title>
      <link href="/2018/12/18/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F01%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/"/>
      <url>/2018/12/18/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F01%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>简单工厂</strong>可以理解为，定义一个工厂类，根据传入的参数不同而返回不同的实例，这些实例通常有共同的父类。<br>虽然简单工厂经常会被使用，但是并不能算作是一种设计模式，反而更像是一种编程习惯。</p><a id="more"></a><h1 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h1><p>当我们创建产品类对象时，会使用到<code>new</code>操作符，但是代码绑着具体类的实例会导致代码更脆弱，更缺乏弹性。<br>实例化这个活动不应该总是公开的进行。<br>否则一旦有变化或扩展，就必须重新打开这段代码进行检查和修改。<br>我们的原则是：“找出会变化的方面，把他们从不变的部分分离出来”。<br>即让我们编写的代码符合<strong>开放-关闭原则</strong>。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>创建一个<code>factory</code>类，将创建产品类对象的代码放在<code>factory</code>类中，由<code>factory</code>类的对象专职创建产品类的对象。</p><h1 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h1><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-0815838574410c6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>工厂类 : Factory</li><li>抽象产品类 : Product</li><li>具体产品类 : ConcreteProductA 和 ConcreteProductB</li></ul><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>假设有一个披萨店，如果有了披萨订单，运用简单工厂处理披萨订单。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-743f1ac2e5e3ccff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><ul><li>抽象类<code>Pizza</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.simpleFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"prepare..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"bake..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"cut..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"box..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Pizza</code>类的实现类<code>CheesePizza</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.simpleFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Pizza</code>类的实现类<code>VeggiePizza</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.simpleFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VeggiePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Pizza</code>类的实现类<code>ClamPizza</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.simpleFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClamPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Pizza</code>类的实现类<code>PepperoniPizza</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.simpleFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PepperoniPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>简单工厂类<code>SimplePizzaFactory</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.simpleFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePizzaFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pizza <span class="title">creatPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO 所有客户用这个方法来实例化新对象</span></span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (type.equals(<span class="string">"Cheese"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"pepperoni"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> PepperoniPizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"clam"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> ClamPizza();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"veggie"</span>)) &#123;</span><br><span class="line">pizza = <span class="keyword">new</span> VeggiePizza();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户类<code>PizzaStore</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.nwpu.simpleFactory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SimplePizzaFactory factory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">PizzaStore(SimplePizzaFactory factory) &#123;</span><br><span class="line"><span class="keyword">this</span>.factory = factory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理披萨订单的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">pizza = factory.creatPizza(type);</span><br><span class="line"></span><br><span class="line">pizza.prepare(); <span class="comment">// 准备</span></span><br><span class="line">pizza.bake(); <span class="comment">// 烘烤</span></span><br><span class="line">pizza.cut(); <span class="comment">// 切片</span></span><br><span class="line">pizza.box(); <span class="comment">//装盒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>利用静态方法定义一个简单工厂，称为<strong>静态工厂</strong>，<strong>静态工厂</strong>不需要使用创建对象的方法来实例化对象，但是不能通过继承来改变创建对象的区别。</li><li>简单工厂的优点：实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责。</li><li>简单工厂的缺点：工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</li><li>在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</li><li>简单工厂模式包含三个角色：<br>（1）工厂角色：负责实现创建所有实例的内部逻辑；<br>（2）抽象产品角色：是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；<br>（3）具体产品角色：是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</li><li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li><li>简单工厂模式适用情况包括：<br>（1）工厂类负责创建的对象比较少；<br>（2）客户端只知道传入工厂类的参数，对于如何创建对象不关心。</li></ol><blockquote><p>参考：Head First设计模式</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 简单工厂 </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个顺序链表</title>
      <link href="/2018/12/17/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%A1%BA%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2018/12/17/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%A1%BA%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><ul><li>Merge Two Sorted Lists</li></ul><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>合并两个顺序排列的链表，并将新链表返回。新链表是把两个链表合并后的有序链表。</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>输入问题：考虑为空！</li><li>新链表的第一个结点问题，由于一般情况下第一个结点都需要特殊处理，比较实用的解决办法是在第一个结点前增加一个虚拟的头结点(例如下面的head)，把实际的第一个结点一般化。最后输出的时候输出这个虚拟结点的下一个结点就OK。</li><li>如何为新链表选择下一个结点（已经虚拟出第一个结点了），这个比较容易，比大小就OK了，取小的并并在此链表前进一步。</li><li>注意循环的终止条件！</li><li>终止后并没有结束！</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// l1、l2至少一个为空</span></span><br><span class="line">    <span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// (l1 &amp;&amp; !l2)为true表示l2为空，则返回l1，否则返回l2</span></span><br><span class="line">        <span class="comment">// 返回l2的情况：（1）l1为空，l2不空；（2）l1、l2都为空。</span></span><br><span class="line">        <span class="keyword">return</span> l1 &amp;&amp; !l2 ? l1 : l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode *head = result;</span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// l1或者l2不为空</span></span><br><span class="line">    <span class="keyword">if</span>(l1 || l2)</span><br><span class="line">    &#123;</span><br><span class="line">        l1 ? (head-&gt;next=l1) : (head-&gt;next=l2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上。</p></blockquote><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树前序遍历（递归 + 非递归）</title>
      <link href="/2018/12/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2018/12/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li>Binary Tree Preorder Traversal</li></ul><p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.<br>For example:<br>Given binary tree{1,#,2,3},</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-34bbbf63f5fca08e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>return[1,2,3].<br><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一棵二叉树，实现二叉树的前序遍历。</p><h1 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a>递归思想</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>二叉树前序遍历的递归思想实现。顺序为：根 → 左 → 右。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 二叉树前序遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    help_fun(v, root);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 前序遍历顺序为：根 → 左 → 右</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help_fun</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    v.push_back(root-&gt;val); <span class="comment">// 保存根节点的值</span></span><br><span class="line">    help_fun(v, root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    help_fun(v, root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非递归思想"><a href="#非递归思想" class="headerlink" title="非递归思想"></a>非递归思想</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>非递归方法入栈的时候先压右子树，因为用的是栈，栈是后进先出，在循环中，先保存当前根结点，然后分别将当前结点的右、左结点入栈，出栈时先出左结点，这样就能继续遍历左结点的孩子结点。就实现了二叉树的前序遍历，即：根 → 左 → 右。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get</span>(root -&gt; val);<span class="comment">// 根</span></span><br><span class="line">inorder(root -&gt; left);<span class="comment">// 左子树</span></span><br><span class="line">inorder(root -&gt; right);<span class="comment">// 右子树</span></span><br></pre></td></tr></table></figure><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 模拟 根 → 左 → 右 遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; v;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode* &gt; s;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> v;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *cur;</span><br><span class="line">        cur = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        v.push_back(cur-&gt;val); <span class="comment">// 保存根节点</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            s.push(cur-&gt;right); <span class="comment">// 压入右结点</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            s.push(cur-&gt;left); <span class="comment">// 压入左结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上。</p></blockquote><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 树 </tag>
            
            <tag> 前序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java EE Web应用开发方法</title>
      <link href="/2018/12/16/Java-EE-Web%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/"/>
      <url>/2018/12/16/Java-EE-Web%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><ul><li>B/S编程模式简介</li><li>HTML和HTTP</li><li>动态web编程</li><li>初识Servlet &amp; JSP</li><li>MVC设计模式初步讨论</li></ul><a id="more"></a><h1 id="B-S编程模式简介"><a href="#B-S编程模式简介" class="headerlink" title="B/S编程模式简介"></a>B/S编程模式简介</h1><ul><li>Web服务器<ul><li>Web服务器接收客户端的请求并将结果返回客户端</li><li>结果：HTML页面、图片、文件、……<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-24aea5f10f6df1c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul></li><li>Web客户端<ul><li>Web客户端可以使用户向服务器提出请求，并向用户展现请求的结果</li><li>浏览器知道如何与服务器通信，并能够解释HTML代码并展现Web页。<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-edb09b6f852d8223.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul></li></ul><h1 id="HTML和HTTP"><a href="#HTML和HTTP" class="headerlink" title="HTML和HTTP"></a>HTML和HTTP</h1><ul><li>请求/响应方式<ul><li>HTML告诉浏览器怎样为用户显示内容</li><li>HTTP是客户端和浏览器在Web上通信的协议</li><li>服务器使用HTTP向客户端发送HTML</li></ul></li><li>HTML</li><li>HTTP<ul><li>基于TCP/IP协议</li><li>HTTP请求包括：HTTP方法（执行的动作）、访问的页面URL、表单参数</li><li>HTTP 1.1 method<ul><li>告诉服务器请求的类型，剩余的消息是如何被格式化的</li><li>GET, PUT, POST, TRACE, DELETE, OPTIONS, HEAD, CONNECT</li><li>GET<ul><li>是最简单的请求，它向服务器获取一个资源并将之发回</li><li>可以用HTTP GET向服务器发送少量的数据</li><li>一个GET例子<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-09e1d03e8e3fd0c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul></li></ul></li></ul></li><li>POST<ul><li>向服务器请求资源，同时可以发送一些表单数据</li><li>一个POST例子<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-fcba17ea76032e35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul></li><li>发送数据用POST不用GET的理由<ul><li>数据大小：GET中的字符量按服务器不同有限制</li><li>安全性：用GET发送的数据被附加到URL后面，任何人可以看到。不适于发送敏感数据</li></ul></li><li>HTTP响应包括：状态码（请求是否成功）、内容类型（text/picture/HTML,etc）、内容（实际的HTML, image, etc）<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-0ae52b99ca4d8299.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul><h1 id="动态web编程"><a href="#动态web编程" class="headerlink" title="动态web编程"></a>动态web编程</h1><ul><li>常见的两种动态Web需求<ul><li>动态内容</li><li>在服务器上储存数据</li></ul></li><li>基本原理<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-7c4561d9de005916.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul><h1 id="初识Servlet-amp-JSP"><a href="#初识Servlet-amp-JSP" class="headerlink" title="初识Servlet &amp; JSP"></a>初识Servlet &amp; JSP</h1><ul><li>First servlet, let’s do it！<ul><li>建立文件目录结构<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-f77049f12608dfa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>编写FirstServlet.java代码，并放到src目录中<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-cdd737772c582f24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>编写部署描述符文件web.xml，放在etc目录中<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-5ce84a6b34d39b69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><ul><li>每个web应用都有一个部署描述符文件（DD）</li><li>一个DD可以定义多个servlets</li><li><servlet-name>将<servlet>元素绑定到<servlet-mapping>元素</servlet-mapping></servlet></servlet-name></li><li><servlet-class>是Java类</servlet-class></li><li><url-pattern>是客户端用于请求servlet的名字</url-pattern></li></ul></li><li>编写部署描述符文件web.xml，放在etc目录中</li><li>在tomcat目录下建立目录树<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-bbc91cde5db25136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>在project1目录下，编译servlet<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-3ac1f053fd84598e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>拷贝FirstServlet.class至WEB-INF/classes拷贝web.xml至WEB-INF中</li><li>启动Tomcat</li><li>打开浏览器到如下网址：<a href="http://localhost:8080/ch1/Serv1" target="_blank" rel="noopener">http://localhost:8080/ch1/Serv1</a></li></ul></li><li>How to… if JSP<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-9c282702ab73dbb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-029c0a124a246f92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>Servlet container<ul><li>servlet没有main()方法，被容器控制</li><li>容器将HTTP请求和响应传给servlet，并调用servlet上的方法，如doPost()或doGet()</li><li>servlet容器提供的服务<ul><li>通信支持<ul><li>Servlet可以通过容器与web服务器通信</li><li>程序员不需自己建立ServerSocket，监听端口，创建流等</li></ul></li><li>寿命周期管理<ul><li>容器控制servlet的“生死”</li><li>容器负责加载类、实例化和初始化servlet、调用servlet方法、对servlet实例进行垃圾回收等工作</li></ul></li><li>多线程支持<ul><li>容器根据对servlet的请求，自动创建Java线程</li><li>开发者仍要处理线程安全问题</li></ul></li><li>声明式安全<ul><li>用XML部署描述符配置安全，无需硬编码</li></ul></li><li>JSP支持<ul><li>将JSP转化成Java代码<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-b186998b63d9dafb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-15386d4964402a70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul></li></ul></li></ul></li><li>The Code<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-3e2baab3b63934d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>容器怎样找到servlet<ul><li>Servlet——狡兔三窟<ul><li>客户端名：URL<br>……/register/registerMe</li><li>部署名：内部保密<br>EnrollServlet</li><li>真实名：文件<br>SignUpServlet.class</li></ul></li><li>Servlet映射机制提高了应用程序的柔性和安全性！</li><li>The DD<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-30a0ab7eb8f92dfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>DD的好处<ul><li>基本不需要修改经过测试的代码</li><li>可以利用DD优化应用程序性能，甚至不写任何代码</li><li>使应用程序能够适应不同的资源，如数据库，不需要重新编译和测试代码</li><li>使得维护动态安全性变得非常容易，如ACL和安全角色</li><li>可以让非程序员修改和部署web应用程序，而程序员关注更重要的事</li></ul></li></ul></li></ul><h1 id="MVC设计模式初步讨论"><a href="#MVC设计模式初步讨论" class="headerlink" title="MVC设计模式初步讨论"></a>MVC设计模式初步讨论</h1><ul><li>模式说明<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-d9b5af8edd745902.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>特点<ul><li>MVC将业务逻辑从servlet中分离，放到模型（Model）中。模型是可复用的POJO，是业务数据（如购物车状态）和操作这些数据的方法（规则）的组合。</li><li>多个视图可共享一个模型</li><li>控制器可以连接不同的模型与视图</li><li>增强了软件健壮性和复用性</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java EE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成括号</title>
      <link href="/2018/12/15/%E7%94%9F%E6%88%90%E6%8B%AC%E5%8F%B7/"/>
      <url>/2018/12/15/%E7%94%9F%E6%88%90%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul><li>Generate Parentheses</li></ul><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.<br>For example, given n = 3, a solution set is:<br>“((()))”, “(()())”, “(())()”, “()(())”, “()()()”</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定<strong>n</strong>对括号，编写一个函数来生成所有的符合格式的括号组合。<br>上面给出了<strong>n = 3</strong>的例子。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>用递归来做。<br>注意几点递归条件：<br>（1）左右括号均用完是递归出口；<br>（2）左括号没有用完就加一个左括号；<br>（3）只有右括号少于左括号且右括号没有用完时才能加右括号，因为不能出现<code>“ ）（ ”</code>这样的情况。</p><ul><li>关键：当前位置左括号不少于右括号；</li><li>节点：目前位置左括号和右括号数（x,y）(x&gt;=y)；</li><li>边：从（x,y)到（x+1,y）和（x，y+1），x==y时，没有（x,y+1）这条边；</li><li>解：是从(0,0)出发到(n,n)的全部路径。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help_fun</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span> &gt;&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span> &gt; v;</span><br><span class="line">    help_fun(n, n, <span class="string">""</span>, v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help_fun</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span> &gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">0</span>)</span><br><span class="line">        help_fun(x<span class="number">-1</span>, y, s+<span class="string">"("</span>, v);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;y &amp;&amp; y&gt;<span class="number">0</span>)</span><br><span class="line">        help_fun(x, y<span class="number">-1</span>, s+<span class="string">")"</span>, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="built_in">string</span> &gt; v;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    v = generateParenthesis(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上。</p></blockquote></li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 括号匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java EE架构概述</title>
      <link href="/2018/12/15/Java-EE%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/12/15/Java-EE%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><ul><li>分布式多层应用</li><li>Java EE容器</li><li>Web Service支持</li><li>打包应用</li><li>开发角色</li><li>Java EE APIs</li></ul><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><ul><li>Java Platform, Enterprise Edition(Java EE)为设计、开发、装配和部署企业应用程序提供了一个基于组件的方法</li><li>Java EE平台提供了：<ul><li>一个多层分布式应用模型</li><li>可复用组件模型</li><li>一个统一的安全模型</li><li>灵活的事务控制</li><li>Web Services</li></ul></li><li>通过Java EE平台，可以<ul><li>更快地构建创新的商业解决方案</li><li>基于Java EE组件的平台独立性，使开发的应用不依赖于特定厂商的产品和API</li><li>软件厂商和客户都能自由地选择符合其需求的产品和组件<h1 id="分布式多层应用"><a href="#分布式多层应用" class="headerlink" title="分布式多层应用"></a>分布式多层应用</h1></li></ul></li><li>应用逻辑按照功能分成若干组件，组成Java EE应用的各种应用组件按照多层Java EE环境中的层次结构，安装在不同的机器上。<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-37ecf42449e6059d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>安全<ul><li>在每个应用中使用平台无关的安全策略</li><li>允许在部署时定义安全约束</li><li>应用程序能够在多种安全实现上移植</li><li>对应用开发者屏蔽实现安全特性的复杂性</li><li>Java EE平台提供了标准的声明式访问控制规则，可由开发者定义并在应用部署到服务器时解释</li><li>Java EE提供了标准的登录机制，开发者可以不用重复开发</li></ul></li><li>Java EE组件<ul><li>A Java EE component is a self-contained functional software unit that is assembled into a Java EE application with its related classes and files and that communicates with other components.</li><li>Java EE规范定义了如下组件：<ul><li>应用客户端（application clients）和Applets是客户端运行的组件</li><li>Servlet和JSP组件是服务器上运行的web组件</li><li>Enterprise JavaBeans (EJB)组件是服务器上运行的业务组件</li></ul></li></ul></li><li>Java EE客户端<ul><li>Web客户端 → thin client<ul><li>动态Web页面：由Web层运行的web组件生成</li><li>Web浏览器：显示页面</li></ul></li><li>Applet</li><li>应用客户端 → richer user interface<ul><li>直接访问企业Beans</li><li>打开HTTP连接，与Web层的servlet通信</li></ul></li><li>JavaBeans组件</li><li>瘦客户端可提升应用的可分布性、可部署性和可管理性，而富客户端可获得良好的用户体验。</li></ul></li><li>服务器通信<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-1bfc26eb24a759c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>Web组件<ul><li>Servlet<ul><li>Servlets are Java programming language classes that<br>dynamically process requests and construct responses.</li></ul></li><li>JSP<ul><li>JSP pages are text-based documents that execute as servlets but allow a more natural approach to creating static content.</li></ul></li><li>JavaBeans (optional)</li></ul></li><li>业务组件<ul><li>Session beans<ul><li>A session bean represents a transient conversation with a client. When the client finishes executing, the session bean and its data are gone.</li></ul></li><li>Entity beans<ul><li>An entity bean represents persistent data stored in one row of a database table. If the client terminates or if the server shuts down, the underlying services ensure that the entity bean data is saved.</li></ul></li><li>Message-driven beans<ul><li>A message-driven bean combines features of a session bean and a Java Message Service (JMS) message listener, allowing a business component to receive JMS messages asynchronously.<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-8709606188619ff9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul></li></ul></li><li>EIS (Enterprise Information System) 层<ul><li>ERP</li><li>数据库系统</li><li>遗产系统</li><li>……<h1 id="Java-EE容器"><a href="#Java-EE容器" class="headerlink" title="Java EE容器"></a>Java EE容器</h1></li></ul></li><li>为什么需要容器？<ul><li>瘦客户端多层应用程序开发面临的难题<ul><li>事务管理</li><li>状态管理</li><li>多线程</li><li>资源池</li><li>其它复杂的底层细节</li></ul></li><li>Java EE服务器对所有类型的组件，以容器的形式提供了一组底层服务。开发者不需重复开发，而只需关注业务问题</li></ul></li><li>容器服务<ul><li>容器是一个组件和支持组件的底层平台特定功能之间的界面</li><li>Web组件、企业Bean、应用客户端组件必须组装成Java EE模块并部署于容器中才能执行</li><li>组装过程包括<ul><li>为Java EE应用中每个组件定义容器方面的设置</li><li>为Java EE应用本身定义设置项</li></ul></li></ul></li><li>容器管理的服务有<ul><li>可配置的服务<br><code>同一Java EE应用中的应用组件依照部署方式不同而表现出不同的行为</code><ul><li>安全服务</li><li>事务服务</li><li>JNDI查找服务</li><li>Java EE远程连接服务</li><li>……</li></ul></li><li>不可配置的服务<ul><li>企业Bean和Servlet寿命周期</li><li>数据库连接资源池</li><li>数据持久化</li><li>访问其它Java EE平台API</li></ul></li></ul></li><li>Java EE服务器和容器<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-b7c62b327f3b0df3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><h1 id="对Web-services的支持"><a href="#对Web-services的支持" class="headerlink" title="对Web services的支持"></a>对Web services的支持</h1></li><li>Web services是基于Web的企业应用，它使用开放的、基于XML的标准和传输协议与调用它的客户端进行数据交换</li><li>XML: 跨平台、可扩展、基于文本的描述数据的标准。<ul><li>自定义标签（tag）</li><li>用schema定义其格式</li><li>用XSL定义处理和展现数据的方式</li></ul></li><li>SOAP: 客户请求和web服务响应描述成SOAP消息<ul><li>信封: 消息中有什么？如何处理消息？</li><li>编码规则: 表示消息中的特定格式的数据实例</li><li>消息约定: 描述请求和响应的格式</li></ul></li><li>WSDL: 用XML格式描述网络服务<ul><li>服务名</li><li>服务位置</li><li>与服务通信的方式</li></ul></li><li>UDDI和ebXML: 在Internet上发布web服务信息的标准<h1 id="打包应用"><a href="#打包应用" class="headerlink" title="打包应用"></a>打包应用</h1></li><li>Java EE应用打包成EAR文件（Enterprise Archive），包括<ul><li>Java EE模块</li><li>部署描述符: 描述应用、模块或组件的部署设置<ul><li>Java EE部署描述符</li><li>运行时部署描述符<br>——应用服务器特定<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-8b67802de7333e93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul></li></ul></li><li>Java EE模块: 一个Java EE模块包括一或多个具有相同容器类型的Java EE组件，以及一个组件部署描述符<ul><li>EJB模块<ul><li>企业bean (class) + EJB部署描述符 → .jar</li></ul></li><li>Web模块<ul><li>Servlet (class) + JSP + 其它Class + HTML + 图片 + Web部署描述符 → .war</li></ul></li><li>应用客户端模块<ul><li>Java class + 应用客户端部署描述符 → .jar</li></ul></li><li>资源适配器模块<ul><li>Java interface, class, native libraries, and other documentation + 资源适配器部署描述符 → .rar<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-b66c1249343a472f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><h1 id="开发角色"><a href="#开发角色" class="headerlink" title="开发角色"></a>开发角色</h1></li></ul></li></ul></li><li>Java EE规范定义了如下角色<ul><li>Java EE Product Provider<ul><li>实现Java EE产品，提供容器、实现API及其它Java EE特性</li></ul></li><li>Tool Provider<ul><li>提供组件开发、组装和打包工具</li></ul></li><li>Application Component Provider<ul><li>构建Java EE应用中使用的Web组件、企业Bean、Applets，或应用客户端</li></ul></li><li>Application Assembler<ul><li>将应用模块组装成Java EE应用的EAR文件</li></ul></li><li>Application Deployer and Administrator<ul><li>配置和部署Java EE应用程序、管理计算和网络架构、监控运行环境<h1 id="Java-EE-APIs-1"><a href="#Java-EE-APIs-1" class="headerlink" title="Java EE APIs (1)"></a>Java EE APIs (1)</h1></li></ul></li></ul></li><li>Enterprise JavaBeans<ul><li>执行业务逻辑</li><li>三种企业bean<ul><li>Session beans</li><li>Entity beans (在Java EE 5中被Java persistence API entities取代)</li><li>Message-driven beans</li></ul></li></ul></li><li>Java Servlet</li><li>JavaServer Pages</li><li>JavaServer Pages Standard Tag Library (JSTL, new in Java EE 5)<ul><li>封装了对许多JSP应用来说通用的核心功能。</li><li>JSTL有迭代和条件Tag，可以处理流程控制；有处理XML文档的Tag；有用于国际化的Tag；有使用SQL访问数据库的Tag；及一些经常使用的功能。<h1 id="Java-EE-APIs-2"><a href="#Java-EE-APIs-2" class="headerlink" title="Java EE APIs (2)"></a>Java EE APIs (2)</h1></li></ul></li><li>JavaServer Face (JSF, new in Java EE 5)<ul><li>是一个创建Web应用的用户界面框架</li><li>主要组件包括<ul><li>一个GUI组件框架</li><li>用于在不同的HTML或各种标记语言和技术下渲染组件的柔性模型</li><li>一个用于生成HTML/4.01标记的标准RenderKit</li></ul></li></ul></li><li>Java Message Service (JMS)<ul><li>Java EE应用组件创建、发送、接收和读取消息的消息通信标准</li><li>支持分布式通信，具有松散耦合、可靠、异步的特征</li></ul></li><li>Java Transaction API (JTA)<ul><li>JTA提供了划分事务的标准接口，UserTransaction接口是核心</li><li>大多数情况下使用容器管理的事务，而不是JTA</li></ul></li><li>JavaMail API<ul><li>发送email通知的API</li><li>包括：一个应用级的接口；和一个服务提供者接口<h1 id="Java-EE-APIs-3"><a href="#Java-EE-APIs-3" class="headerlink" title="Java EE APIs (3)"></a>Java EE APIs (3)</h1></li></ul></li><li>JavaBeans Activation Framework (JAF)<ul><li>JavaMail使用它，如处理MIME编码的邮件附件；</li><li>确定任意数据片断的类型；</li><li>封装对其访问；</li><li>发现其可用操作；</li><li>创建可以执行这些操作的合适的JavaBean组件。</li></ul></li><li>Java API for XML Processing (JAXP)<ul><li>支持使用DOM、SAX和XSLT处理XML文档</li><li>支持使用任何XML兼容的解析器和XSL处理器</li><li>支持W3C XML Schema</li></ul></li><li>Java API for XML-Based RPC (JAX_RPC)<ul><li>使用SOAP标准和HTTP，可以在Internet上实现基于XML的远程过程调用</li><li>支持WSDL，可以输出和输入WSDL文档</li><li>可与运行在Java和非Java平台上的web服务客户端和服务器端实现互操作<h1 id="Java-EE-APIs-4"><a href="#Java-EE-APIs-4" class="headerlink" title="Java EE APIs (4)"></a>Java EE APIs (4)</h1></li></ul></li><li>Java API for XML Web Services (JAX_WS, new in Java EE 5)<ul><li>是JAX-RPC的升级</li><li>使用JAXB API绑定XML数据到Java对象</li><li>引入了面向消息的功能，支持异步编程模型</li><li>支持SOAP1.2</li><li>可直接使用 XML/HTTP 绑定 </li></ul></li><li>SOAP with Attachments API for Java (SAAJ)<ul><li>是一个底层API</li><li>允许生成和使用符合SOAP1.1和SOAP附件规范的消息</li><li>一般不会直接被使用，而是使用JAX-RPC、JAX-WS<h1 id="Java-EE-APIs-5"><a href="#Java-EE-APIs-5" class="headerlink" title="Java EE APIs (5)"></a>Java EE APIs (5)</h1></li></ul></li><li>Java API for XML Registries (JAXR)<ul><li>支持ebXML注册和存储标准</li><li>支持UDDI规范</li></ul></li><li>Java EE Connector Architecture (JCA)<ul><li>用于开发资源适配器</li><li>基于Java EE的Web服务与已有EIS间同步或异步集成，这种集成是面向性能的、安全的、可扩展的、基于消息的、和事务的</li></ul></li><li>JDBC API<ul><li>用Java编程语言的方法调用SQL命令</li><li>分成两部分<ul><li>应用级接口 → 应用组件访问数据库</li><li>服务提供者接口 → 将JDBC驱动程序绑缚到Java EE平台上<h1 id="Java-EE-APIs-6"><a href="#Java-EE-APIs-6" class="headerlink" title="Java EE APIs (6)"></a>Java EE APIs (6)</h1></li></ul></li></ul></li><li>Java Naming and Directory Interface (JNDI)<ul><li>提供目录和命名功能</li><li>允许Java EE应用程序发现和获得任意类型的对象</li><li>与实现无关，可以访问多种已有的命名和目录服务</li><li>使用javax.naming.InitialContext对象在java:comp/env名字下查找对象</li></ul></li><li>Java Authentication and Authorization Service (JAAS)<ul><li>鉴别和授权特定用户或用户组运行Java EE应用<h1 id="Java-EE-APIs-Example"><a href="#Java-EE-APIs-Example" class="headerlink" title="Java EE APIs Example"></a>Java EE APIs Example</h1><img data-src="https://upload-images.jianshu.io/upload_images/15108298-bfa4611efdaba42a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java EE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树中序遍历（递归+非递归）</title>
      <link href="/2018/12/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2018/12/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Binary-Tree-Inorder-Traversal（二叉树中序遍历）"><a href="#Binary-Tree-Inorder-Traversal（二叉树中序遍历）" class="headerlink" title="Binary Tree Inorder Traversal（二叉树中序遍历）"></a>Binary Tree Inorder Traversal（二叉树中序遍历）</h1><p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.<br>For example:<br>Given binary tree{1,#,2,3},</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-2a63a01569a2e932.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>return[1,3,2].<br><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?<br>confused what”{1,#,2,3}”means? <a href="https://www.nowcoder.com/practice/1b25a41f25f241228abd7eb9b768ab9b?tpId=46&tqId=29084&tPage=2&rp=2&ru=/ta/leetcode&qru=/ta/leetcode/question-ranking#" target="_blank" rel="noopener">&gt; read more on how binary tree is serialized on OJ.</a><br><strong>OJ’s Binary Tree Serialization:</strong><br>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.<br>Here’s an example:</p><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-3bf41161cb720979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>The above binary tree is serialized as”{1,2,3,#,#,4,#,#,5}”.</p><a id="more"></a><h1 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a>递归思想</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>中序遍历的递归思想实现。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 二叉树中序遍历</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; v;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> v;</span><br><span class="line">    inorder_help(root, v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_help</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">    inorder_help(root-&gt;left, v);</span><br><span class="line">    v.push_back(root-&gt;val);</span><br><span class="line">    inorder_help(root-&gt;right, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非递归思想"><a href="#非递归思想" class="headerlink" title="非递归思想"></a>非递归思想</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>用非递归模拟二叉树的中序遍历，思路是：优先遍历根节点的左孩子结点，放入一个栈中，遍历到底；然后从栈中取结点，栈的特点是后进先出，从最后的节点开始加入vector数组；接着遍历该结点的右孩子结点，把该孩子结点当作根节点遍历左孩子结点。<br>实现的思想和递归是一样的，就是根据中序遍历的特点，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inorder(root -&gt; left);</span><br><span class="line"><span class="built_in">get</span>(root -&gt; val);</span><br><span class="line">inorder(root -&gt; right);</span><br></pre></td></tr></table></figure><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; v;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode* &gt; s;</span><br><span class="line">    TreeNode *node = root;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty() || node!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        v.push_back(node-&gt;val);</span><br><span class="line">        node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上。</p></blockquote><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 二叉树中序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索一个2D矩阵</title>
      <link href="/2018/12/14/%E6%90%9C%E7%B4%A2%E4%B8%80%E4%B8%AA2D%E7%9F%A9%E9%98%B5/"/>
      <url>/2018/12/14/%E6%90%9C%E7%B4%A2%E4%B8%80%E4%B8%AA2D%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Search-A-2D-Matrix（搜索一个2D矩阵）"><a href="#Search-A-2D-Matrix（搜索一个2D矩阵）" class="headerlink" title="Search A 2D Matrix（搜索一个2D矩阵）"></a>Search A 2D Matrix（搜索一个2D矩阵）</h1><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:<br>Integers in each row are sorted from left to right.<br>The first integer of each row is greater than the last integer of the previous row.<br>For example,<br>Consider the following matrix:</p><blockquote><p>[1,  3,  5,  7],<br>[10, 11, 16, 20],<br>[23, 30, 34, 50]</p></blockquote><a id="more"></a><p>Given target =3, returntrue.</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>写一个高效的算法在<code>M * N</code>的矩阵中查找值。这个矩阵有如下属性：<br>（1）每一行的整数从左往右按从小到大的顺序排列；<br>（2）每一行的第一个整数大于上一行的最后一个整数。<br>例如，在上图中所给出的矩阵中查找<strong>3</strong>，返回值为<code>true</code>。</p><h1 id="暴力查找"><a href="#暴力查找" class="headerlink" title="暴力查找"></a>暴力查找</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>两重循环遍历二维<code>vector</code>数组，找到返回<code>true</code>，找不到返回<code>false</code>。时间复杂度为<strong>O(N^2)</strong>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力查找</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优化后的暴力查找"><a href="#优化后的暴力查找" class="headerlink" title="优化后的暴力查找"></a>优化后的暴力查找</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>按照所给的矩阵的属性从右上角开始查找，如果等于查找值，就返回<code>true</code>，如果比<code>target</code>值小，向下查找，如果比<code>target</code>大，向右查找，一旦向右查找找不到说明没有，就停止查找。时间复杂度为<code>***</code>。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化的暴力查找</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][n<span class="number">-1</span>] &lt; target)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][n<span class="number">-1</span>] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-2</span>; j&gt;=<span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][n<span class="number">-1</span>] &gt; target)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>用二分查找的思想来查找，因为二维数组是按序排列的，所以用二分查找效率更高。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.empty() || matrix.<span class="built_in">size</span>()==<span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = m*n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> row = mid / n;</span><br><span class="line">        <span class="keyword">int</span> col = mid % n;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row][col] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &gt; target)</span><br><span class="line">            <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &lt; target)</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上。</p></blockquote><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>唯一路径</title>
      <link href="/2018/12/13/%E5%94%AF%E4%B8%80%E8%B7%AF%E5%BE%84/"/>
      <url>/2018/12/13/%E5%94%AF%E4%B8%80%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Unique-Paths"><a href="#Unique-Paths" class="headerlink" title="Unique Paths"></a>Unique Paths</h1><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).<br>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).<br>How many possible unique paths are there?<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-b7a195c19079b7e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>Above is a 3 x 7 grid. How many possible unique paths are there?<br><strong>Note</strong>: m and n will be at most 100.</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>在一个<code>m*n</code>的表格中，从左上角的起点处走到右下角的终点处共有多少条不同的路径。<br>在本题中，上图中的表格是<code>3*7</code>的一个表格，有多少种不同的路径。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="动态规划思想"><a href="#动态规划思想" class="headerlink" title="动态规划思想"></a>动态规划思想</h2><p>这是一个典型的入门级动态规划问题，很容易想到动态规划的思路。</p><h3 id="二维数组动态规划"><a href="#二维数组动态规划" class="headerlink" title="二维数组动态规划"></a>二维数组动态规划</h3><p>把问题中的<code>m*n</code>的表格翻译成<code>m*n</code>的二维数组，原理是除了第一行或者第一列的格子外，到其他格子路径的走法是：<strong>每一个格子的可到达路径数=左边一个格子的可到达路径数+上边一个格子的可到达路径数</strong>（第一行或者第一列的格子到达的路径数均为1）。时间复杂度为<strong>O(N^2)</strong>， 空间复杂度为<strong>O(N^2)</strong>。</p><h3 id="一维数组动态规划"><a href="#一维数组动态规划" class="headerlink" title="一维数组动态规划"></a>一维数组动态规划</h3><p>用一维数组代替二维数组，动态更新。时间复杂度为<strong>O(N^2)</strong>，空间复杂度为<strong>O(N)</strong>。</p><h2 id="组合数学思想"><a href="#组合数学思想" class="headerlink" title="组合数学思想"></a>组合数学思想</h2><p>组合数学的思想是，从左上角的起点处走到右下角的终点处，只能向右走或者只能向下走，从行上看走过了<code>m - 1</code>行，从列上看走过了<code>n - 1</code>列，即可以理解为排列组合的问题，所以一共需要的步数中挑出<code>m - 1</code>个向下走，剩下的<code>n - 1</code>个就是向右走，其实就是从<code>（m-1+n-1）</code>里挑选<code>（n-1）</code>或者<code>（m-1）</code>个，即：<code>C(n,r)</code>，其中<code>n = （m-1+n-1）</code>，<code>r = （n-1）</code>或者r = （m-1），公式为：<code>n! / ( r! * (n - r)! )</code>。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="动态规划（二维数组）"><a href="#动态规划（二维数组）" class="headerlink" title="动态规划（二维数组）"></a>动态规划（二维数组）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用vector定义int类型的二维数组，并全部初始化为1</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; &gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;(n, <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划（一维数组）"><a href="#动态规划（一维数组）" class="headerlink" title="动态规划（一维数组）"></a>动态规划（一维数组）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用vector定义int类型的一维数组，并全部初始化为1</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 用一维数组模拟二维数组，动态更新当前行</span></span><br><span class="line">            dp[j] += dp[j<span class="number">-1</span>];</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合数学（排列组合）"><a href="#组合数学（排列组合）" class="headerlink" title="组合数学（排列组合）"></a>组合数学（排列组合）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x = m+n<span class="number">-2</span>;<span class="comment">// 不用 long 会溢出，阶乘求出来太大了</span></span><br><span class="line">    <span class="keyword">long</span> y = <span class="built_in">min</span>(m,n)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">long</span> up = <span class="number">1</span>,down =<span class="number">1</span>;<span class="comment">// 最后求组合数的分子 / 分母</span></span><br><span class="line">    <span class="comment">// if(m==1||n==1) return 1;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;y ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        up *= x--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = y; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        down *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(up/down);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上。</p></blockquote><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡二叉树</title>
      <link href="/2018/12/12/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/12/12/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a>Balanced Binary Tree</h1><p>Given a binary tree, determine if it is height-balanced.<br>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一颗二叉树，确定它是否是在高度上平衡的。<br>平衡二叉树的定义：一颗二叉树，它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>根据平衡二叉树的定义：如果二叉树是空树，那便可以直接确定这棵二叉树是<strong>平衡</strong>的；如果二叉树非空，就判断它的左右子树高度差是否超过1；如果左右子树的高度差不超过1，再判断左右子树是否分别是一棵平衡二叉树。<br>在这里，判断左右子树高度差是否超过1时，用了一个函数<code>isBalancedHelper(TreeNode root);</code>，这个函数用递归方法计算二叉树的高度，并将高度返回；判断左右子树是否分别是一棵平衡二叉树时，采用的也是递归判断二叉树的左右子树分别是否为平衡二叉树（递归，真香！）。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for binary tree</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((isBalancedHelper(root.left)-isBalancedHelper(root.right)&gt;<span class="number">1</span>)||(isBalancedHelper(root.left)-isBalancedHelper(root.right)&lt;<span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root.left)&amp;&amp;isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isBalancedHelper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==null&amp;&amp;root.right==null)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = isBalancedHelper(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = isBalancedHelper(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftHeight &gt; rightHeight ? (leftHeight+<span class="number">1</span>):(rightHeight+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上。</p></blockquote><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再谈装饰者模式（总结）</title>
      <link href="/2018/12/11/%E5%86%8D%E8%B0%88%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%80%BB%E7%BB%93%EF%BC%89/"/>
      <url>/2018/12/11/%E5%86%8D%E8%B0%88%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%80%BB%E7%BB%93%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><p>在之前的文章 <strong><a href="https://yangyuanlin.club/2018/09/14/装饰者模式—JavaIO/" target="_blank" rel="noopener">浅谈装饰者模式+JAVA I/O中的装饰者模式</a></strong> 中，浅谈了一下装饰者模式，这篇文章来总结一下装饰者模式。</p></li><li><p>装饰者模式遵循<strong>开放-关闭原则</strong>，即，类应该对扩展开放，对修改关闭；</p></li><li><p>用<strong>运行时扩展</strong>来取代<strong>编译时继承</strong>；</p></li><li><p>解决了<strong>继承滥用</strong>的问题；</p></li><li><p>用<strong>对象组合</strong>的方式，做到在运行时装饰类，能够在不修改任何底层代码的情况下，给对象赋予新的职责。</p></li><li><p>尽管<strong>继承</strong>威力强大，继承并不总是实现最有弹性和最好维护的设计。</p></li><li><p>用<strong>组合</strong>和<strong>委托</strong>可以在运行时具有继承行为的效果。</p><a id="more"></a></li><li><p><strong>继承</strong>设计子类的行为，是在<strong>编译时</strong>静态决定的，用<strong>组合</strong>的做法扩展对象的行为，可以在<strong>运行时</strong>动态的进行扩展。可以利用此技巧把多个新职责，甚至是设计超类时还没有想到的职责加在对象上，而且不需要修改原来的类代码。</p></li><li><p>通过动态的组合对象，可以写新的代码添加新功能，而无需修改现有代码。既然无需修改现有代码，那么引进bug或产生意外副作用的机会将大幅度减少。即，满足<strong>开放 - 关闭原则</strong>。</p></li><li><p><strong>装饰者</strong>和<strong>被装饰者</strong>对象具有相同的超类型。所以在任何需要原始对象（被包装者）的场合，可以用装饰过的对象代替它。</p></li><li><p>可以用一个或多个<strong>装饰者</strong>包装一个对象。</p></li><li><p><strong>装饰者</strong>可以在<strong>被装饰者</strong>的<strong>行为</strong>之前与 / 或之后，加上自己的行为，以达到特定的目的。</p></li><li><p>对象可以在<strong>任何时候</strong>被装饰，所以可以在<strong>运行时</strong>动态地、不限量的用你喜欢的装饰者来装饰对象。</p></li><li><p><strong>装饰者模式：</strong>动态地将<strong>责任</strong>附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p></li><li><p><strong>装饰者模式</strong>也用到了<strong>继承</strong>，但是是利用<strong>继承</strong>达到<strong>类型匹配</strong>，而不是利用继承获得<strong>行为</strong>。</p></li><li><p>因为装饰者必须能取代被装饰者，所以装饰者需要和被装饰者有相同的<strong>接口</strong>。</p></li><li><p><strong>对象组合</strong>获得新的<strong>行为</strong>，<strong>行为</strong>从哪里来的呢？当我们将<strong>装饰者</strong>与<strong>组件</strong>组合时，就是在加入新的<strong>行为</strong>，所得到的新的<strong>行为</strong>，并不是由<strong>继承</strong>得自超类，而是由<strong>组合对象</strong>得来的。</p></li><li><p>Java I/O也引出了装饰者模式的一个“缺点”：利用装饰者模式，常常造成设计中有很多小类，数量实在太多，可能会造成使用此API程序员的困扰。</p></li><li><p>装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找插入位置</title>
      <link href="/2018/12/11/%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>/2018/12/11/%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Search-Insert-Position"><a href="#Search-Insert-Position" class="headerlink" title="Search Insert Position"></a>Search Insert Position</h1><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.<br>You may assume no duplicates in the array.<br>Here are few examples.<br>[1,3,5,6], 5 → 2<br>[1,3,5,6], 2 → 1<br>[1,3,5,6], 7 → 4<br>[1,3,5,6], 0 → 0</p><a id="more"></a><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定一个排好序的数组和一个目标值，如果能找到目标值，就返回这个索引。如果不能找到，就返回如果把这个值按需插入的话应该在的位置的索引。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>暴力搜索<br>从左到右搜索，如果找到这个值，就返回索引值；如果查找到比这个值大的值了，说明没有这个值，并且如果把这个值插入的话就插入在这个位置，就返回这个索引；如果查询到最后一个还小于目标值，说明应该把目标值插入到当前最后一个值的下一个索引位置。时间复杂度为O(N)。</li><li>二分查找<br>用二分查找法进行查找，如果查找到就返回查找到的索引位置，如果查找不到就把left索引返回，即为需要插入的位置。时间复杂度为O(log2n)。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 暴力查找法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert_1</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] == target) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt; target) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt; target &amp;&amp; i == (n<span class="number">-1</span>)) <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二分查找法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] == target)<span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] &gt; target) r = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid] &lt; target) l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l; <span class="comment">// left索引即为需要插入的索引位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target=<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;searchInsert(A, <span class="number">4</span>, target)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    target=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;searchInsert(A, <span class="number">4</span>, target)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    target=<span class="number">7</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;searchInsert(A, <span class="number">4</span>, target)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    target=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;searchInsert(A, <span class="number">4</span>, target)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img data-src="https://upload-images.jianshu.io/upload_images/15108298-3371ae389edc783a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p><ul><li>以上。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片旋转</title>
      <link href="/2018/12/09/%E5%9B%BE%E7%89%87%E6%97%8B%E8%BD%AC/"/>
      <url>/2018/12/09/%E5%9B%BE%E7%89%87%E6%97%8B%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<ul><li>Rotate Image<br>You are given an n x n 2D matrix representing an image.<br>Rotate the image by 90 degrees (clockwise).<br>Follow up:<br>Could you do this in-place?</li><li>题目大意：给定一个NxN的2D矩阵代表一张图片。把这张图片旋转90°（顺时针方向）。<br>提示：你能就地做这件事吗？</li><li>思路：在计算机图像处理里，旋转图片是很常见的，由于图片的本质是二维数组，所以也就变成了对数组的操作处理，翻转的本质就是把某个位置上的数移动到另一个位置上，比如用一个简单的例子来分析：</li></ul><p>1  2  3　　　 　　7  4  1</p><p>4  5  6　　→　　 8  5  2</p><p>7  8  9 　　　 　   9  6  3</p><a id="more"></a><p>对于90度的翻转有很多方法，一步或多步都可以解，我们先来看一种直接的方法，对于当前位置，计算旋转后的新位置，然后再计算下一个新位置，第四个位置又变成当前位置了，所以这个方法每次循环换四个数字，如下所示：</p><p>解法一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n - <span class="number">1</span> - i; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - <span class="number">1</span> - j][i];</span><br><span class="line">                matrix[n - <span class="number">1</span> - j][i] = matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j];</span><br><span class="line">                matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j] = matrix[j][n - <span class="number">1</span> - i];</span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有一种解法，首先以从对角线为轴翻转，然后再以x轴中线上下翻转即可得到结果，如下图所示(其中蓝色数字表示翻转轴)：</p><p>1  2  3　　　 　　 9  6  3　　　　　  7  4  1</p><p>4  5  6　　–&gt;　　 8  5  2　　 –&gt;   　 8  5  2　　</p><p>7  8  9 　　　 　　7  4  1　　　　　  9  6  3</p><p>解法二</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; ++j) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[n - <span class="number">1</span>- j][n - <span class="number">1</span> - i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[n - <span class="number">1</span> - i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后再来看一种方法，这种方法首先对原数组取其转置矩阵，然后把每行的数字翻转可得到结果，如下所示(其中蓝色数字表示翻转轴)：</p><p>1  2  3　　　 　　 1  4  7　　　　　  7  4  1</p><p>4  5  6　　–&gt;　　 2  5  8　　 –&gt;  　  8  5  2　　</p><p>7  8  9 　　　 　　3  6  9　　　　      9  6  3</p><p>解法三</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(matrix[i].<span class="built_in">begin</span>(), matrix[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            matrix[i][j] = matrix[i][j]^matrix[j][i];</span></span><br><span class="line"><span class="comment">            matrix[j][i] = matrix[i][j]^matrix[j][i];</span></span><br><span class="line"><span class="comment">            matrix[i][j] = matrix[i][j]^matrix[j][i];</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,k=matrix[i].<span class="built_in">size</span>()<span class="number">-1</span>; j&lt;k; j++,k--)</span><br><span class="line">            swap(matrix[i][j], matrix[i][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">a</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            a[i][j] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"图像旋转前："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[i][j]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rotate(a);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"图像旋转后："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[i][j]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>以上。</li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>罗马数字转换成整型数字</title>
      <link href="/2018/12/07/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E5%9E%8B%E6%95%B0%E5%AD%97/"/>
      <url>/2018/12/07/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E5%9E%8B%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<ul><li>Roman To Integer<br>Given a roman numeral, convert it to an integer.<br>Input is guaranteed to be within the range from 1 to 3999.</li><li>题目大意：给定一个罗马数字，把它转换成一个整型数字。输入的罗马数字保证是在1~3999范围内的。</li><li>思路：（对照 <strong><a href="https://yangyuanlin.club/2018/11/28/%E6%95%B4%E5%9E%8B%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/" target="_blank" rel="noopener">整型数字转换成罗马数字</a></strong>）<br>首先看<strong>罗马数字与整型数字对照表</strong></li><li><a id="more"></a></li></ul><table><thead><tr><th align="center">罗马数字</th><th align="center">整型数字</th></tr></thead><tbody><tr><td align="center">I</td><td align="center">1</td></tr><tr><td align="center">V</td><td align="center">5</td></tr><tr><td align="center">X</td><td align="center">10</td></tr><tr><td align="center">L</td><td align="center">50</td></tr><tr><td align="center">C</td><td align="center">100</td></tr><tr><td align="center">D</td><td align="center">500</td></tr><tr><td align="center">M</td><td align="center">1000</td></tr><tr><td align="center">罗马数字的基本规则是：</td><td align="center"></td></tr></tbody></table><ol><li>相同的数字连写、所表示的数等于这些数字相加得到的数、如：Ⅲ=3；</li><li>小的数字在大的数字的右边、所表示的数等于这些数字相加得到的数、 如：Ⅷ=8、Ⅻ=12；</li><li>小的数字、（限于 Ⅰ、X 和 C）在大的数字的左边、所表示的数等于大数减小数得到的数、如：Ⅳ=4、Ⅸ=9；</li><li>正常使用时、连写的数字重复不得超过三次；</li><li>在一个数的上面画一条横线、表示这个数扩大 1000 倍。<br> 按照这个规则就是把罗马数字的每个字符翻译成整型数字，然后按照顺序进行判断，从左到右，当后边一个大于前边一个时，就做减法运算，否则就做加法运算。</li></ol><ul><li>代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* num = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(s[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">                num[i] = <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">                num[i] = <span class="number">500</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">                num[i] = <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">                num[i] = <span class="number">50</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">                num[i] = <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">                num[i] = <span class="number">5</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                num[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &lt; num[i+<span class="number">1</span>])</span><br><span class="line">            res -= num[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res += num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    res += num[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;romanToInt(<span class="string">"IV"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;romanToInt(<span class="string">"VIII"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;romanToInt(<span class="string">"XLIV"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;romanToInt(<span class="string">"LXXXVIII"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;romanToInt(<span class="string">"CDXLIV"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;romanToInt(<span class="string">"DCCCLXXXVIII"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;romanToInt(<span class="string">"MMXIV"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;romanToInt(<span class="string">"MMMXVIII"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>运行结果：<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-c1445a949901da8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li>以上。</li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>唯一二叉搜索树</title>
      <link href="/2018/12/06/%E5%94%AF%E4%B8%80%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2018/12/06/%E5%94%AF%E4%B8%80%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<ul><li>Unique Binary Search Trees<br>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?<br>For example,<br>Given n = 3, there are a total of 5 unique BST’s.<br><img data-src="https://upload-images.jianshu.io/upload_images/15108298-5b3b1e06cc87c577.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li><li><a id="more"></a></li><li>题目大意：给定一个数字<em>n</em>，有多少个结点值为<em>1~n</em>的唯一二叉搜索树？<br>例如：给定<em>n=3</em>，共有5个二叉搜索树。</li><li>思路（递归）：二叉搜索树的性质，左边的数都比根小，右边的数都比根大。二叉树的节点是从1到n，所以能确定如果根为k，则根左边的数是1到k-1，根右边的数是k+1到n。<strong>对于一个根来说，唯一二叉树的数量是其左子树的数量乘以右子树的数量</strong>。也就是说，假如有n个结点，则唯一二叉搜索树的个数为f(n) = f(0)·f(n-1) + f(1)·f(n-2) + … + f(n-1)·f(0)，意思是，当根节点为1的时候，左子树有0个，右子树有n-1个，相乘即得此时的唯一二叉树个数；当根节点为2的时候，左子树有1个，右子树有n-2个，相乘即得此时的唯一二叉树个数；以此类推，当最后根节点为n时，左子树有n-1个，右子树有0个，相乘即得此时的唯一二叉树个数。</li><li>代码（递归）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 假设当前的根节点是i+1（从0开始，root结点值应该加一）</span></span><br><span class="line">        <span class="comment">// 则左子树有0~i个，右子树是（i+2）~n个</span></span><br><span class="line">        res += numTrees(i) * numTrees(n-i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路（非递归）：还有一种是用动态规划的思想去做，理解了递归的思想，非递归的思想也就很好理解了，其实就是把递归改写成了循环，具体是把递归得到的数据存到一个一位数组中；时间复杂度O(N!)，空间复杂度O(N)。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* res = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] += res[j] * res[i-j<span class="number">-1</span>];</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> res[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>以上。</li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬楼梯</title>
      <link href="/2018/12/05/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/2018/12/05/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<ul><li>Climbing Stairs<br>You are climbing a stair case. It takes n steps to reach to the top.<br>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</li><li>题目大意：比方说你正在爬一个楼梯。经过<em>n</em>步能走到顶。每步能走一阶或两阶。有多少种不同的方式到达顶端。</li><li>思路：最常见的是递归解法，也很好理解</li><li><a id="more"></a></li><li>代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 当台阶数小于等于0时</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 当台阶数等于1时，只有一种走法，即走一步就能到顶</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 当台阶数等于2时，有两种走法，即走一步或走两步到顶</span></span><br><span class="line">    <span class="keyword">return</span> climbStairs(n<span class="number">-1</span>) + climbStairs(n<span class="number">-2</span>); <span class="comment">// 台阶数大于2，继续递归，下一步可能走一步，也可能走两步</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这种思路能AC大多数的OJ平台，但是在牛客网却AC不了，那么他还有另外一种思路，即可以把走台阶问题看成是斐波那契数列问题，理由如下：</li><li>该问题本质为斐波拉契数列</li></ul><ol><li>假设当有n个台阶时假设有f(n)种走法；</li><li>最后一步要么跨1个台阶要么跨2个台阶；</li><li>当最后一步跨1个台阶时即之前有n-1个台阶，根据1的假设即n-1个台阶有f(n-1)种走法；</li><li>当最后一步跨2个台阶时即之前有n-2个台阶，根据1的假设即n-2个台阶有f(n-2 )种走法；</li><li>显然n个台阶的走法等于前两种情况的走法之和即f(n) = f(n-1) + f(n-2)。</li></ol><ul><li>f(n) = f(n-1) + f(n-2) 即为斐波那契数列的递推关系式，则的证这是一个斐波那契问题。</li><li>代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs_1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> one_step_before = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> two_steps_before = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> all_ways = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        all_ways = one_step_before + two_steps_before;</span><br><span class="line">        two_steps_before = one_step_before;</span><br><span class="line">        one_step_before = all_ways;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> all_ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股票最高利润 I</title>
      <link href="/2018/12/04/%E8%82%A1%E7%A5%A8%E6%9C%80%E9%AB%98%E5%88%A9%E6%B6%A6-I/"/>
      <url>/2018/12/04/%E8%82%A1%E7%A5%A8%E6%9C%80%E9%AB%98%E5%88%A9%E6%B6%A6-I/</url>
      
        <content type="html"><![CDATA[<ul><li><p>Best Time To Buy and Sell Stock<br>Say you have an array for which the <em>i</em> th element is the price of a given stock on day <em>i</em>.<br>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p></li><li><p>题目大意：给定一个数组，第<em>i</em>个元素代表第<em>i</em>天股票的价格，只限一次买入和卖出，求最大收益。</p></li><li><p>思路：找最低的价格，和它之后的最高价格，求差，再和已有的最大利润比较。不同于<a href="https://www.jianshu.com/p/9f1874980008" target="_blank" rel="noopener">股票最大利润 II</a>。在这个问题中，按那种思路找到的只是局部最大利润。</p></li><li><a id="more"></a></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 价格数要大于等于两个才能考虑（重要）</span></span><br><span class="line">    <span class="keyword">if</span>(prices.<span class="built_in">size</span>() &lt; <span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min_price = prices.front();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it = prices.<span class="built_in">begin</span>()+<span class="number">1</span>; it != prices.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 比较寻找最低利润</span></span><br><span class="line">        min_price = min_price &lt; *it ? min_price : *it;</span><br><span class="line">        <span class="comment">// 跟当前已找到的最高利润作比较</span></span><br><span class="line">        max_profit = max_profit &gt; (*it - min_price) ? max_profit : (*it - min_price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_profit &gt; <span class="number">0</span> ? max_profit : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prices;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        prices.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxProfit(prices) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上。</p></li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断回文数字</title>
      <link href="/2018/12/03/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97/"/>
      <url>/2018/12/03/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<ul><li>Ppalindrome Number<br>Determine whether an integer is a palindrome. Do this without extra space.<br><strong>Some hints:</strong><br>Could negative integers be palindromes? (ie, -1)<br>If yu are thinking of converting the integer to string, note the restriction of using extra space.<br>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?<br>There is a more generic way of solving this problem.</li><li><a id="more"></a></li><li>题目大意：判断一个整数是否是回文数字，不要使用额外的空间。</li><li>思路：反转这个整数，看与原来的数字是否相等。</li><li>代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x%<span class="number">10</span>==<span class="number">0</span>&amp;&amp;x!=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">long</span> y = x;</span><br><span class="line">    <span class="keyword">long</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(y&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp*<span class="number">10</span>+y%<span class="number">10</span>;</span><br><span class="line">        y/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp==x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">    <span class="keyword">if</span>(isPalindrome(x))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"是回文数字"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"不是回文数字"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ch[k++] = <span class="keyword">char</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ch[k]=<span class="string">'\0'</span>;</span><br><span class="line">    k--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++,k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[i]!=ch[k])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>以上。</li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 回文数字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长子序列和（未完待续）</title>
      <link href="/2018/12/02/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
      <url>/2018/12/02/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<ul><li><p>Maximum Subarray</p><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p><p>For example, given the array[−2,1,−3,4,−1,2,1,−5,4],<br>the contiguous subarray[4,−1,2,1]has the largest sum =6.</p><p><a href="https://www.nowcoder.com/practice/32139c198be041feb3bb2ea8bc4dbb01?tpId=46&tqId=29126&tPage=1&rp=1&ru=/ta/leetcode&qru=/ta/leetcode/question-ranking#" target="_blank" rel="noopener">click to show more practice.</a></p><p>More practice:</p><p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><a id="more"></a></li><li><p>题目大意：求最长子序列和。给定一个至少包含一个数字的数组，查找最长子序列和。</p><p>例如：给定的是数组[−2, 1, −3, 4, −1, 2, 1, −5, 4]，最大连续子序列是[4, -4, 2, 1]，最长子序列和是6。</p><p>更多练习：如果已经找到O(n)解决方案，尝试使用分治法解决方案。</p></li><li><p>思路：maxSum 必然是以A[i]（取值范围为A[0] ~ A[n-1]）结尾的某段构成的，也就是说maxSum的candidate必然是以A[i]结果的。如果遍历每个candidate，然后进行比较，那么就能找到最大的maxSum了。<br>假设把A[i]之前的连续段叫做sum。可以很容易想到:<br>（1）如果sum&gt;=0，就可以和A[i]拼接在一起构成新的sum。因为不管nums[i]多大，加上一个正数总会更大，这样形成一个新的candidate。<br>（2）反之，如果sum&lt;0，就没必要和A[i]拼接在一起了。因为不管A[i]多小，加上一个负数总会更小。此时由于题目要求数组连续，所以没法保留原sum，所以只能让sum等于从A[i]开始的新的一段数了，这一段数字形成新的candidate。<br>（3）如果每次得到新的candidate都和全局的maxSum进行比较，那么必然能找到最大的max sum subarray.在循环过程中，用maxSum记录历史最大的值。从A[0]到A[n-1]一步一步地进行。</p></li><li><p>代码：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = A[<span class="number">0</span>], maxsum = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        maxsum = <span class="built_in">max</span>(sum, maxsum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">-2</span>, <span class="number">1</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxSubArray(A, <span class="number">9</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上。</li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 最长子序列和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相等二叉树</title>
      <link href="/2018/12/01/%E7%9B%B8%E7%AD%89%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/12/01/%E7%9B%B8%E7%AD%89%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<ul><li>Same Tree</li></ul><p>Given two binary trees, write a function to check if they are equal or not.</p><p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p><ul><li><p>题目大意：给定两棵二叉树，写一个函数来判断它们是否相等。两棵二叉树相等的条件是两棵二叉树的结构相同并且结点值相等。</p></li><li><a id="more"></a></li><li><p>思路：可以用递归也可以把递归改成非递归（所有的递归都可以改写成非递归的形式）。</p><p>不管递归还是非递归，判断条件都是一样的，（1）首先判断当前结点是否为NULL，如果都为NULL，显然是相等的，（2）如果不是两棵树的当前结点都为NULL，其中有一个为NULL，那么两棵树必不相等，（3）如果两棵树的两个结点的值不相等，那么两棵树必不相等。条件判断完后，说明当前结点相等且不为NULL。接下来就再判断当前结点的左右子树，在递归方法中，用递归手段去判断；在非递归方法中，将当前结点的左右孩子结点入队，在去循环判断。由此可见，递归、非递归，思想是一样的。</p></li><li><p>代码：</p></li><li><p>数据结构定义</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for binary tree</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line">TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法一</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归思想实现</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先判断当前结点的情况，看是否相等</span></span><br><span class="line"><span class="comment">// 两个结点都是NULL，返回true</span></span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span> &amp;&amp; q==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 两个结点其中有一个是NULL，返回false</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="literal">NULL</span> || q==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 两个结点的值不相等，返回false</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//两棵二叉树，当前结点相等，递归判断左右子树</span></span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 非递归思想实现，用两个栈进行层序遍历，遍历过程中对结点进行判断</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q1, q2;</span><br><span class="line">        TreeNode *tmp1, *tmp2;</span><br><span class="line">        q1.push(p), q2.push(q);</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty() &amp;&amp; !q2.empty())&#123;</span><br><span class="line">            tmp1 = q1.front();</span><br><span class="line">            tmp2 = q2.front();</span><br><span class="line">            q1.pop(); q2.pop();</span><br><span class="line">            <span class="comment">// 判断两棵树的当前结点是否都NULL</span></span><br><span class="line">            <span class="keyword">if</span>(tmp1==<span class="literal">NULL</span> &amp;&amp; tmp2==<span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 非都NULL，其中有一个NULL，必不相等</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp1==<span class="literal">NULL</span> || tmp2==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 两棵树的两个结点的值不相等，必不相等</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp1-&gt;val != tmp2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 前三个判断条件都没走，说明q1不为NULL</span></span><br><span class="line">            q1.push(tmp1-&gt;left);</span><br><span class="line">            q1.push(tmp1-&gt;right);</span><br><span class="line">            <span class="comment">// 前三个判断条件都没走，说明q2不为NULL</span></span><br><span class="line">            q2.push(tmp2-&gt;left);</span><br><span class="line">            q2.push(tmp2-&gt;right);</span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line">        <span class="comment">// 结束循环后，队列有至少一个非NULL，说明两棵二叉树结构不一样，必不相等</span></span><br><span class="line">        <span class="keyword">if</span>(!q1.empty() || !q2.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>以上。</li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给每一个结点添加向右的next指针结点</title>
      <link href="/2018/11/30/%E7%BB%99%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%E6%B7%BB%E5%8A%A0%E5%90%91%E5%8F%B3%E7%9A%84next%E6%8C%87%E9%92%88%E7%BB%93%E7%82%B9/"/>
      <url>/2018/11/30/%E7%BB%99%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%E6%B7%BB%E5%8A%A0%E5%90%91%E5%8F%B3%E7%9A%84next%E6%8C%87%E9%92%88%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<ul><li>Populating Next Right Pointers in Each Node</li></ul><p>Given a binary tree</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> &#123;</span></span><br><span class="line">  TreeLinkNode *left;</span><br><span class="line">  TreeLinkNode *right;</span><br><span class="line">  TreeLinkNode *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p><p>Initially, all next pointers are set toNULL.</p><p><strong>Note:</strong></p><ul><li>You may only use constant extra space.</li><li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li></ul><p>For example,<br>Given the following perfect binary tree,</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">2</span>    <span class="number">3</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>After calling your function, the tree should look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span> -&gt; <span class="literal">NULL</span></span><br><span class="line">   /  \</span><br><span class="line">  <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="literal">NULL</span></span><br><span class="line"> / \  / \</span><br><span class="line"><span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>-&gt;<span class="number">7</span> -&gt; <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><ul><li><p>题目大意：题目给出了二叉树的数据结构，要求给每一个结点添加<code>next</code>指针结点，指针指向右边的下一个结点。如果没有下一个右边结点，<code>next</code>指针应该被设置为指向<code>NULL</code>。</p><p>提示：（1）只能使用固定的额外空间；（2）假设二叉树都是完美的二叉树（即，所有的叶子都在同一层上，而且每个父结点都有两个孩子结点）。</p><p>就像例子中给出的就是完美二叉树。</p><p>在调用完成的函数后，二叉树的结构变成了上面那样。</p></li><li><p>思路：仔细考虑题目要求，发现是在同一层上进行操作，应该想到用层次法对二叉树进行操作，思路如下，判断当前节点如果不是叶子结点，说明他有两个孩子结点，将左孩子结点指向右孩子结点，再判断该结点有没有<code>next</code>结点，如果有，那他也有两个孩子结点，就可以把当前结点的右孩子结点指向<code>next</code>结点的左孩子结点，然后再判断<code>next</code>结点的情况，判断完这一层的，再去判断下一层。</p><p>当然还有递归的思想就比较简单了。</p></li><li><p>代码：（递归）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeLinkNode *left, *right, *next;</span><br><span class="line">TreeLinkNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">//当前节点存在</span></span><br><span class="line">        <span class="comment">// 当前结点不是叶子结点，那必然就有两个结点，就让左孩子结点的next指向右孩子结点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>&amp;&amp;root-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;left-&gt;next=root-&gt;right;</span><br><span class="line">        <span class="comment">// 当前结点不是叶子结点，且有next结点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>&amp;&amp;root-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;right-&gt;next=root-&gt;next-&gt;left;</span><br><span class="line">        <span class="built_in">connect</span>(root-&gt;left); <span class="comment">// 递归判断左子树的情况</span></span><br><span class="line">        <span class="built_in">connect</span>(root-&gt;right); <span class="comment">// 递归判断右子树的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（非递归）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeLinkNode *left, *right, *next;</span><br><span class="line">    TreeLinkNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode *r = root;</span><br><span class="line">        <span class="keyword">while</span>(r &amp;&amp; r-&gt;left)&#123; <span class="comment">// 结点非空,且存在孩子结点（左右结点判断一个就好，一个有就都有）</span></span><br><span class="line">            TreeLinkNode *cur = r;</span><br><span class="line">            <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;left)&#123; <span class="comment">// 结点非空,且存在孩子结点（左右结点判断一个就好，一个有就都有）</span></span><br><span class="line">                <span class="comment">// 让当前结点的左孩子结点的next指向当前结点的右孩子结点</span></span><br><span class="line">                cur-&gt;left-&gt;next = cur-&gt;right;</span><br><span class="line">                <span class="comment">// 如果当前结点有next结点，</span></span><br><span class="line">                <span class="comment">// 就让当前结点的右孩子结点的next指向当前结点的next结点的左孩子结点</span></span><br><span class="line">                <span class="comment">// （当前结点有孩子结点，说明当前节点的next结点也必有孩子结点）</span></span><br><span class="line">                cur-&gt;right-&gt;next = cur-&gt;next == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : cur-&gt;next-&gt;left;</span><br><span class="line">                <span class="comment">// 层序向右</span></span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;<span class="comment">//while</span></span><br><span class="line">            <span class="comment">// 层序向下</span></span><br><span class="line">            r = r-&gt;left;</span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>以上。</li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带环链表</title>
      <link href="/2018/11/29/%E5%B8%A6%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
      <url>/2018/11/29/%E5%B8%A6%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Linked-List-Cycle-I"><a href="#Linked-List-Cycle-I" class="headerlink" title="Linked List Cycle I"></a>Linked List Cycle I</h2><p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up: Can you solve it without using extra space?</p><h2 id="Linked-List-Cycle-II"><a href="#Linked-List-Cycle-II" class="headerlink" title="Linked List Cycle II"></a>Linked List Cycle II</h2><a id="more"></a><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p>Follow up: Can you solve it without using extra space?</p><ul><li><p>题目大意：（I）给定一个链表，判断这个单链表中是否有环。（II）给定一个单链表，返回单链表的环的起点。如果单链表中没有环，返回<code>null</code>。进一步考虑：你能解决这两个问题但是不用额外的空间吗？ps：意思就是让你不要用额外的空间。</p></li><li><p>（I）思路：对于第一个问题，我一开始觉得，设置两个指针，一个指向头结点，一个向后查找，如果重新查找到了头结点，就说明有环，但是，情况并非都是这么理想的，比如：</p><p><img data-src="%E5%B8%A6%E7%8E%AF%E9%93%BE%E8%A1%A8/pic_1.jpg" alt></p><p>看到这种情况，就想自己果然还是太年轻了，于是就想到用HashSet，每访问一个节点，就将其记录下来，第一次重复访问了某一个节点时，就说明链表有环，而且该点就是环的起点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line"><span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (set.contains(head)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">set.add(head);</span><br><span class="line">head = head.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而建立哈希表需要额外<code>O(n)</code>的空间开销，于是开始搜集资料，找到了快慢指针这一概念，就是定义两个指针<code>fast</code>和<code>slow</code>从起点开始，<code>fast</code>每次走两步，<code>slow</code>每次走一步，相遇则说明有环。</p><p>meng：而它们相遇的这个点，一定处于环的内部，并且与头节点的距离是环长度的整数倍记快慢指针相遇的这个点是<strong>Xv</strong>，一定有<strong>v≥μ</strong>且<strong>v=kλ</strong>。于是，寻找环的起点就不难了，因为起点<strong>μ</strong>一定满足<strong>xμ=xμ+v</strong>。我们只要从头节点开始遍历链表，第一个满足这个等式的节点就是环的起点。</p><p>上面的方法就是所谓的<strong>Floyd’s cycle-finding algorithm</strong>。算法的时间复杂度是O(μ+λ)O(μ+λ)，空间复杂度是O(1)。</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *fast, *slow;</span><br><span class="line">        fast = slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast -&gt; next -&gt; next;</span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">            <span class="comment">//快慢指针相遇说明有环</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>（II）思路：如果有环（即<code>isCycle</code>为<code>true</code>），则一个指针从头开始，另一个从<strong>xv</strong>开始，同时以相同的速度往前移动，每次都移动一步。当两个指针相遇时，位置就是环的起点。</p></li><li><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *fast, *slow;</span><br><span class="line">        fast = slow = head;</span><br><span class="line">        <span class="keyword">bool</span> isCycle = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast -&gt; next -&gt; next;</span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)</span><br><span class="line">            &#123;</span><br><span class="line">                isCycle = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isCycle)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = head;</span><br><span class="line">            <span class="keyword">while</span>(fast != slow)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast -&gt; next;</span><br><span class="line">                slow = slow -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外，如果还要求环的长度（最小正周期），由于已经知道了环的起点，只要从它开始遍历，找到第一个等于起点的位置即可，最多还需要<strong>O(λ)</strong>的时间。</p></li><li><p>参考</p><p><a src="http://ihuafan.com/%E7%AE%97%E6%B3%95/floyds-cycle-finding-algorithm#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0c">参考一</a></p><p><a src="https://www.cnblogs.com/hiddenfox/p/3408931.html">参考二</a></p></li></ul><ul><li>以上。</li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda3_5.3.1(64-bit)安裝教程</title>
      <link href="/2018/11/28/Anaconda3-5-3-1-64-bit-%E5%AE%89%E8%A3%9D%E6%95%99%E7%A8%8B/"/>
      <url>/2018/11/28/Anaconda3-5-3-1-64-bit-%E5%AE%89%E8%A3%9D%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><ul><li><p><a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">官网下载</a>Anaconda3_5.3.1(64-bit)安装包。</p><p><img data-src="Anaconda3-5-3-1-64-bit-%E5%AE%89%E8%A3%9D%E6%95%99%E7%A8%8B/1.png" alt></p></li></ul><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><img data-src="Anaconda3-5-3-1-64-bit-%E5%AE%89%E8%A3%9D%E6%95%99%E7%A8%8B/2.png" alt></p><p><img data-src="Anaconda3-5-3-1-64-bit-%E5%AE%89%E8%A3%9D%E6%95%99%E7%A8%8B/3.png" alt></p><p><img data-src="Anaconda3-5-3-1-64-bit-%E5%AE%89%E8%A3%9D%E6%95%99%E7%A8%8B/4.png" alt></p><p><img data-src="Anaconda3-5-3-1-64-bit-%E5%AE%89%E8%A3%9D%E6%95%99%E7%A8%8B/5.png" alt></p><p><img data-src="Anaconda3-5-3-1-64-bit-%E5%AE%89%E8%A3%9D%E6%95%99%E7%A8%8B/6.png" alt></p><p><img data-src="Anaconda3-5-3-1-64-bit-%E5%AE%89%E8%A3%9D%E6%95%99%E7%A8%8B/7.png" alt></p><p><img data-src="Anaconda3-5-3-1-64-bit-%E5%AE%89%E8%A3%9D%E6%95%99%E7%A8%8B/8.png" alt></p><p><img data-src="Anaconda3-5-3-1-64-bit-%E5%AE%89%E8%A3%9D%E6%95%99%E7%A8%8B/9.png" alt></p><ul><li>以上。</li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Anaconda </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整型数字转换成罗马数字</title>
      <link href="/2018/11/28/%E6%95%B4%E5%9E%8B%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
      <url>/2018/11/28/%E6%95%B4%E5%9E%8B%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<ul><li>integer to roman</li></ul><p>Given an integer, convert it to a roman numeral.</p><p>Input is guaranteed to be within the range from 1 to 3999.</p><a id="more"></a><ul><li><p>题目大意：给定一个整型数字，把它转换成罗马数字。输入的整型数字范围在 1 到 3999 之间。</p></li><li><p>思路：（对照 <strong><a href="https://yangyuanlin.club/2018/12/07/罗马数字转换成整型数字/" target="_blank" rel="noopener">罗马数字转换成整型数字</a></strong>）</p><p>分别考虑输入的数的千、百、十、个位的数字。</p></li><li><p>代码：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1[<span class="number">4</span>][<span class="number">10</span>] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">""</span>;</span><br><span class="line">    s2 += s1[<span class="number">3</span>][num/<span class="number">1000</span>%<span class="number">10</span>];</span><br><span class="line">    s2 += s1[<span class="number">2</span>][num/<span class="number">100</span>%<span class="number">10</span>];</span><br><span class="line">    s2 += s1[<span class="number">1</span>][num/<span class="number">10</span>%<span class="number">10</span>];</span><br><span class="line">    s2 += s1[<span class="number">0</span>][num%<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;intToRoman(<span class="number">4</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;intToRoman(<span class="number">8</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;intToRoman(<span class="number">44</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;intToRoman(<span class="number">88</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;intToRoman(<span class="number">444</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;intToRoman(<span class="number">888</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;intToRoman(<span class="number">2014</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;intToRoman(<span class="number">3018</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果</li></ul><p><img data-src="%E6%95%B4%E5%9E%8B%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E6%88%90%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/result.PNG" alt></p><ul><li>以上。</li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器最大容水量</title>
      <link href="/2018/11/27/%E5%AE%B9%E5%99%A8%E6%9C%80%E5%A4%A7%E5%AE%B9%E6%B0%B4%E9%87%8F/"/>
      <url>/2018/11/27/%E5%AE%B9%E5%99%A8%E6%9C%80%E5%A4%A7%E5%AE%B9%E6%B0%B4%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>container with most water</li></ul><p>Given n non-negative integers a1 , a2 , …, an , where each represents a point at coordinate (i, ai ). n vertical lines are drawn such that the two endpoints of line i is at (i, ai ) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container.</p><a id="more"></a><ul><li><p>題目大意：给定n个非负整数a1，a2，……，an，他们每一个分别表示坐标上的一个点（i，a<em>i</em>）。绘制n条垂直于 x 轴的直线，第 i 条垂线的两个端点的坐标分别是（i，a<em>i</em>）和（i，0）。找出两条线，这两条线和 x 轴组成一个容器，使得这个容器能盛最多的水。</p></li><li><p>思路：假设n = 10，a[n] = {0，1，0，2，1，0，1，3，2，1}，按照题目要求绘制下图，从图中可以看出，当这两条线分别垂直于起点和终点时，这时宽度最大，这时每移动一次其中一个点，必然宽度变小。如此一来，想求最大，只有高度增长才有可能做到，所以每次（1）两边往中间找，（2）每次放弃最短的版，这是因为，去掉限制—-短板，即放弃高度较小的点，就有可能会获得更高的高度，从而得到更大的容积。</p></li></ul><p><img data-src="%E5%AE%B9%E5%99%A8%E6%9C%80%E5%A4%A7%E5%AE%B9%E6%B0%B4%E9%87%8F/graph.jpg" alt></p><ul><li>代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">height</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">0</span>,left = <span class="number">0</span>,right = <span class="built_in">height</span>.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        Max = <span class="built_in">max</span>(Max, (right-left) * <span class="built_in">min</span>(<span class="built_in">height</span>[left], <span class="built_in">height</span>[right]));</span><br><span class="line">        <span class="built_in">height</span>[left] &lt; <span class="built_in">height</span>[right] ? left++ : right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; h;</span><br><span class="line">        <span class="built_in">height</span>.push_back(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxArea(<span class="built_in">height</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：通过</p></blockquote><ul><li>以上。</li></ul><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++标准模板库vector介绍</title>
      <link href="/2018/11/26/C-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93vector%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/11/26/C-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93vector%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>（1）vector是表示可变大小数组的序列容器。</p><p>（2）就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。</p><p>（3）本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。</p><a id="more"></a><p>（4）vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。</p><p>（5）因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长。与其它动态序列容器相比（deques, lists and forward_lists）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起lists和forward_lists统一的迭代器和引用更好。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">// vector元素为 int 类型  </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v2; <span class="comment">// vector元素为 string 类型  </span></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; v3; <span class="comment">// vector元素为结构体型，结构体可以自行定义</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it; <span class="comment">// 用迭代器方式进行遍历</span></span><br></pre></td></tr></table></figure><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Constructors <span class="comment">// 构造函数 </span></span><br><span class="line">Operators <span class="comment">// 对vector进行赋值或比较 </span></span><br><span class="line">assign() <span class="comment">// 对Vector中的元素赋值 </span></span><br><span class="line">at() <span class="comment">// 返回指定位置的元素 </span></span><br><span class="line">back() <span class="comment">// 返回最末一个元素 </span></span><br><span class="line"><span class="built_in">begin</span>() <span class="comment">// 返回第一个元素的迭代器 </span></span><br><span class="line">capacity() <span class="comment">// 返回vector所能容纳的元素数量(在不重新分配内存的情况下） </span></span><br><span class="line"><span class="built_in">clear</span>() <span class="comment">// 清空所有元素 </span></span><br><span class="line">empty() <span class="comment">// 判断Vector是否为空（返回true时为空） </span></span><br><span class="line"><span class="built_in">end</span>() <span class="comment">// 返回最末元素的迭代器(译注:实指向最末元素的下一个位置) </span></span><br><span class="line">erase() <span class="comment">// 删除指定元素 </span></span><br><span class="line">front() <span class="comment">// 返回第一个元素 </span></span><br><span class="line">get_allocator() <span class="comment">// 返回vector的内存分配器 </span></span><br><span class="line">insert() <span class="comment">// 插入元素到Vector中 </span></span><br><span class="line">max_size() <span class="comment">// 返回Vector所能容纳元素的最大数量（上限） </span></span><br><span class="line">pop_back() <span class="comment">// 移除最后一个元素 </span></span><br><span class="line">push_back() <span class="comment">// 在Vector最后添加一个元素 </span></span><br><span class="line">rbegin() <span class="comment">// 返回Vector尾部的逆迭代器 </span></span><br><span class="line">rend() <span class="comment">// 返回Vector起始的逆迭代器 </span></span><br><span class="line">reserve() <span class="comment">// 设置Vector最小的元素容纳数量 </span></span><br><span class="line">resize() <span class="comment">// 改变Vector元素数量的大小 </span></span><br><span class="line"><span class="built_in">size</span>() <span class="comment">// 返回Vector元素数量的大小 </span></span><br><span class="line">swap() <span class="comment">// 交换两个Vector</span></span><br></pre></td></tr></table></figure><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><ul><li>代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v;                            <span class="comment">//定义vector</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;                 <span class="comment">//定义一个vector迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">10</span>; i &gt;= <span class="number">1</span>; i--)              <span class="comment">//插入数据</span></span><br><span class="line">        v.push_back(i);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输出："</span>;</span><br><span class="line">    <span class="keyword">for</span>(it=v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();it++)       <span class="comment">//输出迭代器的值</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    it-=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"最后一个的值为："</span>&lt;&lt;*it&lt;&lt;<span class="string">"     "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    v.erase(it);                             <span class="comment">//删除最后一个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"元素个数："</span> &lt;&lt;v.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//输出元素个数</span></span><br><span class="line">    sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());                    <span class="comment">//vector排序</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"排序后："</span>;</span><br><span class="line">    <span class="keyword">for</span>(it=v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();it++)            <span class="comment">//输出vector元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    v.insert(v.<span class="built_in">begin</span>(),<span class="number">100</span>) ;                 <span class="comment">//在pos位置插入一个elem</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"第一个元素为："</span> &lt;&lt;v.front()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出第一个元素</span></span><br><span class="line">    v.pop_back();                         <span class="comment">//去掉最后一个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"元素个数："</span> &lt;&lt;v.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出元素个数</span></span><br><span class="line">    v.<span class="built_in">clear</span>();                                <span class="comment">//vector清空</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"清空后元素个数："</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//输出元素个数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果</li></ul><p><img data-src="result.PNG" alt></p><ul><li>以上。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股票最大利润II</title>
      <link href="/2018/11/25/%E8%82%A1%E7%A5%A8%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"/>
      <url>/2018/11/25/%E8%82%A1%E7%A5%A8%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
      
        <content type="html"><![CDATA[<ul><li>best time to buy and sell stock ii</li></ul><p>Say you have an array for which the <em>i</em> th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><a id="more"></a><ul><li>题目大意：给定一个数组，第<em>i</em>个元素表示的是第<em>i</em>天的股票的价格。设计一个算法来获取最大利润。你可以完成多次交易（即，多次买入和卖出股票），但是，你不能在同一时间内进行多笔交易（即，你必须在买进股票之前卖出所有的股票）。</li><li>思路：低价买进，在降价之前的最高价卖出，再在低价的时候买进，以此循环就能获得最高利润，所以问题就转变成了判断相邻两个数是否是递增的，因为连续递增可以看做是一次买入买进操作，所以统计所有递增量即可。</li><li>代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((prices[i] &gt; prices[i<span class="number">-1</span>]))</span><br><span class="line">            profit += prices[i]-prices[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        v.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxProfit(v) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果：通过</p></blockquote><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找单数</title>
      <link href="/2018/11/25/%E6%89%BE%E5%8D%95%E6%95%B0/"/>
      <url>/2018/11/25/%E6%89%BE%E5%8D%95%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>single number</li></ul><p>Given an array of integers, every element appears <em>twice</em> except for one. Find that single one.</p><p><strong>Note:</strong><br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><a id="more"></a><ul><li>題目大意：给一个数组，数组中只有一个数是单独出现的，别的数都是成对出现的，找出这个单独出现的数。特别提示：你的算法应该具有线性的运行复杂度，而且不要用额外的内存。</li><li>思路：如果没有特别提示的话，是很好做的：从第一个数找起，记录下标，找到跟它相等的，就把两个数都置为0（假设整数中没有0），最后数组中没有置为0的数就是要找的那个单数。但是有了这个特别提示，就要想别的办法，最后的办法是用位运算，具体是用异或运算。</li><li>异或的运算法则：（1）异或满足交换律； （2）相同两个数异或为0；（3）0异或一个数为那个数本身。</li><li>代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num ^= A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;singleNumber(A, <span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上</p><hr><blockquote><p>版权声明：本文为博主原创文章，转载请注明出处。<br>个人博客地址：<a href="https://yangyuanlin.club" target="_blank" rel="noopener">https://yangyuanlin.club</a><br>欢迎来踩<del>~</del></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数反转</title>
      <link href="/2018/11/25/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
      <url>/2018/11/25/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<ul><li>Reverse digits of an integer.</li></ul><p><strong>Example1:</strong> x = 123, return 321<br><strong>Example2:</strong> x = -123, return -321</p><p><a href="https://www.nowcoder.com/profile/8403160/codeBookDetail?submissionId=12652940#" target="_blank" rel="noopener">click to show spoilers.</a></p><ul><li>Have you thought about this?</li></ul><a id="more"></a><p>Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!</p><p>If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100.</p><p>Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?</p><p>Throw an exception? Good, but what if throwing an exception is not an option? You would then have to re-design the function (ie, add an extra parameter).</p><ul><li>題目大意：把一个整数的数字顺序反转，正负号不变。</li><li>思路：定义一个临时变量转存这个整数，如果是负数就变成它的相反数，然后进行循环，每次对10求余取出这个整数的最后一位，然后把这个数除以10。</li><li>代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = x &gt; <span class="number">0</span> ? x : (-x);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp)</span><br><span class="line">        &#123;</span><br><span class="line">            result = result * <span class="number">10</span> + temp % <span class="number">10</span>;</span><br><span class="line">            temp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x &gt; <span class="number">0</span> ? result : (-result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>然后这样的话是可以通过牛客网上的测试数据的，但是关键是它题目<code>Have you thought about this?</code>后边的要求，大意是要考虑<code>int</code>类型的溢出问题，这里有两种思路：</li></ul><p>（1）定义为返回的变量为<code>long</code>或者<code>long long</code>类型，判断如果大于<code>int</code> <code>max32 = 0x7fffffff;</code>或者小于<code>int</code> <code>min32 = 0x80000000;</code>就是溢出了。</p><p>（2）每次计算新的结果时，再用逆运算（把结果除以10）判断与上一次循环的结果是否相同，不同就溢出。</p><p>第二种思路很巧妙，我喜欢第二种思路。</p><ul><li>代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = x &gt; <span class="number">0</span> ? x : (-x);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> newResult = result * <span class="number">10</span> + temp % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 把newResult/10也就是把加上的temp%10又除掉了，如果不等于result，说明发生了溢出</span></span><br><span class="line">            <span class="keyword">if</span>((newRessult / <span class="number">10</span>) != result) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            result = newRessult;</span><br><span class="line">            temp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x &gt; <span class="number">0</span> ? result : (-result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm安装教程</title>
      <link href="/2018/11/25/PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2018/11/25/PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><ul><li>官网下载安装包，这里选择professional版本。</li></ul><p><img data-src="PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/download.png" alt></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><a id="more"></a><h2 id="开始安装，选择next"><a href="#开始安装，选择next" class="headerlink" title="开始安装，选择next"></a>开始安装，选择next</h2><p><img data-src="PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/startInstall.png" alt="img"></p><h2 id="选择安装路径，继续next"><a href="#选择安装路径，继续next" class="headerlink" title="选择安装路径，继续next"></a>选择安装路径，继续next</h2><p><img data-src="PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/selectInstallPath.png" alt></p><h2 id="选择安装选项，继续next"><a href="#选择安装选项，继续next" class="headerlink" title="选择安装选项，继续next"></a>选择安装选项，继续next</h2><p><img data-src="PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/installOption.png" alt></p><h2 id="进入这一页面，默认选择，点击install"><a href="#进入这一页面，默认选择，点击install" class="headerlink" title="进入这一页面，默认选择，点击install"></a>进入这一页面，默认选择，点击install</h2><p><img data-src="PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/end.png" alt></p><h2 id="安装中，等待就好了"><a href="#安装中，等待就好了" class="headerlink" title="安装中，等待就好了"></a>安装中，等待就好了</h2><p><img data-src="PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/installing.png" alt></p><h2 id="安装完毕"><a href="#安装完毕" class="headerlink" title="安装完毕"></a>安装完毕</h2><p><img data-src="PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/finish.png" alt></p><p>因为在前边安装选项中的时候我们选择了<code>Add launchers dir to the path</code>，所以需要重启电脑，这里有两个选项：</p><ul><li><p>现在立即重启</p></li><li><p>稍后手动重启</p></li></ul><p>选择立即重启，因为我们要立刻建一个python项目尝试一下。</p><h1 id="用PyCharm新建第一个python项目"><a href="#用PyCharm新建第一个python项目" class="headerlink" title="用PyCharm新建第一个python项目"></a>用PyCharm新建第一个python项目</h1><blockquote><p>这里我实际上是已经安装了anaconda，所以电脑里已经有了python环境，而且也已经配置了anaconda的环境变量（D:\Program Files\anconda和D:\Program Files\anconda\Scripts配置到Path）</p></blockquote><h2 id="软件初始配置"><a href="#软件初始配置" class="headerlink" title="软件初始配置"></a>软件初始配置</h2><ul><li><p>配置导入，选择不导入</p></li><li><p>主题选择，选择Darcula的暗黑系主题</p></li><li><p>开始使用</p></li></ul><p><img data-src="PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/welcome.PNG" alt></p><h2 id="新建一个项目"><a href="#新建一个项目" class="headerlink" title="新建一个项目"></a>新建一个项目</h2><p><img data-src="PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/creatNewProject.png" alt></p><h2 id="选择路径"><a href="#选择路径" class="headerlink" title="选择路径"></a>选择路径</h2><ul><li><p>Location：项目路径</p></li><li><p>Base interpreter：python.exe的路径，这里我是安装了anaconda，所以已经有了python环境，而且我还配置了环境变量，所以PyCharm可以自动找到python.exe的路径。点击creat。</p></li></ul><p><img data-src="PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/newProject.png" alt></p><h2 id="新建Python文件"><a href="#新建Python文件" class="headerlink" title="新建Python文件"></a>新建Python文件</h2><p>项目名处右键 -&gt; new -&gt; python file -&gt; test01 -&gt; OK</p><p><img data-src="PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/newPython.png" alt></p><h2 id="更改编辑器区域字体大小"><a href="#更改编辑器区域字体大小" class="headerlink" title="更改编辑器区域字体大小"></a>更改编辑器区域字体大小</h2><ul><li>编辑区字体太小了，改一下字体。</li></ul><p><img data-src="PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/changeFontSize.png" alt></p><h2 id="输出一行hello-world"><a href="#输出一行hello-world" class="headerlink" title="输出一行hello world!!!"></a>输出一行<code>hello world!!!</code></h2><p>输入代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'hello world!!!'</span>);</span><br></pre></td></tr></table></figure><p>看到界面上，运行按钮是灰色的，右键test01.py -&gt; 运行</p><p><img data-src="PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/noRun.png" alt></p><p>可以看到运行出来了，而且运行按钮也亮起来了。</p><p><img data-src="PyCharm%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/run.png" alt></p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 安装教程 </tag>
            
            <tag> PyCharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github+Hexo博客体验优化（添加功能）</title>
      <link href="/2018/11/24/%E5%8D%9A%E5%AE%A2%E4%BD%93%E9%AA%8C%E4%BC%98%E5%8C%96/"/>
      <url>/2018/11/24/%E5%8D%9A%E5%AE%A2%E4%BD%93%E9%AA%8C%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="添加分类、标签、关于等页面"><a href="#添加分类、标签、关于等页面" class="headerlink" title="添加分类、标签、关于等页面"></a>添加分类、标签、关于等页面</h1><ul><li>以添加<strong>分类</strong>页面为例：</li></ul><p>在<strong>站点目录</strong>下，打开<code>Git Bash Here</code>，输入</p><p><code>hexo new page &quot;categories&quot;</code></p><p>之后在站点目录下的source文件夹下，会新增一个<code>categories</code>的文件夹，里面有一个<code>index.md</code>文件，打开如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2015-12-04 15:37:22</span><br><span class="line">type: "categories"</span><br><span class="line">comments: false</span><br><span class="line">------------------------------</span><br></pre></td></tr></table></figure><a id="more"></a><p>其中，comments可以设置为false，含义是打开分类页面，评论插件不显示；如要显示则改为<code>true</code>。</p><p>tags, about页面的创建类似，分别输入</p><p><code>hexo new page &quot;tags&quot;</code><br><code>hexo new page &quot;about&quot;</code></p><h1 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h1><p>编辑站点配置文件，添加如下内容</p><p><code>avatar: url</code></p><p>其中，<code>url</code>可以是<br>(1) 完整的互联网URL，你可以先将设置的头像图片放到网上；<br>(2) 本地地址：如<code>/upload/image/avatar.png</code> (你需要将<code>avatar.png</code>文件放在<code>/站点目录/source/upload/image/</code>里面)。</p><h1 id="上传本地图片"><a href="#上传本地图片" class="headerlink" title="上传本地图片"></a>上传本地图片</h1><ul><li>打开博客根目录下的配置文件_config.yml，找到post_asset_folder参数，设置为true，之后在每次使用命令<code>$ hexo new &quot;pages&quot;</code>新建文件时，Hexo会自动建立一个与文章同名的文件夹，把与该文章相关的所有资源都放到那个文件夹，就可以方便的使用资源。</li><li>在hexo的目录下执行<code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code>（需要等待一段时间）。</li><li>完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。</li><li>把图片放在与pages.md文件同名的文件夹pages下，引用图片时使用格式<code>![图片名](pages/pic.jpg)</code>，就可以显示图片了。</li></ul><h1 id="添加社交链接"><a href="#添加社交链接" class="headerlink" title="添加社交链接"></a>添加社交链接</h1><ul><li>编辑站点配置文件，添加</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  github: https:&#x2F;&#x2F;github.com&#x2F;</span><br><span class="line">  twitter: https:&#x2F;&#x2F;twitter.com&#x2F;</span><br><span class="line">  weibo: http:&#x2F;&#x2F;weibo.com&#x2F;</span><br><span class="line">  zhihu: http:&#x2F;&#x2F;www.zhihu.com&#x2F;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>可根据自身需要自行删减。</p><h1 id="添加友情链接"><a href="#添加友情链接" class="headerlink" title="添加友情链接"></a>添加友情链接</h1><ul><li>以添加github官网(<code>https://www.github.com</code>)为友情链接为例</li></ul><p>编辑站点配置文件，添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">links_title: 友情链接</span><br><span class="line">links:</span><br><span class="line">  Github: https:&#x2F;&#x2F;www.github.com</span><br></pre></td></tr></table></figure><p>其中，links_title为友情链接的名称。</p><h1 id="绑定自己的域名"><a href="#绑定自己的域名" class="headerlink" title="绑定自己的域名"></a>绑定自己的域名</h1><ul><li>域名解析</li></ul><ol><li>打开cmd，ing之前github_username.github.io，得到IP地址。</li></ol><p><img data-src="%E5%8D%9A%E5%AE%A2%E4%BD%93%E9%AA%8C%E4%BC%98%E5%8C%96/IP%E5%9C%B0%E5%9D%80.PNG" alt="IP地址"></p><ol start="2"><li>登录腾讯云，控制台-&gt;云解析-&gt;解析-&gt;新手快速添加，添加记录：</li></ol><p><img data-src="%E5%8D%9A%E5%AE%A2%E4%BD%93%E9%AA%8C%E4%BC%98%E5%8C%96/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.PNG" alt="域名解析"></p><ul><li>Github操作</li></ul><p>打开创建的github_user.github.io的仓库，选择setting -&gt; GitHub Pages -&gt; Custom domain -&gt; 输入自己的域名 -&gt; save：</p><p><img data-src="%E5%8D%9A%E5%AE%A2%E4%BD%93%E9%AA%8C%E4%BC%98%E5%8C%96/setting.PNG" alt></p><p>到现在，打开浏览器地址栏输入<code>http://yangyuanlin.club</code>已经可以访问到了，但是浏览器提示是不安全的访问，如何通过HTTPS访问自定义域名呢？</p><ul><li>通过HTTPS访问自定义域名</li></ul><p><strong>HTTP与HTTPS</strong><br>HTTP是明文传输协议，传输内容容易被嗅探和篡改。<br>而HTTPS，即HTTP over SSL/TLS,是添加了一层SSL(Secure Sockets Layer，安全套接层)，或者是TLS(Transport Layer Security,传输层安全协议)，所以HTTPS就可以视为HTTP和SSL/TLS协议的组合。<br>HTTPS能做到良好的保密性(防嗅探)，真实性(防篡改)，完整性(防域名劫持和域名欺骗)。</p><p><strong>SSL证书</strong><br>SSL是TLS的前身，但TLS通常也被标志为SSL。<br>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息(会话秘钥)，服务器收到密文后，用自己的私钥解密。<br>这个公钥就放在数字证书中。只要证书是可信的，公钥就是可信的。</p><p><strong>申请SSL证书</strong><br>SSL证书由你的NS(Name Server，域名服务商)颁发，由于腾讯云的SSL证书超级贵，所以我们可以迁移到免费提供SSL的NS处，比如国内的DNSpod(国内都需要备案),还有国外的Netlify和Cloudflare，从速度和操作性考虑，本人选择了Cloudflare。 </p><ol><li>到Cloudflare官网注册； </li><li>根据指引点击Add Site，添加自定义域名<code>www.yangyuanlin.club</code>，会自动开始扫描DNS解析记录； </li><li>扫描完成后，<strong>Cloudflare</strong>会选择给我们分配两个NS地址，将这两个地址替换腾讯云上的原NS地址，等待生效； e721ccd1d0e34d95515e1157e726508e</li></ol><p><img data-src="%E5%8D%9A%E5%AE%A2%E4%BD%93%E9%AA%8C%E4%BC%98%E5%8C%96/ns.PNG" alt></p><ol start="4"><li>在<strong>Cloudflare</strong>上检查自己网站的状态，显示为<code>Active</code>时表示NS更改成功； </li></ol><p><img data-src="%E5%8D%9A%E5%AE%A2%E4%BD%93%E9%AA%8C%E4%BC%98%E5%8C%96/active.PNG" alt></p><ol start="5"><li>在<strong>Cloudflare</strong>将自己网站的<strong>SSL</strong>状态改变为<code>Full</code>状态，等待<strong>Status</strong>变为<code>Active Certificate</code>，通常生效需要十几分钟。</li><li>再访问自定义域名时，就可以看见是<code>https</code>传输，网址前也有一把绿色小锁,可以看到这个证书其实是<strong>Cloudflare</strong>的证书。</li></ol><p><img data-src="%E5%8D%9A%E5%AE%A2%E4%BD%93%E9%AA%8C%E4%BC%98%E5%8C%96/https.PNG" alt></p><p><img data-src="%E5%8D%9A%E5%AE%A2%E4%BD%93%E9%AA%8C%E4%BC%98%E5%8C%96/%E8%AF%81%E4%B9%A6.PNG" alt></p><h1 id="图床工具（还没用）"><a href="#图床工具（还没用）" class="headerlink" title="图床工具（还没用）"></a>图床工具（还没用）</h1><p>图床就是一个在网络上存储图片的地方，目的是为了节省本地服务器空间，加快图片打开速度。个人用户一般不会使用，主要是个人博客和小网站使用。</p><ul><li>七牛云</li></ul><p>另外，这里也有很多：</p><p><code>https://www.jianshu.com/p/718173c339ee</code></p><h1 id="添加百度SEO"><a href="#添加百度SEO" class="headerlink" title="添加百度SEO"></a>添加百度SEO</h1><ul><li>百度搜索<code>site:www.yangyuanlin.club</code> -&gt; 提交网址，填写<code>ywww.yangyuanlin.club</code> -&gt; 提交。</li><li>在<a href="http://zhanzhang.baidu.com/site/index?site=http://www.visugar.com/" target="_blank">百度搜索资源平台</a>中对网站进行验证，文件验证搞不了（html文件总是被重新编译），html标签验证不会，CNAME验证还没搞完。</li><li>安装地图生成插件，生成网站地图，Git Bush中执行：</li></ul><p><code>npm install hexo-generator-sitemap --save  # sitemap.xml适合提交给谷歌搜素引擎</code></p><p><code>npm install hexo-generator-baidu-sitemap --save  # baidusitemap.xml适合提交百度搜索引擎</code></p><p>然后在站点配置文件_config.yml中添加以下代码（我没加就生成了sitemap）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 自动生成sitemap</span><br><span class="line">sitemap:</span><br><span class="line">path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>最后修改站点配置文件_config.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: https:&#x2F;&#x2F;yangyuanlin.club</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p>以后每次hexo g后都会在/public目录下生成sitemap.xml和baidusitemap.xml，这就是你的站点地图。</p><ul><li>首页标题优化</li></ul><p>SEO最重要的是你的标题，一般搜索都是搜索你的标题。</p><p>更改<code>index.swig</code>文件<code>(HEXO_Blog\themes\next\layout);</code></p><h1 id="评论系统valine"><a href="#评论系统valine" class="headerlink" title="评论系统valine"></a>评论系统valine</h1><blockquote><ul><li><a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a>一款快速、简洁且高效的无后端评论系统。</li></ul></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>快速</li><li>安全</li><li>Emoji 😉</li><li>无后端实现</li><li>MarkDown 全语法支持</li><li>轻量易用(~15kb gzipped)</li><li><a href="https://valine.js.org/visitor.html" target="_blank" rel="noopener">文章阅读量统计</a> <code>v1.2.0+</code></li></ul><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><p>评论内容需要保存到LeanCloud，注册账号并创建应用，<a href="https://tab.leancloud.cn/" target="_blank" rel="noopener">注册官网</a>。</p><p><img data-src="https://ws1.sinaimg.cn/large/006qRazegy1fkwo2fpoetj30h40coaak.jpg" alt="img"></p><p>应用创建好以后，进入刚刚创建的应用，选择左下角的<code>设置</code>&gt;<code>应用Key</code>，然后就能看到你的<code>APP ID</code>和<code>APP Key</code>了：</p><p><img data-src="https://ws1.sinaimg.cn/large/006qRazegy1fkwo6w2b6uj30xe0etjt4.jpg" alt="img"></p><h2 id="HTML-片段"><a href="#HTML-片段" class="headerlink" title="HTML 片段"></a>HTML 片段</h2><p>修改初始化对象中的<code>appId</code>和<code>appKey</code>的值为上面刚刚获取到的值即可(其他可以默认)。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn1.lncld.net/static/js/3.0.4/av-min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'//unpkg.com/valine/dist/Valine.min.js'</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"vcomments"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">new</span> Valine(&#123;</span></span><br><span class="line"><span class="actionscript">            el: <span class="string">'#vcomments'</span>,</span></span><br><span class="line"><span class="actionscript">            appId: <span class="string">'&lt;API_ID&gt;'</span>,</span></span><br><span class="line"><span class="actionscript">            appKey: <span class="string">'&lt;API_Key&gt;'</span></span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>修改初始化对象中的<code>APP_ID</code>和<code>APP_KEY</code>的值为上面刚刚获取到的值即可(<code>其他可以默认</code>)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Valine(&#123;</span><br><span class="line">    el: <span class="string">'#vcomments'</span> ,</span><br><span class="line">    appId: <span class="string">'&lt;APP_ID&gt;'</span>,</span><br><span class="line">    appKey: <span class="string">'&lt;APP_KEY&gt;'</span>,</span><br><span class="line">    notify:<span class="literal">false</span>, </span><br><span class="line">    verify:<span class="literal">false</span>, </span><br><span class="line">    avatar:<span class="string">'mm'</span>, </span><br><span class="line">    placeholder: <span class="string">'just go go'</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>Valine 现已发布到<a href="https://www.npmjs.com/package/valine" target="_blank" rel="noopener">npm</a>，可以直接用命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install leancloud's js-sdk</span></span><br><span class="line">npm install leancloud-storage --save</span><br><span class="line"><span class="comment"># Install valine</span></span><br><span class="line">npm install valine --save</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register AV objects to the global</span></span><br><span class="line"><span class="built_in">window</span>.AV = <span class="built_in">require</span>(<span class="string">'leancloud-storage'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use import</span></span><br><span class="line"><span class="keyword">import</span> Valine <span class="keyword">from</span> <span class="string">'valine'</span>;</span><br><span class="line"><span class="comment">// or Use require</span></span><br><span class="line"><span class="keyword">const</span> Valine = <span class="built_in">require</span>(<span class="string">'valine'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Valine(&#123;</span><br><span class="line">    el:<span class="string">'#vcomments'</span>,</span><br><span class="line">    <span class="comment">// other config</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>未完待续……</p>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的最小深度</title>
      <link href="/2018/11/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
      <url>/2018/11/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<ul><li>minimum depth of binary tree</li></ul><p>Given a binary tree, find its minimum depth.<br>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><a id="more"></a><ul><li>题目大意：给定一颗二叉树，找到它的最小深度。最小深度指的是，从根节点到最近的叶子节点，沿着这条路径走过的节点的数目。</li><li>思路：利用队列采用层序遍历，一旦找到一个叶节点，它肯定是最短的。</li><li>代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> TreeNode* tree;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 层序遍历，一旦找到一个叶节点，它肯定是最短的</span></span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">queue</span>&lt;tree&gt; qu;</span><br><span class="line">            tree now = root; <span class="comment">// 记录该层的当前节点</span></span><br><span class="line">            tree last = root; <span class="comment">// 记录该层的最后一个节点</span></span><br><span class="line">            <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">            qu.push(root);</span><br><span class="line">            <span class="keyword">while</span> (!qu.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                now = qu.front(); <span class="comment">// 取队首</span></span><br><span class="line">                qu.pop(); <span class="comment">// 出队首</span></span><br><span class="line">                <span class="built_in">size</span> = qu.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">if</span> (now-&gt;left != <span class="literal">NULL</span>)qu.push(now-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (now-&gt;right != <span class="literal">NULL</span>)qu.push(now-&gt;right);</span><br><span class="line">                <span class="comment">// 没有元素进队，说明这是一个叶子节点，找到的第一个叶子节点为最短的</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">size</span> - qu.<span class="built_in">size</span>() == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// last==now，说明当前节点走到了该层的最后一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (last == now)</span><br><span class="line">                &#123;</span><br><span class="line">                    level++;</span><br><span class="line">                    <span class="comment">// last指向下一层的最后一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (!qu.empty())last = qu.back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> level;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>测试结果：</li></ul><p><img data-src="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E7%9F%AD%E5%B1%82%E6%95%B0/1.PNG" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github+HEXO搭建个人博客网站</title>
      <link href="/2018/11/23/github-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
      <url>/2018/11/23/github-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h1><p>​    Github Pages：github是项目托管网站，列出了项目的源文件，所以github有一个pages功能，用来介绍你的项目目录，可以自定义主页，用来代替默认的列出源列表的这个页面。所以，Github Pages可以被认为是用户编写的、托管在github上的静态网页。</p><a id="more"></a><h1 id="2-搭建本地环境"><a href="#2-搭建本地环境" class="headerlink" title="2. 搭建本地环境"></a>2. 搭建本地环境</h1><p>​    首先需要搭建本地环境：Git + Node.js + Hexo + Typora，Typora是一款专门写markdown文件的编辑器，如果习惯用其他的编辑器写md，也可以。</p><p>​    操作系统：windows 7，其他系统安装方式类似。</p><p>​    安装顺序是先安装Git和Node.js，这两个安装完以后才能安装Hexo。</p><h2 id="2-1-安装Git"><a href="#2-1-安装Git" class="headerlink" title="2.1 安装Git"></a>2.1 安装Git</h2><p>​    官网下载Git安装包，安装路径自定义，有一个选项自动添加到环境变量的，要勾上。这里因为我之前就已经在用Git作为版本控制工具，所以就没有重新安装。</p><p>​    安装完成后，win+r 输入cmd打开命令行，输入git –version，返回所安装的Git的版本信息，说明安装成功。</p><h2 id="2-2-安装Node-js"><a href="#2-2-安装Node-js" class="headerlink" title="2.2 安装Node.js"></a>2.2 安装Node.js</h2><p>​    同样官网下载安装包，全部选择默认安装。</p><p>​    安装完成后，win+r 输入cmd打开命令行，输入node -v，返回所安装的node.js的版本信息，说明安装成功。</p><h2 id="2-3-安装Hexo"><a href="#2-3-安装Hexo" class="headerlink" title="2.3 安装Hexo"></a>2.3 安装Hexo</h2><p>​    安装Hexo建议照着官方文档来，网上的博客鉴于时间以及版本说法五花八门，按照官方文档来最为稳妥，而且这个是有中文官方文档的，不用担心看不懂。</p><ul><li><a href="https://hexo.io/zh-cn/docs/" target="_blank">中文官方文档</a></li><li><a href="https://hexo.io/docs/index.html" target="_blank">英文官方文档</a></li></ul><p>​    在电脑磁盘上找一个你想存放博客相关文件的地方，新建文件夹Hexo_Blog，进入，右键Git Bush Here，即可在命令行中使用npm命令安装Hexo。</p><h3 id="2-3-1-安装命令："><a href="#2-3-1-安装命令：" class="headerlink" title="2.3.1 安装命令："></a>2.3.1 安装命令：</h3><p>​    <code>$ npm install -g hexo-cli</code></p><p>​    然后等待一会儿，等待时间跟你的网速有关。</p><h3 id="2-3-2-初始化Hexo"><a href="#2-3-2-初始化Hexo" class="headerlink" title="2.3.2 初始化Hexo"></a>2.3.2 初始化Hexo</h3><p>​    安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><p>​    <code>$ hexo init</code></p><p>​    <code>$ npm install</code></p><p>​    然后等待安装结束。结束后会生成一些配置文件，具体信息参考官方文档，很详细。</p><h3 id="2-3-3-体验Hexo"><a href="#2-3-3-体验Hexo" class="headerlink" title="2.3.3 体验Hexo"></a>2.3.3 体验Hexo</h3><p>​    同样是在命令行中，输入：</p><p>​    <code>$ hexo g</code></p><p>​    <code>$ hexo s</code></p><p>​    提示：</p><p>​    <code>INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></p><p>​    说明建站成功，博客网站已经成功在本地建立起来啦！</p><p>​    在浏览器中打开<code>http://localhost:4000/</code>，你将会看到：</p><p><img data-src="hexo-first-time.png" alt></p><p>​    一片美丽的星空！！！</p><p>​    说明建站成功，主题有点丑，所以我们后边会换主题。</p>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
            <tag> node.js </tag>
            
            <tag> git </tag>
            
            <tag> typora </tag>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的最大深度</title>
      <link href="/2018/11/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <url>/2018/11/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<ul><li><p>maximum depth of binary tree</p><p>Given a binary tree, find its maximum depth.<br>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><a id="more"></a></li><li><p>题目大意：给定一棵二叉树，找它的最大深度。最大深度指的是从根节点向下到最远的叶子节点，沿着这条路径走过所经过的节点的数目。</p></li><li><p>思路：递归左右子树，左右子树最深的子树的高度加一，就是当前二叉树的最大深度。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for binary tree</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  TreeNode *left;</span><br><span class="line">  TreeNode *right;</span><br><span class="line">  TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 需要填入的代码块</span></span><br><span class="line">      <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> leftLength = maxDepth(root-&gt;left);</span><br><span class="line">      <span class="keyword">int</span> rightLength = maxDepth(root-&gt;right);</span><br><span class="line">      <span class="keyword">return</span> leftLength &gt; rightLength ? (leftLength+<span class="number">1</span>) : (rightLength+<span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 需要填入的代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><ul><li>测试结果</li></ul><p><img data-src="maximum-depth-of-binary-tree/1.PNG" alt="测试结果"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈装饰者模式+JAVA I/O中的装饰者模式</title>
      <link href="/2018/09/14/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E2%80%94JavaIO/"/>
      <url>/2018/09/14/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E2%80%94JavaIO/</url>
      
        <content type="html"><![CDATA[<ol><li><h1 id="1-装饰者模式"><a href="#1-装饰者模式" class="headerlink" title="1. 装饰者模式"></a>1. 装饰者模式</h1><p>举个栗子，假如在一家饮料店中有两种饮料，分别是奶茶和咖啡，相对的有三种调料，蜂蜜、块糖和摩卡，这样消费者就有不同的消费组合，比如加糖摩卡咖啡、蜂蜜摩卡咖啡，加糖奶茶……如果饮料的种类或者调料的种类增多，那么消费组合就会相应的增多，反映到编程代码上就会出现“类爆炸”，而且再添加新的饮料或者调料时会不可避免的改变原有的类的代码，这就违反了设计原则中的开放-关闭原则，即类应该对扩展开放，对修改关闭。</p></li></ol><a id="more"></a><h2 id="1-1-类图"><a href="#1-1-类图" class="headerlink" title="1.1 类图"></a>1.1 类图</h2><p>  使用装饰者模式就能很好地解决这个问题，废话不多说，该例子的类图如下：</p><p>  <img data-src="http://upload-images.jianshu.io/upload_images/15108298-635e82cc5abbda54?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>  其中Beverage是抽象类，CondimentDecorator是继承自Beverage类的抽象类。</p><h2 id="1-2-饮料的抽象类"><a href="#1-2-饮料的抽象类" class="headerlink" title="1.2 饮料的抽象类"></a>1.2 饮料的抽象类</h2><p>  Beverage.java代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饮料的描述</span></span><br><span class="line"><span class="keyword">protected</span> String description;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Beverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">description = <span class="string">"饮料的抽象类"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> description;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-调味品的抽象类"><a href="#1-3-调味品的抽象类" class="headerlink" title="1.3 调味品的抽象类"></a>1.3 调味品的抽象类</h2><p>  CondimentDecorator.java代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 调味品装饰者，继承自饮料的抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CondimentDecorator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">description = <span class="string">"调味品的抽象类"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;<span class="comment">//所有的调料品装饰者必须重写getDescription()方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;<span class="comment">//所有的调料品装饰者必须重写cost()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-饮料-奶茶的实现类"><a href="#1-4-饮料-奶茶的实现类" class="headerlink" title="1.4 饮料 奶茶的实现类"></a>1.4 饮料 奶茶的实现类</h2><p>  TeaMilk.java的代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeaMilk</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TeaMilk</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//饮料的描述</span></span><br><span class="line">description=<span class="string">"奶茶"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* (non-Javadoc)</span></span><br><span class="line"><span class="comment"> * @see Beverage#cost()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//奶茶一杯三块钱</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">3.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-饮料-咖啡的实现类"><a href="#1-5-饮料-咖啡的实现类" class="headerlink" title="1.5 饮料 咖啡的实现类"></a>1.5 饮料 咖啡的实现类</h2><p>  Coffee.java的代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Coffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//饮料的描述</span></span><br><span class="line">description=<span class="string">"咖啡"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* (non-Javadoc)</span></span><br><span class="line"><span class="comment"> * @see Beverage#cost()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//咖啡一杯四块钱</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">4.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  1.6 调味品 蜂蜜的实现类</p><p>  Honey.java的代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 蜂蜜，继承自调味品抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Honey</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录饮料的变量，是被装饰者</span></span><br><span class="line">Beverage beverage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让被装饰者记录到实例变量中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Honey</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 描述调味品和饮料</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"蜂蜜"</span> + beverage.getDescription();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 加蜂蜜一块钱，计算加了蜂蜜的饮料的价钱</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span> + beverage.cost();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  1.7 调味品 摩卡的实现类</p><p>  Mocha.java的代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 摩卡，继承自调味品装饰者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用一个变量记录饮料，也就是被装饰者</span></span><br><span class="line">Beverage beverage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把被装饰者记录到实例变量中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Mocha</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 描述调味品和饮料</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"摩卡"</span> + beverage.getDescription();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 加摩卡一块钱，计算加了摩卡的饮料的价钱</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span> + beverage.cost();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  1.8 调味品 糖的实现类</p><p>  Sugar.java的代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 糖，继承自调味品抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sugar</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用一个变量记录饮料，也就是被装饰者</span></span><br><span class="line">Beverage beverage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把被装饰者记录到实例变量中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sugar</span><span class="params">(Beverage beverage)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 描述加糖的饮料</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"加糖"</span> + beverage.getDescription();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 计算加了糖的饮料的价钱</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span> + beverage.cost();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  1.9 测试类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 点一杯蜂蜜摩卡咖啡</span></span><br><span class="line">Beverage beverage1 = <span class="keyword">new</span> Coffee();<span class="comment">// 定义咖啡对象</span></span><br><span class="line">beverage1 = <span class="keyword">new</span> Mocha(beverage1);<span class="comment">// 用摩卡装饰</span></span><br><span class="line">beverage1 = <span class="keyword">new</span> Honey(beverage1);<span class="comment">// 用蜂蜜装饰</span></span><br><span class="line">System.out.println(<span class="string">"顾客点了（"</span> + beverage1.getDescription() + <span class="string">"）\n价格是："</span></span><br><span class="line">+ beverage1.cost() + <span class="string">"元"</span>);</span><br><span class="line"><span class="comment">// 点一杯加糖奶茶</span></span><br><span class="line">Beverage beverage2 = <span class="keyword">new</span> TeaMilk();<span class="comment">// 定义奶茶对象</span></span><br><span class="line">beverage2 = <span class="keyword">new</span> Sugar(beverage2);<span class="comment">// 用糖装饰</span></span><br><span class="line">System.out.println(<span class="string">"顾客点了（"</span> + beverage2.getDescription() + <span class="string">"）\n价格是："</span></span><br><span class="line">+ beverage2.cost() + <span class="string">"元"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>  <img data-src="http://upload-images.jianshu.io/upload_images/15108298-a4f4e8024d98dc25?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="2-JAVA-I-O中的装饰者模式"><a href="#2-JAVA-I-O中的装饰者模式" class="headerlink" title="2. JAVA I/O中的装饰者模式"></a>2. JAVA I/O中的装饰者模式</h1><p>  例题：</p><ul><li><p>先从文件test.txt中读Employee对象的数据存到HashMap，</p></li><li><p>再把HashMap中的Employee对象的数据存到一个新的文件test2.txt。</p></li><li><p>代码：</p><h2 id="2-1-Employee实体类Employee-java"><a href="#2-1-Employee实体类Employee-java" class="headerlink" title="2.1 Employee实体类Employee.java"></a>2.1 Employee实体类Employee.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nwpu;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String department;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String id, String name, String department)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.department = department;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDepartment</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> department;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDepartment</span><span class="params">(String department)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.department = department;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id+<span class="string">","</span>+name+<span class="string">","</span>+department;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-测试类TestFileIO-java"><a href="#2-2-测试类TestFileIO-java" class="headerlink" title="2.2 测试类TestFileIO.java"></a>2.2 测试类TestFileIO.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nwpu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yylin</span></span><br><span class="line"><span class="comment"> * 读取文件时：</span></span><br><span class="line"><span class="comment"> * 一行一行读取文件，解决读取中文字符时出现乱码。</span></span><br><span class="line"><span class="comment"> *  流的关闭顺序：先打开的后关，后打开的先关，</span></span><br><span class="line"><span class="comment"> *  否则有可能出现java.io.IOException: Stream closed异常。</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 写入文件时：</span></span><br><span class="line"><span class="comment"> *  一行一行写入文件，解决写入中文字符时出现乱码。</span></span><br><span class="line"><span class="comment"> *  流的关闭顺序：先打开的后关，后打开的先关，</span></span><br><span class="line"><span class="comment"> *  否则有可能出现java.io.IOException: Stream closed异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileIO</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * read file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FileInputStream fis=<span class="keyword">null</span>;<span class="comment">//文件输入流</span></span><br><span class="line">InputStreamReader isr=<span class="keyword">null</span>;<span class="comment">//读入输入流</span></span><br><span class="line">BufferedReader br=<span class="keyword">null</span>;<span class="comment">//对读入的文件流缓存</span></span><br><span class="line">Set&lt;Employee&gt; set=<span class="keyword">new</span> HashSet&lt;Employee&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String fileURL=<span class="string">"E:/test/test.txt"</span>;</span><br><span class="line">fis=<span class="keyword">new</span> FileInputStream(fileURL);</span><br><span class="line"><span class="comment">//解决读入中文乱码的问题 + 用InputStreamReader类装饰FileInputStream类</span></span><br><span class="line">isr=<span class="keyword">new</span> InputStreamReader(fis,<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//用BufferedReader类装饰BufferedReader类</span></span><br><span class="line">br=<span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">String line=<span class="string">""</span>;</span><br><span class="line">String arrs[]=<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//按行读入</span></span><br><span class="line"><span class="keyword">while</span> ((line=br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(line);<span class="comment">//输出读入的行</span></span><br><span class="line">arrs=line.split(<span class="string">","</span>);</span><br><span class="line"><span class="comment">//注入对象</span></span><br><span class="line">set.add(<span class="keyword">new</span> Employee(arrs[<span class="number">0</span>],arrs[<span class="number">1</span>],arrs[<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//流的关闭顺序：先打开的后关，后打开的先关</span></span><br><span class="line">br.close();</span><br><span class="line">isr.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Employee e : set) &#123;</span><br><span class="line">System.out.println(e.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * write file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FileOutputStream fos=<span class="keyword">null</span>;<span class="comment">//文件输出流</span></span><br><span class="line">OutputStreamWriter osw=<span class="keyword">null</span>;<span class="comment">//写出输出流</span></span><br><span class="line">BufferedWriter bw=<span class="keyword">null</span>;<span class="comment">//缓存写出的输出流</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String fileURL=<span class="string">"E:/test/test2.txt"</span>;</span><br><span class="line">fos=<span class="keyword">new</span> FileOutputStream(fileURL);</span><br><span class="line"><span class="comment">//解决中文乱码问题 + 用OutputStreamWriter类装饰FileOutputStream类</span></span><br><span class="line">osw=<span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//用BufferedWriter类装饰OutputStreamWriter类</span></span><br><span class="line">bw=<span class="keyword">new</span> BufferedWriter(osw);</span><br><span class="line"><span class="keyword">for</span> (Employee e : set) &#123;</span><br><span class="line">bw.write(e.toString()+<span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意关闭的先后顺序，先打开的后关闭，后打开的先关闭</span></span><br><span class="line">bw.close();</span><br><span class="line">osw.close();</span><br><span class="line">fos.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-运行结果"><a href="#2-3-运行结果" class="headerlink" title="2.3 运行结果"></a>2.3 运行结果</h2><p><img data-src="http://upload-images.jianshu.io/upload_images/15108298-3d4141e880bb2bca?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>程序运行前：<br><img data-src="http://upload-images.jianshu.io/upload_images/15108298-c7ead75c4b788429?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>test.txt中：<br><img data-src="http://upload-images.jianshu.io/upload_images/15108298-93a995d8f9f943a9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>程序运行后：<br><img data-src="http://upload-images.jianshu.io/upload_images/15108298-1a161e93e8f4dd24?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>test.txt中：<br><img data-src="http://upload-images.jianshu.io/upload_images/15108298-d2bd676acedb694d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 装饰者模式 </tag>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/08/08/hello-world/"/>
      <url>/2018/08/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
