<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/logo.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.ico">
  <link rel="mask-icon" href="/images/logo.ico" color="#222">
  <meta name="google-site-verification" content="QrRqAEoLHOBZnSt7mRkhAt6dCoj3nREdeG7IU9IKL1E">
  <meta name="msvalidate.01" content="9A1D61A279FB6EF4CF3128BF57AFCBAC">
  <meta name="baidu-site-verification" content="5Iz7ysEFLe">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-corner-indicator.min.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ylyang.xyz","root":"/","scheme":"Gemini","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":{"enable":true,"onlypost":false,"loadingImg":null},"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"path":"./public/search.xml"};
  </script>

  <meta name="description" content="for循环优化 - 基本衡量指标看一个例子在头文件里定义了一个变量N &#x3D; 3  N是循环边界，for循环执行的是乘加操作  以上程序可以用以下这样一个状态来表示，一共有四个状态，分别是C0、C1、C2、C3，">
<meta property="og:type" content="article">
<meta property="og:title" content="Vivado HLS之for循环优化">
<meta property="og:url" content="ylyang.xyz/2020/01/05/VivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="静水流深的博客">
<meta property="og:description" content="for循环优化 - 基本衡量指标看一个例子在头文件里定义了一个变量N &#x3D; 3  N是循环边界，for循环执行的是乘加操作  以上程序可以用以下这样一个状态来表示，一共有四个状态，分别是C0、C1、C2、C3，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C1.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C2.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C3.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C4.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C5.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C6.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C7.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C8.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C9.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C10.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C11.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C13.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C14.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C15.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C16.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C17.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C18.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C19.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C20.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C21.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C22.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C23.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C24.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C25.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C26.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C27.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C28.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C29.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C30.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C31.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C32.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C33.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C34.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C35.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C36.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C37.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C38.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C39.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C40.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C41.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C42.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C43.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C44.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C45.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C46.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C47.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C48.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C49.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C50.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C51.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C52.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C53.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C54.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C63.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C55.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C56.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C57.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C58.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C59.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C60.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C61.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C62.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C64.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C65.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C66.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C67.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C68.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C69.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C70.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C71.PNG">
<meta property="og:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C72.PNG">
<meta property="article:published_time" content="2020-01-05T04:59:05.000Z">
<meta property="article:modified_time" content="2020-08-06T08:08:46.004Z">
<meta property="article:author" content="ylyang">
<meta property="article:tag" content="Vivado HLS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="e:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C1.PNG">

<link rel="canonical" href="ylyang.xyz/2020/01/05/VivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Vivado HLS之for循环优化 | 静水流深的博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

   <script type="text/javascript" src="/js/myjs/clicklove.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">静水流深的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">ylyang's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">20</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">178</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">126</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#for循环优化-基本衡量指标"><span class="nav-number">1.</span> <span class="nav-text">for循环优化 - 基本衡量指标</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#看一个例子"><span class="nav-number">1.1.</span> <span class="nav-text">看一个例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#名词介绍"><span class="nav-number">1.2.</span> <span class="nav-text">名词介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pipeline优化for循环"><span class="nav-number">1.3.</span> <span class="nav-text">pipeline优化for循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在波形图中查看相应的指标"><span class="nav-number">1.4.</span> <span class="nav-text">在波形图中查看相应的指标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unrolling优化for循环"><span class="nav-number">1.5.</span> <span class="nav-text">unrolling优化for循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#部分循环展开（Partial-Loop-Unrolling）"><span class="nav-number">1.6.</span> <span class="nav-text">部分循环展开（Partial Loop Unrolling）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设置方法"><span class="nav-number">1.6.1.</span> <span class="nav-text">设置方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环变量i"><span class="nav-number">1.7.</span> <span class="nav-text">循环变量i</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#for循环优化-循环合并"><span class="nav-number">2.</span> <span class="nav-text">for循环优化 - 循环合并</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#例子"><span class="nav-number">2.1.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何-循环合并"><span class="nav-number">2.2.</span> <span class="nav-text">如何 循环合并</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对于循环边界相同的两个常数"><span class="nav-number">2.2.1.</span> <span class="nav-text">对于循环边界相同的两个常数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对于循环边界不同的两个常数"><span class="nav-number">2.2.2.</span> <span class="nav-text">对于循环边界不同的两个常数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环边界有变量的场景（报错）"><span class="nav-number">2.2.3.</span> <span class="nav-text">循环边界有变量的场景（报错）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环边界都是变量的场景（报错）"><span class="nav-number">2.2.4.</span> <span class="nav-text">循环边界都是变量的场景（报错）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解决方案"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">解决方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并规则"><span class="nav-number">2.3.</span> <span class="nav-text">合并规则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#for循环优化-数据流"><span class="nav-number">3.</span> <span class="nav-text">for循环优化 - 数据流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#看一个例子-1"><span class="nav-number">3.1.</span> <span class="nav-text">看一个例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dataflow（数据流）优化方式"><span class="nav-number">3.2.</span> <span class="nav-text">Dataflow（数据流）优化方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运用Dataflow之后带来的性能上的好处"><span class="nav-number">3.3.</span> <span class="nav-text">运用Dataflow之后带来的性能上的好处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dataflow优化限制"><span class="nav-number">3.4.</span> <span class="nav-text">Dataflow优化限制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Single-producer-consumer-Model"><span class="nav-number">3.4.1.</span> <span class="nav-text">Single-producer-consumer Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bypassing-Tasks-Model"><span class="nav-number">3.4.2.</span> <span class="nav-text">Bypassing Tasks Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置Dataflow的内存通道（Configuring-Dataflow-Memory-Channels）"><span class="nav-number">3.4.3.</span> <span class="nav-text">配置Dataflow的内存通道（Configuring Dataflow Memory Channels）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显式指定默认通道（To-explicitly-specify-the-default-channel）"><span class="nav-number">3.4.4.</span> <span class="nav-text">显式指定默认通道（To explicitly specify the default channel）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">3.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#for循环优化-嵌套的for循环"><span class="nav-number">4.</span> <span class="nav-text">for循环优化 - 嵌套的for循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套for循环的分类"><span class="nav-number">4.1.</span> <span class="nav-text">嵌套for循环的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一类是perfect-loop-nest"><span class="nav-number">4.1.1.</span> <span class="nav-text">第一类是perfect loop nest</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二类是Semi-Perfect-loop-nest"><span class="nav-number">4.1.2.</span> <span class="nav-text">第二类是Semi-Perfect loop nest</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三类是Imperfect-loop-nest"><span class="nav-number">4.1.3.</span> <span class="nav-text">第三类是Imperfect loop nest</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#perfect-loop的例子"><span class="nav-number">4.2.</span> <span class="nav-text">perfect loop的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Imperfect-Loop的例子"><span class="nav-number">4.3.</span> <span class="nav-text">Imperfect Loop的例子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如果只对最内层的for循环做pipeline（流水）"><span class="nav-number">4.3.1.</span> <span class="nav-text">如果只对最内层的for循环做pipeline（流水）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果只是对第二层for循环做pipeline"><span class="nav-number">4.3.2.</span> <span class="nav-text">如果只是对第二层for循环做pipeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果只对最外层的for循环做pipeline"><span class="nav-number">4.3.3.</span> <span class="nav-text">如果只对最外层的for循环做pipeline</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#比较"><span class="nav-number">4.4.</span> <span class="nav-text">比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对整个函数做流水"><span class="nav-number">4.5.</span> <span class="nav-text">对整个函数做流水</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#矩阵乘法优化"><span class="nav-number">4.6.</span> <span class="nav-text">矩阵乘法优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-2"><span class="nav-number">4.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#for循环优化-其他方法"><span class="nav-number">5.</span> <span class="nav-text">for循环优化 - 其他方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#for循环的并行性"><span class="nav-number">5.1.</span> <span class="nav-text">for循环的并行性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使函数并行执行的方法"><span class="nav-number">5.1.1.</span> <span class="nav-text">使函数并行执行的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对上面两个结果进行比较"><span class="nav-number">5.1.2.</span> <span class="nav-text">对上面两个结果进行比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用rrewind-option"><span class="nav-number">5.2.</span> <span class="nav-text">使用rrewind option</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rewind使用举例"><span class="nav-number">5.2.1.</span> <span class="nav-text">rewind使用举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数中有多个循环的情况"><span class="nav-number">5.2.2.</span> <span class="nav-text">函数中有多个循环的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何对for循环自动添加流水"><span class="nav-number">5.2.3.</span> <span class="nav-text">如何对for循环自动添加流水</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加pipeline失效的情况"><span class="nav-number">5.2.4.</span> <span class="nav-text">添加pipeline失效的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何处理循环边界是变量的情形"><span class="nav-number">5.2.5.</span> <span class="nav-text">如何处理循环边界是变量的情形</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用Tripcount的directive的方式"><span class="nav-number">5.2.5.1.</span> <span class="nav-text">使用Tripcount的directive的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将循环边界的数据类型声明为ap-int-lt-w-gt"><span class="nav-number">5.2.5.2.</span> <span class="nav-text">将循环边界的数据类型声明为ap_int&lt;w&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用assert这个macro"><span class="nav-number">5.2.5.3.</span> <span class="nav-text">使用assert这个macro</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-3"><span class="nav-number">5.2.6.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ylyang"
      src="/images/tou2.jpg">
  <p class="site-author-name" itemprop="name">ylyang</p>
  <div class="site-description" itemprop="description">云山苍苍，江水泱泱；先生之风，山高水长。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">178</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yangyl7239" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yangyl7239" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuanlin.young@gmail.com" title="E-Mail → mailto:yuanlin.young@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://ylyang.xyz/" title="https:&#x2F;&#x2F;ylyang.xyz">Home</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/yangyl7239" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="ylyang.xyz/2020/01/05/VivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tou2.jpg">
      <meta itemprop="name" content="ylyang">
      <meta itemprop="description" content="云山苍苍，江水泱泱；先生之风，山高水长。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Vivado HLS之for循环优化
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="文章创建时间：2020-01-05 12:59:05" itemprop="dateCreated datePublished" datetime="2020-01-05T12:59:05+08:00">2020-01-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vivado-HLS/" itemprop="url" rel="index"><span itemprop="name">Vivado HLS</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="for循环优化-基本衡量指标"><a href="#for循环优化-基本衡量指标" class="headerlink" title="for循环优化 - 基本衡量指标"></a>for循环优化 - 基本衡量指标</h1><h2 id="看一个例子"><a href="#看一个例子" class="headerlink" title="看一个例子"></a>看一个例子</h2><p>在头文件里定义了一个变量<code>N = 3</code></p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C1.PNG" alt="1"></p>
<p>N是循环边界，for循环执行的是乘加操作</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C2.PNG" alt="2"></p>
<p>以上程序可以用以下这样一个状态来表示，一共有四个状态，分别是<code>C0、C1、C2、C3</code>，</p>
<a id="more"></a>

<p>在这四个状态中，</p>
<p>C0是读取数据b和c</p>
<p>C1是获取数组xin[]的0号地址xin[0]</p>
<p>C2是从0号地址读取相应的数据</p>
<p>C3完成相应的计算</p>
<h2 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h2><p>假定每个状态都消耗一个时钟周期，for循环要执行三次，所以<strong>Loop Trip Count = 3</strong>，也就是代表<strong>循环一共执行了多少次</strong></p>
<p>对一个for循环而言，有<code>C1、C2、C3</code>三个状态，占用了三个时钟周期，所以它的<strong>Loop Iteration Latency = 3</strong></p>
<p><strong>本次for循环和下一次for循环的间隔</strong>也是三，所以也是<strong>Loop Iteration Interval（Loop II）= 3</strong>，这个<strong>Loop II</strong>表明了两次相邻的输入之间的间隔，也是以时钟周期的个数表示的，从而我们就可以确定整个for循环的<strong>Loop Latency = 9</strong>，</p>
<p>整个函数的<strong>Function Latency = 10</strong></p>
<p>以及<strong>Function Initial Interval（II）= 11</strong></p>
<p>这些参数是衡量我们设计性能很重要的指标，在综合报告中也能看到这些指标。</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C3.PNG" alt="3"></p>
<p>这是综合后的报告，相应的Latency、Interation Latency，还有函数的Latency以及相应的Interval</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C4.PNG" alt="4"></p>
<p>从 CoSimulation的波形来看，当ap_start为高的时候作为起始点，当ap_done为高的时候作为终止点，这样就确定了整个函数的Latency</p>
<p>这样就确定了整个函数的Function Latency = 10，相应的可以确定Function Initial Interval = 11</p>
<p>我们在描述for循环的时候很明确的知道for循环执行到什么时候退出，但是对硬件电路而言，需要去判断，判断变量i到底是否超出了循环边界，相应的循环体要不要被终止，这样就需要消耗一个额外的时钟周期，所以并不是i一达到循环边界就结束，会有一个判断的操作</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C5.PNG" alt="5"></p>
<h2 id="pipeline优化for循环"><a href="#pipeline优化for循环" class="headerlink" title="pipeline优化for循环"></a>pipeline优化for循环</h2><p>对for循环最常见的优化就是做流水线，流水线设置是在directive中设置为pipeline，相应的设置完成以后就可以在Directive窗口中被设置好了</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C6.PNG" alt="6"></p>
<p>为什么设置pipeline会改善Latency和Interval呢？</p>
<p>在没有采用pipeline的时候整个操作是按时间的先后顺序来执行的，一旦有了pipeline，就变成了并行的流水线操作</p>
<p>这里设置pipeline以后，Iteration Latency = 3没有变，每次循环还是要消耗3个时钟周期，但是II就变成1了（Loop II = 1），不用等到上一个for循环执行完了再去读下一个，而是当在读数据的时候，下一次for循环就可以开始获取相应的地址，也可以看到Loop Latency = 3</p>
<p>这也就是通过pipeline可以把Latency和Interval降下来的原因</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C7.PNG" alt="7"></p>
<h2 id="在波形图中查看相应的指标"><a href="#在波形图中查看相应的指标" class="headerlink" title="在波形图中查看相应的指标"></a>在波形图中查看相应的指标</h2><p>在波形图中可以查看相应的指标，比如Function Latency和Function Initial Interval</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C8.PNG" alt="8"></p>
<h2 id="unrolling优化for循环"><a href="#unrolling优化for循环" class="headerlink" title="unrolling优化for循环"></a>unrolling优化for循环</h2><p>对于for循环也可以进行展开优化，在默认的情况下for循环是被折叠的，所谓折叠可以理解为每一次循环都是采用同一套电路，只是这个电路被分时复用了，如果展开就意味着这个for循环被复制了，可能被复制了n次，也可能被复制了n/2ci，可控。</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C9.PNG" alt="9"></p>
<p>比如下图中<strong>trip count  = 3</strong>，完全展开，相应的资源扩大了三倍，乘法器从一个变成了3个</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C10.PNG" alt="10"></p>
<h2 id="部分循环展开（Partial-Loop-Unrolling）"><a href="#部分循环展开（Partial-Loop-Unrolling）" class="headerlink" title="部分循环展开（Partial Loop Unrolling）"></a>部分循环展开（Partial Loop Unrolling）</h2><p>如下程序，<strong>trip count = 6</strong>，从C语言角度出发，可以写成三个for循环，这三个for循环<code>i</code>的起始值是不一样的，但是边界都是6，相应的，每个for循环所对应的<code>i</code>也是不一样的，可以在右上角看到：</p>
<p>loop1：i = 0，3</p>
<p>loop2：i = 1，4</p>
<p>loop3：i = 2，5</p>
<p>所以从这个角度讲，for循环是被拆分成三部分，或者说是被复制了三份，被复制后0和3共用一套逻辑资源，1和4共用一套逻辑资源，2和5共用一套逻辑资源</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C11.PNG" alt="11"></p>
<h3 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h3><p>当使用部分循环展开时，在directive窗口进行设置，有个参数是<strong>factor</strong>，将其设置为3，意思就是将for循环复制了3份</p>
<p>综合后的结果可以看到DSP48消耗了三个，也就是乘法器复制了三份</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C13.PNG" alt="13"></p>
<h2 id="循环变量i"><a href="#循环变量i" class="headerlink" title="循环变量i"></a>循环变量<code>i</code></h2><p>还是以上面的代码为例，循环变量<code>i</code>被声明为了<code>int</code>，也可以声明为ap_int&lt;4&gt;，也就是4比特，因为它的边界是6，所以声明为int还是ap_int是不受影响的，因为Vivado HLS考虑的是<code>i</code>的最大值是多少，从而根据<code>i</code>的最大值进行相应的资源规划，尽管也会考虑到数据类型，但是变量的范围决定了它的资源量</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C14.PNG" alt="14"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一节讲了一些基本的概念，</p>
<p>循环和函数的Latency以及Interval，</p>
<p>对于for循环优化最常用的是pipeline，也就是流水</p>
<p>对于for循环在默认情况下是折叠的，因此我们可以对他进行循环展开</p>
<p>也可以进行部分展开，设置相应的factor来实现</p>
<p>部分展开是一种折中的方式，在并行度和资源方面选择一种折中的方案，获取最佳实践</p>
<p>循环变量对最终的资源消耗量并没有影响</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C15.PNG" alt="15"></p>
<h1 id="for循环优化-循环合并"><a href="#for循环优化-循环合并" class="headerlink" title="for循环优化 - 循环合并"></a>for循环优化 - 循环合并</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在下面的代码中，有两个循环，一个执行加法，一个执行减法，而且这两个for循环对应的逻辑电路是可以并行执行的，就是可以同时去并行计算<code>a + b</code>和<code>a - b</code>，期望的电路如下右图，有加法和减法，同时把输出数据给到两个运算单元，从而得到相应的结果</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C16.PNG" alt="16"></p>
<p>但是实际上在默认的情况下，对于加的for循环，Latency等于8，对于减的for循环，Latency也是等于8，从综合后的报告可以看到，这两个for循环是按顺序执行的，考虑到进入for循环和退出for循环需要额外的时钟周期，所以整个的Latency是18个时钟周期</p>
<p>这显然不符合我们预期的结果</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C17.PNG" alt="17"></p>
<h2 id="如何-循环合并"><a href="#如何-循环合并" class="headerlink" title="如何 循环合并"></a>如何 循环合并</h2><h3 id="对于循环边界相同的两个常数"><a href="#对于循环边界相同的两个常数" class="headerlink" title="对于循环边界相同的两个常数"></a>对于循环边界相同的两个常数</h3><p>所以在Vivado HLS中就提供了循环合并，在进行循环合并时，有一个新的概念叫region（区域），就是绿色虚线框对应的部分，所谓region就是loop region花括号之间对应的代码段，region作用的loop_merge，循环合并的作用域也就是loo_region下的for循环部分，在相应的directive窗口下就可以看到是生效的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C18.PNG" alt="18"></p>
<p>合并之后整个loop就变成了一个，从综合的报告中也可以看到Latency变成了8，整个函数的Latency就变成了9</p>
<p>，这就是循环合并带给我们的最直接的好处</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C19.PNG" alt="19"></p>
<p>通过前面的比较可以看到，循环的合并从一定程度上降低Latency，这是因为在默认的状态下，for循环会创建额外的状态机，而状态机会创建额外的时钟周期，以及额外的资源，所以就会导致Latency和整个的资源用量都会有所改变，所以一旦合并，这两个方面都会降低</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C20.PNG" alt="20"></p>
<h3 id="对于循环边界不同的两个常数"><a href="#对于循环边界不同的两个常数" class="headerlink" title="对于循环边界不同的两个常数"></a>对于循环边界不同的两个常数</h3><p>如下代码中两个循环的循环边界是不同的，在合并之前是分开的，分别是4和2，合并之后trip count变成了4，也就是说，当两个循环的循环边界不同时，在合并时是以最大的边界作为合并后的边界</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C21.PNG" alt="21"></p>
<h3 id="循环边界有变量的场景（报错）"><a href="#循环边界有变量的场景（报错）" class="headerlink" title="循环边界有变量的场景（报错）"></a>循环边界有变量的场景（报错）</h3><p>如果一个循环的边界是常数，另一个循环的边界是变量的场景</p>
<p>在这个例子中，第一个循环的循环边界是常数，第二个循环的循环边界是变量，是函数的传入的一个参数</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C22.PNG" alt="22"></p>
<p>从综合后的报告可以看出，给出的trip count是一个范围，0 ~ 15，这是因为这里的变量K是一个ap_uint&lt;4&gt;的数据类型，四位无符号整数表示的最大范围就是0 ~ 15，所以这里的trip count就是0 ~ 15</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C23.PNG" alt="23"></p>
<p>如果在这两个for循环上应用loop merge，就会报错</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C24.PNG" alt="24"></p>
<p>所以当for循环的边界一个是常数，一个是变量的情形下，他们是不能合并的</p>
<h3 id="循环边界都是变量的场景（报错）"><a href="#循环边界都是变量的场景（报错）" class="headerlink" title="循环边界都是变量的场景（报错）"></a>循环边界都是变量的场景（报错）</h3><p>如下所示代码中，J和K都是变量</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C25.PNG" alt="25"></p>
<p>综合后的报告中可以看到trip count 是个范围，而不是固定的常数，都是0 ~ 15，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C26.PNG" alt="26"></p>
<p>同样对这两个for循环应用loop_merge，报错如下：</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C27.PNG" alt="27"></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>假如上面例子中的K &lt; J</p>
<p>因为K &lt; J，因此可以把J拆开，拆成两部分，一部分是0 ~ K，一部分是K ~ J</p>
<p>这样就可以把上面的for循环合并</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C28.PNG" alt="28"></p>
<p>综合后，在没有采用loop_merge的情况下有三个for循环</p>
<p>merge之后，只有两个for循环</p>
<p>所以当两个边界都是for循环时，可以通过修改代码实现for循环的合并</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C29.PNG" alt="29"></p>
<h2 id="合并规则"><a href="#合并规则" class="headerlink" title="合并规则"></a>合并规则</h2><p>1、当for循环的循环边界是固定常数的情况下，合并之后的for循环是以其中那个大的循环边界为边界</p>
<p>2、当两个for循环都是变量的情况下，他们必须是相同的值，也就是说，两个边界变量所能达到的最大值和最小值得是一样的，保证他们要有相同的迭代周期</p>
<p>3、如果循环边界一个是变量，一个是常数，他们是没法合并的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C30.PNG" alt="30"></p>
<p>在这一节中还引入了region的概念，region就是两个花括号之间的代码段，合并for循环可以帮助我们在一定程度上降低时钟周期，在Latency上有所改善，同时使一些for循环能够并行执行，但是要注意并不是所有的循环都能合并，我们需要遵循一定的规则</p>
<h1 id="for循环优化-数据流"><a href="#for循环优化-数据流" class="headerlink" title="for循环优化 - 数据流"></a>for循环优化 - 数据流</h1><h2 id="看一个例子-1"><a href="#看一个例子-1" class="headerlink" title="看一个例子"></a>看一个例子</h2><p>在下面的例子中有三个for循环，分别是Task A，Task B，Task C来做标记，同时for循环所用到的一些变量，也就是一些数组，看他的数据流是怎么样的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C31.PNG" alt="31"></p>
<p>首先进来的是数组A，通过循环Task A，生成变量x，x通过Task B，生成变量y，y通过Task C，生成变量C，通过这个例子可以看到，Task B依赖于Task A，因为Task B用到的变量x是通过Task A传过来的，同样Task C生成的C变量是取决于变量y的，所以可以看到A、B、C三个Task中间是有依赖关系的，结合前面for循环优化的两种方法，pipeline和loop merge，来进行优化</p>
<p>很显然pipeline是没问题的，但是merge是不可以的，因为他们之间存在依赖关系</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C32.PNG" alt="32"></p>
<h2 id="Dataflow（数据流）优化方式"><a href="#Dataflow（数据流）优化方式" class="headerlink" title="Dataflow（数据流）优化方式"></a>Dataflow（数据流）优化方式</h2><p>三个循环，在循环之间可以通过channel，channel可以是Ping-pong RAM，可以是FIFO，也可以是Register</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C33.PNG" alt="33"></p>
<p>在没有使用Dataflow时，三个循环的执行顺序就是如下A、B、C，使用Dataflow之后就变成右边的顺序，特点是，循环之间都是并行的关系，同时循环之间是有交叠的，从下图就可以看到，在执行loopA的时候并不需要执行完loopB就可以执行了，只要loopA有输出，就可以用loopA的输出去执行loopB，同时多个任务之间有交叠，这种交叠可以帮助我们降低Latency，而提高数据吞吐率</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C34.PNG" alt="34"></p>
<h2 id="运用Dataflow之后带来的性能上的好处"><a href="#运用Dataflow之后带来的性能上的好处" class="headerlink" title="运用Dataflow之后带来的性能上的好处"></a>运用Dataflow之后带来的性能上的好处</h2><p>可以看到Latency有明显的降低</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C35.PNG" alt="35"></p>
<p>再看utilization，也有很大的改善</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C36.PNG" alt="36"></p>
<p>此外，对于dataflow在使用的时候，每个for循环之间的channel时pingpong ram还是Register可以通过config_dataflow去配置</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C37.PNG" alt="37"></p>
<p>默认情况下，channel是ping-pong RAM</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C38.PNG" alt="38"></p>
<h2 id="Dataflow优化限制"><a href="#Dataflow优化限制" class="headerlink" title="Dataflow优化限制"></a>Dataflow优化限制</h2><p>并不是所有的for循环都可以使用dataflow，出现下面这些情况的，在使用的时候就要做一些优化或者改善，重点讲前两个</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C39.PNG" alt="39"></p>
<h3 id="Single-producer-consumer-Model"><a href="#Single-producer-consumer-Model" class="headerlink" title="Single-producer-consumer Model"></a>Single-producer-consumer Model</h3><p>在下面这个例子中，loop2和loop3，din通过Loop1会生成temp1，然后temp1通过Loop2会生成dout1，同时temp也会到Loop3生成dout2，所以可以看到temp1是被Loop1和Loop2这两个循环都使用到</p>
<p>这个例子可以使用pipeline，Loop2和Loop3也可以使用merge合并，因为他们两个都是使用temp1执行的</p>
<p>但是这个例子，不能使用dataflow，因为这个模型导致temp1在Loop2和Loop3两个循环中都使用， 所以要进行修改代码，使得可以使用dataflow</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C40.PNG" alt="40"></p>
<p> 首先编写循环loop_copy，在loop_copy中执行的操作很简单，就是把temp1赋给了temp2和temp3，temp2只是流向loop2，temp3只是流向loop3，接着又分别生成dout1和dout2，然后对其进行综合发现，此时的Latency和Interval都有所改善，utilization也有相应的改善，这个是旨在说明，变量只能在一个for循环中被使用</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C41.PNG" alt="41"></p>
<h3 id="Bypassing-Tasks-Model"><a href="#Bypassing-Tasks-Model" class="headerlink" title="Bypassing Tasks Model"></a>Bypassing Tasks Model</h3><p>这个例子是在Loop2中temp1会生成temp3，数据流如右图所示是din通过Loop1生成temp1，temp1通过Loop2生成temp3，但是Loop1中还有一个变量temp2会直接到Loop3，而没有经过Loop2，因此相对于Loop2而言他是Bypassing</p>
<p>这时候，pipeline是可以使用的，</p>
<p>但是如果使用merge，因为temp1在Loop2中会使用，temp2和temp3在Loop3会使用，temp3的数据来自于Loop2和Loop1，所以也是不能使用merge的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C42.PNG" alt="42"></p>
<p>但是我们可以进行优化</p>
<p>我们在Loop2中对temp2进行额外的复制，数据流是din通过Loop1生成temp1和temp2，然后temp1和temp2通过Loop2分别生成temp3和temp4，注意，temp4只是temp2的复制，这样temp2就在Loop2中有所体现，然后再通过Loop3生成dout，这时候就可以使用Dataflow，可以看到综合后的结果相应的Latency、Interval和Utilization都有所体现。</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C43.PNG" alt="43"></p>
<h3 id="配置Dataflow的内存通道（Configuring-Dataflow-Memory-Channels）"><a href="#配置Dataflow的内存通道（Configuring-Dataflow-Memory-Channels）" class="headerlink" title="配置Dataflow的内存通道（Configuring Dataflow Memory Channels）"></a>配置Dataflow的内存通道（Configuring Dataflow Memory Channels）</h3><p>这里说的Memery也就是channel，可以使用ping-pong也可以使用FIFO</p>
<p>1、如果参数是个scalar、pointer或者reference，Vivado HLS会把它作为FIFO</p>
<p>2、如果参数是个数组，结果可能是ping-pong RAM也可能是FIFO</p>
<ul>
<li>如果Vivado HLS能够判断出数据流是按顺序，也就是体现出FIFO的特征，那么这时候就会配置成FIFO，相应的depth深度为1</li>
<li>如果无法检查出数据的特征，也就是说数据的顺序是随机的，这时候就会把channel变成ping-pong RAM</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Configuring Dataflow Memory Channels</span><br><span class="line">Vivado HLS implements channels between the tasks as either ping-pong or FIFO buffers, depending on the access patterns of the producer and the consumer of the data.</span><br><span class="line"><span class="bullet"> - </span>For scalar, pointer, and reference parameters as well as the function return, Vivado HLS implements the channel as a FIFO.</span><br><span class="line"><span class="bullet"> - </span>If the parameter (producer or consumer) is an array, Vivado HLS implements the channel as a ping-pong buffer or a FIFO as follows.</span><br><span class="line"><span class="code">	• If Vivado HLS determines the data is accessed in sequential order, Vivado HLS implements the memory channel as a FIFO channel of depth 1.</span></span><br><span class="line"><span class="code">	• If Vivado HLS is unable to determine that the data is accessed in sequential order or determines the data is accessed in an arbitrary manner, Vivado HLS implements the memory channel as a ping-pong buffer. that is, as two block RAMs each defined by the maximum size of the consumer or producer array.</span></span><br><span class="line">配置数据流内存通道</span><br><span class="line">Vivado HLS根据数据生产者和消费者的访问方式，将任务之间的通道实现为ping-pong或FIFO缓冲区。</span><br><span class="line">  -对于scalar，指针和引用参数以及函数返回值，Vivado HLS将通道实现为FIFO。</span><br><span class="line">  -如果参数（生产者或消费者）是数组，则Vivado HLS将该通道实现为ping-pong缓冲区或FIFO，如下所示。</span><br><span class="line"><span class="code">	• 如果Vivado HLS确定按顺序访问数据，则Vivado HLS将存储通道实现为深度为1的FIFO通道。</span></span><br><span class="line"><span class="code">	• 如果Vivado HLS无法确定按顺序访问数据或确定以随机方式访问数据，则Vivado HLS将存储通道实现为ping-pong缓冲区。（也就是说，作为两个Block RAM，每个Block RAM由使用者或生产者阵列的最大大小定义。）</span></span><br></pre></td></tr></table></figure>

<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C44.PNG" alt="44"></p>
<h3 id="显式指定默认通道（To-explicitly-specify-the-default-channel）"><a href="#显式指定默认通道（To-explicitly-specify-the-default-channel）" class="headerlink" title="显式指定默认通道（To explicitly specify the default channel）"></a>显式指定默认通道（To explicitly specify the default channel）</h3><p>我们也可以通过config_dataflow很显式的告诉Vivado HLS这个Memery是FIFO还是ping-pong RAM，只是需要注意，一旦配置成FIFO，FIFO的深度如果配置的有问题，再RTL协同仿真的时候就会报错</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C45.PNG" alt="45"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>1、dataflow对for循环的改善，可以使得for循环并行的执行方式，也就是说相邻的顺序的变成了并行，体现在for循环可以重叠的执行，下一个for循环不必等到前一个for循环执行完了再执行，只要前一个for循环有输出，就可以利用当前的输出去执行下一个for循环</p>
<p>2、在使用dataflow的时候也有一些限制，最典型的就是上面所讲的那两个限制</p>
<p>3、对于for循环之间的memery也就是channel，我们可以缺省的使用默认的配置方式，也可以显式的配置为FIFO或者ping-pong RAM</p>
<h1 id="for循环优化-嵌套的for循环"><a href="#for循环优化-嵌套的for循环" class="headerlink" title="for循环优化 - 嵌套的for循环"></a>for循环优化 - 嵌套的for循环</h1><h2 id="嵌套for循环的分类"><a href="#嵌套for循环的分类" class="headerlink" title="嵌套for循环的分类"></a>嵌套for循环的分类</h2><p>在Vivado HLS中对嵌套的for循环有三种分类</p>
<h3 id="第一类是perfect-loop-nest"><a href="#第一类是perfect-loop-nest" class="headerlink" title="第一类是perfect loop nest"></a>第一类是perfect loop nest</h3><p>特征是循环边界都是常数，同时循环体只会在最内层的for循环里出现</p>
<h3 id="第二类是Semi-Perfect-loop-nest"><a href="#第二类是Semi-Perfect-loop-nest" class="headerlink" title="第二类是Semi-Perfect loop nest"></a>第二类是Semi-Perfect loop nest</h3><p>这种情况最外层的for循环循环边界是变量，但内层的循环边界是常数，同时循环体也只会在最内层的for循环里出现</p>
<h3 id="第三类是Imperfect-loop-nest"><a href="#第三类是Imperfect-loop-nest" class="headerlink" title="第三类是Imperfect loop nest"></a>第三类是Imperfect loop nest</h3><p>Imperfect loop nest其中又分成两类，</p>
<p>第一类是循环边界是常数，但是循环体出现在外部循环中，</p>
<p>第二类是尽管循环体只在内层for循环，但是最内部的for循环循环边界是个变量</p>
<p>对于Imperfect loop nest希望可以通过代码优化的手段把它转化成Semi-Perfect loop nest或者是Perfect loop nest</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C46.PNG" alt="46"></p>
<h2 id="perfect-loop的例子"><a href="#perfect-loop的例子" class="headerlink" title="perfect loop的例子"></a>perfect loop的例子</h2><p>这个例子是两个矩阵对应元素相乘，这里并不是矩阵的乘法，而是矩阵的元素对应相乘，这里M=2，N=4，是声明在头文件里的，然后做一个对比</p>
<p>三种情况：1、不加任何约束；2、只对内部for’循环做pipeline；3、只对外层循环做pipeline。</p>
<p>可以看到，只对外层for循环做pipeline的时候，Latency是最小的</p>
<p>而在资源消耗方面，对外层for循环做pipeline，DSP48E也就是乘法器，用到了4个，这其实是因为，当我们做流水的时候，如果是对外层for循环做流水，这个外层for循环下面的所有的for循环都会被打开，相应的资源也就会增加，所以这就是乘法器变成了4个的原因</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C47.PNG" alt="47"></p>
<p>如果对最内层的for循环做pipeline，就会看到控制台有一个输出信息，<code>Flattening a loop nest</code>，这时候trip count变成了8，也就是2x4，也就是把内部的for循环展开并打平，外部的for循环也是展开打平，所以count就变成了8</p>
<p>Loop_Flatten的要求是两个for嵌套的循环一定要是perfect loop或者是Simi-perfect loop，</p>
<h2 id="Imperfect-Loop的例子"><a href="#Imperfect-Loop的例子" class="headerlink" title="Imperfect Loop的例子"></a>Imperfect Loop的例子</h2><p>这个是矩阵的乘法，可以看到，在第二个for循环和第三个for循环之间有一个循环体，也就是初始化为0的操作，这两个矩阵都是3x3的矩阵</p>
<h3 id="如果只对最内层的for循环做pipeline（流水）"><a href="#如果只对最内层的for循环做pipeline（流水）" class="headerlink" title="如果只对最内层的for循环做pipeline（流水）"></a>如果只对最内层的for循环做pipeline（流水）</h3><p>1、如果只对最内层的for循环做流水，整个count外部的变成了9，内层的还是3，因为这个col对应的for循环和Product对应的for循环之间有循环体，是无法应用Loop Flatten的，所以这就是为什么Product对应的for循环是3，而Row和Col对应的for循环被打平</p>
<p>同时在分析结果中也可以看到，这个Imperfect loop是要做初始化的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C48.PNG" alt="48"></p>
<h3 id="如果只是对第二层for循环做pipeline"><a href="#如果只是对第二层for循环做pipeline" class="headerlink" title="如果只是对第二层for循环做pipeline"></a>如果只是对第二层for循环做pipeline</h3><p>2、如果只是对第二层for循环做pipeline，也就是Col对应的for循环做流水，首先会在输出信息中看到有一个Unrolling loop ‘Product’，也就是说把Col对应的for循环下面的所有for循环都会打开，所以这时候for循环就变成了Rol和Col都被打平，trip count变成了9，而内部的Product循环会被展开，在这里unrolling和flatten是不一样的概念</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOOP_FLATTEN的directive作用是“允许嵌套循环塌缩为一个循环以减少延时”，原文是“Allows netsed loops to be collapsed into a single loop with inproved latency”</span><br></pre></td></tr></table></figure>

<p>同时在分析表（右下）中还可以看到都有一个a load，同时在相应的信息中也可以看到，会有limited memory ports，在默认情况下会把数组声明为相应的memory，在这里他是一个双端口的memory</p>
<p>在这里得出结论，如果我们对上层的for循环做pipeline，那么这个for循环下面的所有for循环都会被unroll也就是会被展开</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C49.PNG" alt="49"></p>
<h3 id="如果只对最外层的for循环做pipeline"><a href="#如果只对最外层的for循环做pipeline" class="headerlink" title="如果只对最外层的for循环做pipeline"></a>如果只对最外层的for循环做pipeline</h3><p>3、如果只对最外层的for循环做pipeline，他会把下面的for循环全部展开（Unrolling），trip count变成了3，但是DSP48变成了9</p>
<p>这也进一步验证了以上的结论，对上层的for循环做流水，下面的for循环全都会被展开（Unrolling）</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C50.PNG" alt="50"></p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>四种情况</p>
<p>1、不加任何约束</p>
<p>2、对最内层循环做流水</p>
<p>3、对中间层循环做流水</p>
<p>4、对最外层循环做流水</p>
<p>可以看到，Latency的变化，显然，对最外层的循环做流水，可以获得最好的Latency，但是资源方面用到的DSP48是最多的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C51.PNG" alt="51"></p>
<h2 id="对整个函数做流水"><a href="#对整个函数做流水" class="headerlink" title="对整个函数做流水"></a>对整个函数做流水</h2><p>可以看到，整个函数中的循环都被展开了</p>
<p>对函数做流水，能获得最好的Latency，但是相应的，使用的资源也是最多的，DSP48变成了27个</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C52.PNG" alt="52"></p>
<h2 id="矩阵乘法优化"><a href="#矩阵乘法优化" class="headerlink" title="矩阵乘法优化"></a>矩阵乘法优化</h2><p>矩阵乘法的规则可以用相应的地址来表示，比如第i行第j列要算第k个乘法，那么要获得第0行第0列的数据，那么会执行什么样的操作呢？</p>
<p>就是a的第0行，b的第0列，相乘，然后再做相加，获得结果的第0行0列的元素</p>
<p>同样a的第0行，b的第1列，相乘，然后再做相加，获得结果的第0行1列的元素</p>
<p>那么在这个过程中可以看到，a的第0行在算结果的第0行的时候，是保持不变的，实际上我们只要读一次将他缓存起来就可以，而b需要读第0列、第1列、第2列… …，同样在算结果的第1行第0列、1列、2列的元素的时候，类似的也是，我们对a只需要读相应的第1行的元素，对b要读第0列、1列、2列的元素，都要遍历一下</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C53.PNG" alt="53"></p>
<p>经过上面的分析就可以对C代码进行优化，见Cache_Row，做了一个缓存的机制，也就是在计算结果的第0行的元素的时候，把a的第0行缓存下来</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C54.PNG" alt="54"> </p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>1、对循环或者函数做流水的时候，他们所在的下层的for循环都会被展开（unroll）</p>
<p>2、通常情况下，建议对最内部的函数做流水，这样既可以获得较好的Latency，同时资源用量也是可以接受的</p>
<h1 id="for循环优化-其他方法"><a href="#for循环优化-其他方法" class="headerlink" title="for循环优化 - 其他方法"></a>for循环优化 - 其他方法</h1><p>主要内容</p>
<ul>
<li><p>for循环的并行性</p>
</li>
<li><p>for循环在做流水的时候如何使用rewind option</p>
</li>
<li><p>当for循环的循环边界是变量的时候如何处理</p>
</li>
</ul>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C63.PNG" alt="63"></p>
<h2 id="for循环的并行性"><a href="#for循环的并行性" class="headerlink" title="for循环的并行性"></a>for循环的并行性</h2><p>这个例子中，这个函数包括两个for循环，sum_x和sum_y，这两个for循环分别用到了数组A和数组B，然后分别产生了相应的数组X和数组Y，可以看到这两个for循环是相互独立的，也就是说把他们翻译成相应的硬件电路是可以并行执行的，但是从综合后的结果来看，Vivado HLS是把他们做了顺序执行的，我们可以看到整个的Latency是18，来源于两个for循环串行相加的结果</p>
<p>所以，在默认的情况下，Vivado HLS是把for循环做顺序执行的，其实很容易想到，因为这两个for循环是相互独立的，循环边界都是常数且相等，因此可以用merge的方式降低Latency，但是当for循环的边界是变量的时候，是没有办法用merge的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C55.PNG" alt="55"></p>
<p>但是假如把for循环封装成一个函数，然后在顶层函数中对这个函数调用两次，这样的话综合后的结果跟前边的结果是一致的，这样可以看出来，Vivado HLS是把这个函数做了分时复用，相应的节省了资源，但是从并行性的角度而言，相应的函数还是顺序执行的，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C56.PNG" alt="56"></p>
<h3 id="使函数并行执行的方法"><a href="#使函数并行执行的方法" class="headerlink" title="使函数并行执行的方法"></a>使函数并行执行的方法</h3><p>那么有没有什么方式可以实现使函数并行执行呢，我们可以通过ALLOCATION这个directive可以实现让这两个函数并行执行，在这里这个AllOCATION有个limited = 2，就是说将这个函数Accumulator()复制了两份，换言之，这两个函数就实现了并行执行，这时我们可以看到Latency已经变成了10</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C57.PNG" alt="57"></p>
<h3 id="对上面两个结果进行比较"><a href="#对上面两个结果进行比较" class="headerlink" title="对上面两个结果进行比较"></a>对上面两个结果进行比较</h3><p>对上面两个结果进行比较，可以看到整个的Latency是降低了，这里的策略是将for循环封装成函数以后，采用了ALLOCATION的directive，同时把这个for循环做了pipeline，从仿真结果也可以看到，这个函数是并行执行的，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C58.PNG" alt="58"></p>
<h2 id="使用rrewind-option"><a href="#使用rrewind-option" class="headerlink" title="使用rrewind option"></a>使用rrewind option</h2><p>看下面这个for循环，这个for循环有三个操作，读、运算、写，如果我们只是添加了pipeline的策略，这时候，在执行完了一次for’循环在执行下一次for循环时，中间会有一个时钟周期的空挡，如果我们使用rewind之后，两次for循环之间时没有空挡的，这样就降低了整个函数的Latency，因为for循环的Latency降低了，从而也会将整个函数的Latency降低，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C59.PNG" alt="59"></p>
<h3 id="rewind使用举例"><a href="#rewind使用举例" class="headerlink" title="rewind使用举例"></a>rewind使用举例</h3><p>这是一个累加运算，</p>
<p>采用pipeline，并选中<code>enable loop rewinding (option)</code>，</p>
<p>这时候可以看到，在默认情况下，以及只添加pipeline，以及添加pipeline并选中rewind三种solution做了比较，</p>
<p>显然，采用添加pipeline并选中rewind的方式Latency时最小的，Interval也是最小的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C60.PNG" alt="60"></p>
<p>从仿真结果也可以看出来，在没有rewind的情况下，for循环在执行的时候，中间会有一段空挡，添加rewind之后就没有空档了，执行是连续的执行</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C61.PNG" alt="61"></p>
<h3 id="函数中有多个循环的情况"><a href="#函数中有多个循环的情况" class="headerlink" title="函数中有多个循环的情况"></a>函数中有多个循环的情况</h3><p>当我们的函数中有多个循环的时候，比如下面这个例子，有sum_x和sum_y，这时候如果我们再对这两个或者其中的某一个做rewind的时候，会抛出警告如下，告诉我们因为这个函数包含了多个循环，因此没法执行rewind，因此rewind不是适用于所有的for循环，他是有条件的</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C62.PNG" alt="62"></p>
<h3 id="如何对for循环自动添加流水"><a href="#如何对for循环自动添加流水" class="headerlink" title="如何对for循环自动添加流水"></a>如何对for循环自动添加流水</h3><p>这个时候就要用到config_compile configuration，这个是通过pipeline loops option来设置我们期望的循环次数，换言之，当这个循环次数小于我们设定的值的时候，这个循环就会被添加流水</p>
<p>比如这里的参数pipeline loops设置为6，那么当循环的次数小于6的时候就会被添加流水</p>
<p>如果在使用config_compile之后，如果仍然希望有一些for’循环不做流水，这时候我们就可以在directive的pipeline这个选项中将disable loop pipelining选项选中，那么相应的for循环就不会被添加流水，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C64.PNG" alt="64"></p>
<h3 id="添加pipeline失效的情况"><a href="#添加pipeline失效的情况" class="headerlink" title="添加pipeline失效的情况"></a>添加pipeline失效的情况</h3><p> 当我们对一个任务把它作为pipeline的时候，对于函数或者一个for循环，相应的这些函数或者for循环下边的操作都会被展开，那么如果这个for循环的循环边界是一个变量的话，就阻止了工具对相应的操作执行流水，这是因为Vivado HLS并不知道这个循环什么时候能够完成，这就是要讲的下一个问题，如何处理循环边界是变量的情形。</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C65.PNG" alt="65"></p>
<h3 id="如何处理循环边界是变量的情形"><a href="#如何处理循环边界是变量的情形" class="headerlink" title="如何处理循环边界是变量的情形"></a>如何处理循环边界是变量的情形</h3><p>当循环边界是变量的时候会引发一些问题，首先是Vivado HLS无法确定Loop的Latency是多少，进而也就无法确定整个函数的Latency，这时候相应的Latency会以问号作为标记，在下面的例子中，循环边界width是个变量，最后的综合报告中可以看到，Latency和Interval都是问号，这里这个width是个int型，也就是32位的一个整型</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C66.PNG" alt="66"></p>
<p>对于这种情况，有三种处理方式：</p>
<p>1、使用Tripcount的directive</p>
<p>2、将循环边界的数据类型声明为<code>ap_int&lt;w&gt;</code></p>
<p>3、使用assert这个macro</p>
<h4 id="使用Tripcount的directive的方式"><a href="#使用Tripcount的directive的方式" class="headerlink" title="使用Tripcount的directive的方式"></a>使用Tripcount的directive的方式</h4><p>先看一下使用Tripcount的directive的方式，在这里有一个min和一个max，是用来说明tripcount的最大值和最小值，相应的综合后的报告中就能看到，tripcount的值的范围是4 ~ 8，相应的Latency就有min和max，interval也有相应的min和max</p>
<p>这里需要注意的是，tripcount这个directive不会影响综合后的结果，不会对综合做任何的优化，只是用于报告的显示，以及不同solution之间的比较，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C67.PNG" alt="67"></p>
<h4 id="将循环边界的数据类型声明为ap-int-lt-w-gt"><a href="#将循环边界的数据类型声明为ap-int-lt-w-gt" class="headerlink" title="将循环边界的数据类型声明为ap_int&lt;w&gt;"></a>将循环边界的数据类型声明为<code>ap_int&lt;w&gt;</code></h4><p>再看一下将循环边界声明为<code>ap_int&lt;w&gt;</code>类型的情景，因为我们在头文件里定义了TEST，所以相应的循环边界的类型就变成了ap_int&lt;5&gt;，所以综合后的报告中tripcount就变成了0 ~ 15，因为5位有符号整数所能表示的最大值就是15</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C68.PNG" alt="68"></p>
<p>看一下综合后的结果，从资源角度看，整个的LUT会减少，触发器也会减少</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C69.PNG" alt="69"></p>
<h4 id="使用assert这个macro"><a href="#使用assert这个macro" class="headerlink" title="使用assert这个macro"></a>使用assert这个macro</h4><p>头文件添加<code>#include&lt;assert.h&gt;</code>，同时在for循环上边声明<code>assert(width &lt; 5);</code>，这时候tripcount就变成了0 ~ 4，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C70.PNG" alt="70"></p>
<p>综合后的报告可以看到，整个资源也会进一步减少，LUT从104变成了29，触发器由80变成了19，</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C71.PNG" alt="71"></p>
<p>对这三种方法进一步作比较，当采用assert这种方式的时候，Latency是最小的，同时相应的资源消耗也是最小</p>
<p><img data-src="E:%5Cblog2%5Csource_posts%5CVivadoHLS%E4%B9%8Bfor%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%5C72.PNG" alt="72"></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>1、当函数中有多个for循环的时候，即便多个for循环是相互独立的，Vivado HLS默认情况下也会让他们默认执行，而不是并行处理</p>
<p>2、当我们对for循环做pipeline的时候，我们可以选择rewind，帮助我们进一步改善Latency，但是并不是所有的for循环都能使用rewind</p>
<p>3、当循环边界是变量的时候，我们有三种处理方式，通过tripcount、通过改变循环边界的变量类型、通过采用assert三种方式，其中后两种方式是可以帮助我们改善综合后的一些结果，比如Latency以及资源。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Vivado-HLS/" rel="tag"><i class="fa fa-tag"></i> Vivado HLS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/04/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8VivadoHLS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" rel="prev" title="复合数据类型在Vivado HLS中的应用">
      <i class="fa fa-chevron-left"></i> 复合数据类型在Vivado HLS中的应用
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/07/VivadoHLS%E4%B9%8B%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96/" rel="next" title="VivadoHLS之数组优化">
      VivadoHLS之数组优化 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Powered by ylyang</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/npm/ribbon.js@1/dist/ribbon.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>


  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
